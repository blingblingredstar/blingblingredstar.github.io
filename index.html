<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="刘勇的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="刘勇的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="刘勇的博客">






  <link rel="canonical" href="http://yoursite.com/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>刘勇的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">刘勇的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/Deep-JavaScript-Foundations/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/Deep-JavaScript-Foundations/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 11:43:41" itemprop="dateCreated datePublished" datetime="2019-04-29T11:43:41+08:00">2019-04-29</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!DOCTYPE html>
    <html>
    <head><meta name="generator" content="Hexo 3.8.0">
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>介绍(Introduction)</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <hr>
<h2 id="title-deep-javascript-foundationsdate-2019-04-29-114232categories-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0tags-frontendmasters-javascript-%E9%97%AD%E5%8C%85-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B%E6%9C%BA%E5%88%B6">title: Deep JavaScript Foundations
date: 2019-04-29 11:42:32
categories: 学习笔记
tags: [FrontEndMasters, JavaScript, 闭包, 高阶函数, 面相对象, 原型机制]</h2>
<h2 id="%E4%BB%8B%E7%BB%8Dintroduction">介绍(Introduction)</h2>
<p>我们为什么要深入了解JavaScript？我们现在有了babel，我们有typescript，问什么还要学习JavaScript？</p>
<p>我们为什么要深入了解JavaScript？我们现在有了babel，我们有typescript，问什么还要学习JavaScript？
无论是vue、react、angular，都是建立在js之上的，并不能脱离js的范畴。js有的特性他们也有，js会产生的问题他们也会产生。</p>
<p>我们作为开发人员是有着有倾向性的，假设好的心理模型，当bug出现时，我们有时会责怪编程语言，但这并不是js的问题。js的设计有着复杂的历史原因，显然，更主要的原因使我们没有阅读规范。</p>
<p><a href="https://www.ecma-international.org/ecma-262/9.0/index.html#Title" target="_blank" rel="noopener">ECMA规范</a></p>
<p>问题出现时，你首先要找到那么权威的说明在哪里，然后阅读他。</p>
<p>首先应该问自己，规范是这样规定的吗？我所做的是否符合规范？</p>
<p>如果你想要代码按照你所设想的执行，那么唯一的方式就是了解你的代码时怎样执行的。</p>
<p>这节课的根本目的是了解js的底层原理（算法设计）。这样才能使我们成为一个更加高效的开发人员。如果我们不知道我们所编写的代码的作用，并且只是单纯的希望不要有bug，显然是个不切实际的想法。</p>
<p>这里举了一个例子：你能说出一个职业，一个完全建立在猜测之上的职业吗？</p>
<p>如果我们不了解js的运行机制，代码是如何工作的，而只是看到代码跑起来了，产生了一些结果，那么，我们是不是一个合格的开发人员呢？有的时候，我们会建立一个符合我们预期的心理模型，并且希望js能按照我们的心理模型计算出我们预期的结果。但显然，我们所建立的心理模型很有可能与js的运行模型并不一致，那么，bug的产生也就理所当然了。就像你不能指望一个建筑设计师说我认为这个墙有用，这个房子很结实，让大家住进去吧，看看是不是这样。</p>
<p>一般我们发现问题时，我们一般会在MDN上搜索查看资料，但是MDN并不是规范。所以当MDN无法解释时，我们要阅读规范。我们通过不断阅读规范修正我们的心理模型使其与js工作的模型逐渐一致，这样，我们也就能越来越接近bug free了。</p>
<p>作者认为js可以分为三个核心部分，不论是VUE、ANGULAR、REACT甚至是JQuery，都是js，都建立在以下三个支柱之上：</p>
<ol>
<li>类型(type)
<ul>
<li>原始类型(Primitive Type)</li>
<li>抽象操作(Abstract Operations)</li>
<li>强制转换(Coercion)</li>
<li>等于(Equality)</li>
<li>其他js语言(TypeScript,Flow,etc)</li>
</ul>
</li>
<li>作用域(Scope)
<ul>
<li>作用域范围(Nested Scope)</li>
<li>变量提升(Hoisting)</li>
<li>闭包(Closure)</li>
<li>模块化(Modules)</li>
</ul>
</li>
<li>面相对象(Objects(Oriented))
<ul>
<li>this</li>
<li>class{}</li>
<li>Prototypes</li>
<li>OO vs. OLOO</li>
</ul>
</li>
</ol>
<h2 id="%E7%B1%BB%E5%9E%8Btype">类型(Type)</h2>
<h3 id="%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8Bprimitive-types">原始类型(Primitive Types)</h3>
<p>在js中，一切都是对象。</p>
<blockquote>
<p>&quot;In JavaScript, everything is an object.&quot;</p>
</blockquote>
<p>这是不正确的说法。</p>
<p>这个说法的来源是js中的绝大部分值可以表现为对象，但他们并不是对象。</p>
<p>也许有许多人都是这样认为的，但是规范上并不是这样。</p>
<p>规范是这样说的：
ECMAScript语言类型对应于由使用ECMAScript语言的ECMAScript程序员直接操作的值。ECMAScript语言类型有Undefined、Null、Boolean、String、Symbol、Number和Object。ECMAScript语言值是以ECMAScript语言类型为特征的值。</p>
<blockquote>
<p>An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Symbol, Number, and Object. An ECMAScript language value is a value that is characterized by an ECMAScript language type.</p>
</blockquote>
<p>就像规范所规定一样，js中有七种原始类型</p>
<ol>
<li>undefined</li>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>symbol</li>
</ol>
<p>注意，在这里作者并没有将null放在原始类型中，作者认为null来源于js的历史错误之一，并在后面会解释他这样认为的原因。</p>
<p>在这里作者还举出了一些平时经常被我们误认为原始类型的“类型”</p>
<ul>
<li>undeclared(未声明的变量)</li>
<li>null(同上所述，被认为是历史错误)</li>
<li>function(不是原始类型，只是Object的“子对象”)</li>
<li>array(不是原始类型，只是Object的“子对象”)</li>
<li>bigint(即将加入到最新的规范中，已经在chrome v8引擎中实现。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">MDN文档</a>)</li>
</ul>
<p>所以除了Object、function以及array，其他并不是“对象”。</p>
<p>在js中，变量没有类型，但是变量的值有类型。</p>
<blockquote>
<p>In JavaScript, variables don't have types, values do.</p>
</blockquote>
<h3 id="typeof%E6%93%8D%E4%BD%9C%E7%AC%A6">typeof操作符</h3>
<blockquote>
<p>typeof操作符返回一个字符串，表示未经计算的操作数的类型。</p>
</blockquote>
<p>首先来看一段代码</p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">var</span> v
<span class="hljs-keyword">typeof</span> v    <span class="hljs-comment">// "undefined"</span>
v = <span class="hljs-string">'1'</span>
<span class="hljs-keyword">typeof</span> v    <span class="hljs-comment">// "string"</span>
v = <span class="hljs-number">2</span>
<span class="hljs-keyword">typeof</span> v    <span class="hljs-comment">// "number"</span>
v = <span class="hljs-literal">true</span>
<span class="hljs-keyword">typeof</span> v    <span class="hljs-comment">// "boolean"</span>
v = {}
<span class="hljs-keyword">typeof</span> v    <span class="hljs-comment">// "object"</span>
v = <span class="hljs-built_in">Symbol</span>()
<span class="hljs-keyword">typeof</span> v    <span class="hljs-comment">// "symbol"</span>
</div></code></pre>
<p>当我们使用typeof后加上变量v时，我们判断的不是变量v的类型，而是变量v当前值得类型。通过代码我们可以发现这一点，在我们给变量v重新赋值之后，typeof返回的结果也做出了变化，返回了我们所赋给变量v的值得类型的字符串。</p>
<p>在第二行，我们看到返回了一个undefined，这说明在我们声明一个变量时，会自动给变量赋值为undefined。我们理解undefined一般理解为变量还没有赋值，但我们可以理解为当前还没有值但可能会有。</p>
<p>这里注意，typeof操作符返回的是字符串，所以比较时应该也用字符串。</p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">typeof</span> doesnotExist   <span class="hljs-comment">// "undefined"</span>

<span class="hljs-keyword">var</span> v = <span class="hljs-literal">null</span>
<span class="hljs-keyword">typeof</span> v              <span class="hljs-comment">// "object" 注意，这里返回的预期是null，但是是object</span>

v = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}
<span class="hljs-keyword">typeof</span> v              <span class="hljs-comment">// “function” 这里很奇怪，因为预期返回object</span>

v = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-keyword">typeof</span> v              <span class="hljs-comment">// "object" 因为数组也是object类型，所以返回object</span>
</div></code></pre>
<p>作者在这里认为使用typeof判断null时返回&quot;object&quot;是因为ES1中的历史问题。当然，typeof判断函数时返回&quot;function&quot;可以帮助我们判断是不是函数，但是在判断数组时又失去了作用（现在使用Array.isArray()判断）。作者认为这也是历史原因，并且我们无法进行修复，因为这会导致许多建立与此的代码发生错误。</p>
<h3 id="bigint">Bigint</h3>
<p>bigint是规范中即将可能推出的新的原始类型,给一个变量赋值为42n时，代表了不仅仅是数字42，还代表了数字可以无限大，直到填满内存空间。</p>
<pre><code class="language-javascript"><div><span class="hljs-comment">// 即将推出</span>
<span class="hljs-keyword">var</span> v = <span class="hljs-number">42</span>n  <span class="hljs-comment">//or BigInt(42)</span>
<span class="hljs-keyword">typeof</span> v     <span class="hljs-comment">// "bigint"</span>
</div></code></pre>
<h3 id="kind-of-emptiness">Kind of Emptiness</h3>
<p>这里对未声明变量和变量的undefined进行了说明。在js中，变量未声明和变量声明后未赋值完全是两个概念。这也是因为历史原因，可能是不希望因为没有声明变量而阻断程序的运行。</p>
<p>在这里，为了解决这个问题，es6提出了uninitialized(也成为TDZ-the temporal dead zone-暂时性死区)。这个想法的初衷在于变量，例如块级作用域变量，不会进行初始化。一个未声明的变量不会被自动赋值为undefined。在一个未被初始化的作用域中，会被报错。</p>
<h3 id="nan--isnan">NaN &amp; isNaN</h3>
<p>NaN是not a number的缩写，顾名思义，应该代表了变量的值不是number类型。但实际上NaN代表了无效数字的值。</p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">var</span> myAge = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'0o46'</span>)        <span class="hljs-comment">// 38</span>
<span class="hljs-keyword">var</span> myNextAge = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'39'</span>)      <span class="hljs-comment">// 39</span>
<span class="hljs-keyword">var</span> myCatsAge = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'n/a'</span>)     <span class="hljs-comment">// NaN</span>
myAge - <span class="hljs-string">"my son's age"</span>            <span class="hljs-comment">// NaN</span>

myCatsAge === myCatsAge           <span class="hljs-comment">// false  注意此处!</span>

<span class="hljs-built_in">isNaN</span>(myAge)                      <span class="hljs-comment">// false</span>
<span class="hljs-built_in">isNaN</span>(myCatsAge)                  <span class="hljs-comment">// true</span>
<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"my son's age"</span>)             <span class="hljs-comment">// true   注意此处！</span>

<span class="hljs-built_in">Number</span>.isNaN(myCatsAge)           <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-string">"my son's age"</span>)      <span class="hljs-comment">// false</span>
</div></code></pre>
<p>在数学中，0是一个有意义的数字，但是当我们想给一个数字类型变量赋值，表示这不在是一个数字该怎么办（作者举了猫的例子，因为作者不再养猫，所以作者的猫的年龄不是数字）。在js中，减号表示数学相减运算，js会将符号两边的变量的值强制转换为数字，所以数字减去字符串，得到的是NaN。</p>
<p>在一般情况下，我们不希望使用==，以防止js自动为我们进行类型转换。而是使用===来判断两个变量代表的值是否相等。但是在上述代码中，因为ieee规定NaN不等于NaN自身，所以使用===判断时，即使两边变量代表的值是一样的，还是不相等。所以除了ieee规定的NaN不等于NaN，其他变量都全等于自身。</p>
<p>为了分清楚变量的值是否是NaN，我们有了isNaN运算符。同时要注意的是，在上述代码中我们给isNaN传入了一个字符串，理论上应该返回false，但是在isNaN进行判断前js认为我们传入的是一个数字，会进行强制的类型转换，所以最后判断为true。为了避免这种现象，我们有设计出了Number.isNaN()来避免强制类型转换，所以在最后一行我们传入string类型的值，得到了false。</p>
<p>NaN：无效的数字</p>
<blockquote>
<p>NaN: Invalid Number</p>
</blockquote>
<h3 id="%E8%B4%9F%E9%9B%B6negative-zero">负零(Negative Zero)</h3>
<p>如果你问一个数学家，数学家会告诉你不存在负零，但是在js中是存在的，是存在于ieee 754规范中的。</p>
<pre><code class="language-javascript"><div><span class="hljs-keyword">var</span> trendRate = <span class="hljs-number">-0</span>
trendRate === <span class="hljs-number">-0</span>            <span class="hljs-comment">// true</span>

trendRate.toString()        <span class="hljs-comment">// “0”   注意！</span>
trendRate === <span class="hljs-number">0</span>             <span class="hljs-comment">// true  注意！</span>
trendRate &lt; <span class="hljs-number">0</span>               <span class="hljs-comment">// false</span>
trendRate &gt; <span class="hljs-number">0</span>               <span class="hljs-comment">// false</span>

<span class="hljs-built_in">Object</span>.is(trendRate, <span class="hljs-number">-0</span>)    <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Object</span>.is(trendRate, <span class="hljs-number">0</span>)     <span class="hljs-comment">// false</span>
</div></code></pre>
<p>可以看到，当我们把-0转化为字符串是，得到的是&quot;0&quot;，并且-0全等于（===）0。<a href="http://xn--Object-957imklvi9bk30c0x2i2kd0o7e4dg.is" target="_blank" rel="noopener">在这里作者也介绍了Object.is</a>(),并将其比喻为====。顺便，<a href="http://Object.is" target="_blank" rel="noopener">Object.is</a>()也可以用来进行比较NaN。</p>
<p>在这里作者也举例了-0的应用实例：如果设计了一款游戏，想要让速度代表汽车行进方向，那么当汽车停止时，我们就需要0和-0来判断汽车停止时的行进方向。</p>
<pre><code class="language-javascript"><div><span class="hljs-built_in">Math</span>.sign(<span class="hljs-number">-3</span>)       <span class="hljs-comment">// -1</span>
<span class="hljs-built_in">Math</span>.sign(<span class="hljs-number">3</span>)        <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">Math</span>.sign(<span class="hljs-number">-0</span>)       <span class="hljs-comment">// -0   注意这里！</span>
<span class="hljs-built_in">Math</span>.sign(<span class="hljs-number">0</span>)        <span class="hljs-comment">// 0   注意这里！</span>

<span class="hljs-comment">// "fix" Math.sign(...)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sign</span>(<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">return</span> v !== <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.sign(v) : <span class="hljs-built_in">Object</span>.is(v, <span class="hljs-number">0</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>
}

sign(<span class="hljs-number">-3</span>)            <span class="hljs-comment">// -1</span>
sign(<span class="hljs-number">3</span>)             <span class="hljs-comment">// 1</span>
sign(<span class="hljs-number">-0</span>)            <span class="hljs-comment">// -1</span>
sign(<span class="hljs-number">0</span>)             <span class="hljs-comment">// 1</span>
</div></code></pre>
<h3 id="%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1fundamental-objects">基本对象(Fundamental Objects)</h3>
<p>基本对象(Fundamental Objects)也称作内置对象(Built-In Objects)或者原生功能(Native Functions)。</p>
<p>在一下功能中，作者建议一定要使用new关键字调用(可以看出，首字母均为大写，说明是一种构造函数)</p>
<ul>
<li>Object()</li>
<li>Array()</li>
<li>Function()</li>
<li>Date()</li>
<li>RegExp()</li>
<li>Error()</li>
</ul>
<p>一下是作者不建议使用new关键字的</p>
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
</ul>
<h2 id="%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2coercion">强制类型转换(Coercion)</h2>
<h3 id="%E6%8A%BD%E8%B1%A1%E8%BF%90%E7%AE%97abstract-operations">抽象运算(Abstract Operations)</h3>
<blockquote>
<p>这些操作不是ECMAScript语言的一部分;在这里定义它们仅仅是为了帮助ECMAScript语言的语义规范。在整个规范中定义了其他更专门化的抽象操作。
These operations are not a part of the ECMAScript language; they are defined here to solely to aid the specification of the semantics of the ECMAScript language. Other, more specialized abstract operations are defined throughout this specification.</p>
</blockquote>
<p>这段讲的就是js中的一些列抽象操作，主要就是类型转换(Type Conversion)，我们一般把js的类型转换成为强制类型转换(Coercion)，或则隐式类型转换，目前看来，这几个术语表达的应该是同一件事，及js自动进行的一系列操作。</p>
<h4 id="toprimitivehint-711">ToPrimitive(hint) (7.1.1)</h4>
<blockquote>
<p>抽象操作ToPrimitive接受输入参数和可选参数PreferredType。抽象操作ToPrimitive将其输入参数转换为非Object类型。如果一个对象能够转换为多个基本类型，它可以使用可选提示PreferredType来支持该类型。
The abstract operation ToPrimitive takes an input argument and an optional argument PreferredType. The abstract operation ToPrimitive converts its input argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint PreferredType to favour that type.</p>
</blockquote>
<p>注意，<code>ToPrimitive</code>并不是js引擎所实现的一个功能，我们并不能在js中进行调用。这是一个概念性的操作，是一个功能需求的描述，是一个算法描述。这个需求要求了在js中要把一些不是原始类型的值转化为原始类型。</p>
<p><code>ToPrimitive</code>描述了如果你有一个非原始类型的值，你希望他转化成哪种基本类型。就像进行数学运算，会自动调用<code>ToPrimitive</code>将运算符两边的值转化为数字类型，但是注意，这并不能保证这个值一定能转化为<code>Nubmer</code>类型。</p>
<p>在js的算法设计中，递归是很主要的一部分。例如调用<code>ToPrimitive</code>后返回的仍不是一个属于原始类型的值，就会不断调用<code>ToPrimitive</code>知道返回一个可以操作的值。</p>
<p>基本上<code>ToPrimitive</code>会传入两种参数<code>number</code>和<code>string</code>，如果<code>number</code>，首先会调用<code>valueOf()</code>方法进行转换，如果转换失败，会调用<code>toString()</code>方法。传入<code>string</code>时正好相反，会首先调用<code>toString()</code>，然后调用<code>valueOf()</code>方法。</p>
<h4 id="tostring-7112">ToString (7.1.12)</h4>
<blockquote>
<p>抽象操作ToString:根据参数将参数转换为String类型的值
The abstract operation ToString converts argument to a value of type String</p>
</blockquote>
<p><code>null &quot;null&quot;</code>
<code>undefined &quot;undefined&quot;</code>
<code>true &quot;true&quot;</code>
<code>false &quot;false&quot;</code>
<code>3.14159 &quot;3.14159&quot;</code>
<code>0 &quot;0&quot;</code>
<code>-0 &quot;0&quot; // 注意，这里返回的与预期有一些出入</code></p>
<p>以上是对一些值调用<code>toString()</code>方法后的返回结果，在大多数情况下，返回的结果与我们的预期也相符</p>
<p>当接收数组作为参数时，会有如下返回结果</p>
<p><code>[] &quot;&quot;</code>
<code>[1,2,3] &quot;1,2,3&quot;</code>
<code>[null,undefined] &quot;,&quot;</code>
<code>[[[],[],[]],[]] &quot;,,,&quot;</code>
<code>[,,,,] &quot;,,,&quot;</code></p>
<p>可以发现，<code>toString()</code>方法传入数组时，会将数组的[]去掉并返回值，当值为null或undefined时，会保留位置但是并没有值，所以在传入数组时返回的结果与我们的预期很不相符。</p>
<p>当接收对象作为参数时，有如下表现：</p>
<p><code>{} &quot;[object Object]&quot;</code>
<code>{a:2} &quot;[object Object]&quot;</code>
<code>{ toString(){ return &quot;X&quot;; } } &quot;X&quot;</code></p>
<h4 id="tonumber-713">ToNumber (7.1.3)</h4>
<blockquote>
<p>抽象操作ToNumber将参数转换为类型为Number的值
The abstract operation ToNumber converts argument to a value of type Number</p>
</blockquote>
<p>上面也提到过，当我们想做一件事，这件事需要操作数字时，就会自动调用<code>ToNumber()</code>将值转为Number类型。</p>
<p><code>&quot;&quot; 0</code>
<code>&quot;0&quot; 0</code>
<code>&quot;-0&quot; -0</code>
<code>&quot;009&quot; 9</code>
<code>&quot;3.14159&quot; 3.14159</code>
<code>&quot;0.&quot; 0</code>
<code>&quot;.0&quot; 0</code>
<code>&quot;.&quot; NaN</code>
<code>&quot;0xaf&quot; 175</code></p>
<p>通过上面的调用结果，比较值得注意的就是空字符会转为0。</p>
<p><code>false 0</code>
<code>true 1</code>
<code>null 0</code>
<code>undefined NaN</code></p>
<p>上面比较值得注意的是null会转化为0，而不是像undefined一样转化为NaN。</p>
<p>在传入数组时，会有以下表现（会先将数组调用toString，所以空数组返回0）</p>
<p><code>[&quot;&quot;] 0</code>
<code>[&quot;0&quot;] 0</code>
<code>[&quot;-0&quot;] -0</code>
<code>[null] 0</code>
<code>[undefined] 0</code>
<code>[1,2,3] NaN</code>
<code>[[[[]]]] 0</code></p>
<p>传入对象时，有如下表现：</p>
<p><code>{ .. } NaN</code>
<code>{ valueOf() { return 3; } } 3</code></p>
<h4 id="toboolean-712">ToBoolean (7.1.2)</h4>
<blockquote>
<p>抽象操作ToBoolean将参数转换为Boolean类型的值<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-toboolean" target="_blank" rel="noopener">7.1.2ToBoolean ( argument )</a>
The abstract operation ToBoolean converts argument to a value of type Boolean</p>
</blockquote>
<p><code>Falsy Truthy</code>
<code>“” “foo”</code>
<code>0,-0 23</code>
<code>null { a:1 }</code>
<code>NaN [1,3]</code>
<code>false true</code>
<code>undefined function(){..} ...</code></p>
<p>一般我们只需记住Falsy部分即可，其他不属于Falsy的均转换为true。当我们仅仅只调用<code>ToBoolean</code>时并没与其他强制转换发生，所以将一个空数组输入会返回true。</p>
<h4 id="%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2coercion-1">强制类型转换Coercion</h4>
<p>在我们学习js时，我们都知道js是一门动态类型语言，会进行类型转换，我们也在极力避免类型转换的发生</p>
<blockquote>
<p>You claim to avoid coercion because it's evil, but...</p>
</blockquote>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> numStudents = <span class="hljs-number">16</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`there are <span class="hljs-subst">${numStudents}</span> students`</span>) <span class="hljs-comment">// there are 16 students</span>
</div></code></pre>
<p>在上述代码中，我们就进行了类型转换。在这方面，类型转换是的输出结果符合了我们的心理预期。在这里我们使用了类型转换，我们就要了解类型转换帮我们做了什么。</p>
<p>这里还举例了许多其他案例，不一一叙述。</p>
<h4 id="boxing">Boxing</h4>
<p>我们知道我们可以通过.value.length访问一个原始类型值得值得长度。这是因为原始类型值是对象吗？根据规范可知并不是，这是应为在我们通过点方法访问一个非对象的属性时，js使用类型转换帮我们转换为了对象，以防报错阻止程序运行。</p>
<h2 id="philosophy-of-coercion">Philosophy of Coercion</h2>
<h3 id="intentional-coercion">Intentional Coercion</h3>
<p>您不需要通过避免强制转换来处理这些类型转换的特殊情况。</p>
<blockquote>
<p>You don't deal with these type conversion corner cases by avoiding coercions.</p>
</blockquote>
<p>相反，您必须采用一种使值类型简单明了的编码风格。</p>
<blockquote>
<p>Instead, you have to adopt a coding style that makes value types plain and obvious.</p>
</blockquote>
<p>一个高质量的JS程序应该积极拥抱强制类型转换，确保每个操作涉及的类型都是清晰的。因此，边缘案例是处于安全管理下的。</p>
<blockquote>
<p>A quality JS program embraces coercions, making sure the types involved in every operation are clear. Thus, corner cases are safely managed.</p>
</blockquote>
<p>JavaScript的动态类型不是缺点，而是它的一个优点</p>
<blockquote>
<p>JavaScript's dynamic typing is not a weakness, it's one of its strong qualities</p>
</blockquote>
<h3 id="culture-of-learning">Culture of Learning</h3>
<p>这里作者对于初级开发者的学习也提出了一些建议。初级开发者会在一些基本问题上犯错误，这很正常。如果一个初级开发者碰到了边缘案例没有发现错误，应该与其讨论边缘案例所发生的情况。一个比较懒惰的观点就是指望团队的每一个人都一直学习，一直进步。但这也是不现实的，我们首先应该确保自身在不断学习进步，更加了解我们使用的工具。代码是一种交流方式。</p>
<h3 id="implicit-coercion">Implicit Coercion</h3>
<p>隐式类型转换不是魔术，也不是一件坏事，是一个抽象的方法。</p>
<p>我们会隐藏不必要的细节，避免读者注意力的分散，并使读者更清楚所做的事。</p>
<blockquote>
<p>Hiding unnecessary details, re-focusing the reader and increasing clarity</p>
</blockquote>
<p>js更好入门的原因之一就是不会强迫开发人员处理各种复杂的类型转换。</p>
<p>这里作者认为问题的关键还是对开发人员的思维负担到底是增加了还是减少了。</p>
<blockquote>
<p>Is showing the reader the extra type details helpful or distracting?</p>
</blockquote>
<h3 id="understanding-feature">Understanding Feature</h3>
<p>以下是道格拉斯克劳柯福德在js语言精粹中的观点：</p>
<blockquote>
<p>&quot;If a feature is sometimes <strong>useful</strong> and sometimes <strong>dangerous</strong> and if there is a better option then always use the <strong>better</strong> option.&quot;
-- &quot;The Good Parts&quot;, Crockford</p>
</blockquote>
<p>在这里，作者提出了他的观点：</p>
<blockquote>
<p>Useful: when the reader is focused on what's important
Dangerous: when the reader can't tell what will happen
Better: when the reader understands the code
作者还认为：
故意避免使用可以提高代码可读性的特性是不负责任的
It is irresponsible to knowingly avoid usage of a feature that can improve code readability</p>
</blockquote>
<h2 id="equality">Equality</h2>
<h3 id="double--triple-equals">Double &amp; Triple Equals</h3>
<p>一般我们把==成为松散比较或者不严格比较，===成为严格比较。</p>
<blockquote>
<p>== checks value (loose)
=== checks value and type (strict)</p>
</blockquote>
<p>但事实上可能并不如此。</p>
<blockquote>
<p>If you're trying to understand your code, it's critical you learn to think like JS</p>
</blockquote>
<p>这里作者深入的讲述了==和===所表现出的一些行为及其导致的问题。</p>
<p>这是关于==及===的规范链接<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-abstract-equality-comparison" target="_blank" rel="noopener">ECMA</a>。</p>
<p>以下是规范中关于==部分：</p>
<blockquote>
<p>Abstract Equality Comparison
The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:
1.If Type(x) is the same as Type(y), then
1.1.Return the result of performing Strict Equality Comparison x === y.
2.If x is null and y is undefined, return true.
3.If x is undefined and y is null, return true.
4.If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y).
5.If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y.
6.If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y.
7.If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y).
8.If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).
9.If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.
Return false.</p>
</blockquote>
<p>以下是关于===部分：</p>
<blockquote>
<p>Strict Equality Comparison
The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows:
1.If Type(x) is different from Type(y), return false.
2.If Type(x) is Number, then
2.1.If x is NaN, return false.
2.2.If y is NaN, return false.
2.3.If x is the same Number value as y, return true.
2.4.If x is +0 and y is -0, return true.
2.5.If x is -0 and y is +0, return true.
2.6.Return false.
3.Return SameValueNonNumber(x, y).</p>
</blockquote>
<p>关键注意关于==的第一条，第一条说明了即使使用==号，也会先进行===比较，如果类型一致，直接返回===比较后的结果。之前说过，规范是js代码实现的算法描述，在实现==的算法描述第一步，就进行了类型比较。所以==和===都进行了类型比较，只不过==要在===比较失败时进行一些其他情况的判定并返回比较结果。所以当两个值得类型相同时，==与===没有任何区别。</p>
<p>所以真正重要的是作为开发人员要清楚地知道自己要比较的两个值是什么类型。</p>
<p>所以==与===的区别就在于我们是否允许两个比较值进行类型转换。因为===是短路操作，如果类型不同直接返回false。但是==允许在类型不同时进行类型转换后递归比较。</p>
<p>在这里注意，比较两个对象时，应为变量保存的是对象的引用地址，所以即使两个对象的结构及字面量一致，返回的也是false。</p>
<blockquote>
<p>== allows coercion (types different)
=== disallows coercion (types same)</p>
</blockquote>
<h3 id="coercive-equality">Coercive Equality</h3>
<p>和其他操作一样，强制类型转换是否有助于等于比较?</p>
<blockquote>
<p>Like every other operation, is coercion helpful in an equality comparison or not?</p>
</blockquote>
<p>你可以问自己，如果我很明确要比较的数据类型，强制类型转换是否对我有帮助？</p>
<p>使用==并不意味着坏的，而是意味着我是否允许比较的数据进行类型转换。如果当前情况下进行类型转换对我是否更有帮助，是更安全还是更危险。如果你不确定要比较的数据的类型，那么想办法在其他部分是数据类型更加明确是不是更好的选择？</p>
<p>使用==的优势之一可以参考规范的第2条及第3条，既免于我们判断数据类型为空时，到底是<code>===null</code>还是<code>===undefined</code>。</p>
<p>这里作者也提出了lint工具只是一个参考，lint工具通过预先制定好的规则来判断代码是否符合规范，但是规范只是参考，并不能保证代码就一定不出错。关于代码规范，每个人也有不同的看法。我们应该让团队自己决定团队的代码规范。</p>
<h3 id="double-equals-algorithm">Double Equals Algorithm</h3>
<p>可以从上面的规范看出，==号的算法设计倾向于把两个值转化为数字类型进行比较，当比较值不是原始类型值（数组等），会转化为原始类型值进行比较。</p>
<h3 id="double-equals-summary">Double Equals Summary</h3>
<blockquote>
<p>If the types are the same: ===
If null or undefined: equal
If non-primitives: ToPrimitive
Prefer: ToNumber</p>
</blockquote>
<p>==的算法摘要：如果类型一致就是用===判断，如果是null或者undefined就返回true，如果不是原始类型就转化为原始类型进行比较，最后比较时倾向于把值转化为number类型进行比较</p>
<h3 id="corner-cases-summary">Corner Cases: Summary</h3>
<p>我们应在使用==判断时避开边缘案例的几个主要场景</p>
<ol>
<li>== with 0 or &quot;&quot; (or even &quot; &quot;)</li>
<li>== with non-primitives</li>
<li>== true or == false : allow ToBoolean or use ===</li>
</ol>
<p>不要使用==比较0，空字符串，或包含空格的空字符串。
不要用==比较非原始类型的值。
不要判断一个值是否==true或者==false，如果不得不比较，使用===。</p>
<h3 id="the-case-for-preferring">The case for preferring ==</h3>
<p>了解类型总是比不了解它们好</p>
<blockquote>
<p>Knowing types is always better than not knowing them
静态类型不是了解类型的唯一(甚至不一定是最好的)方法
Static Types is not the only (or even necessarily best) way to know your types
如果你不了解你要比较的数据类型，不要使用==
== is not about comparisons with unknown types
==是关于与已知类型的比较，在类型转换非常有帮助的情况下可以选择
== is about comparisons with known type(s), optionally where conversions are helpful</p>
</blockquote>
<h2 id="static-typing">Static Typing</h2>
<h3 id="typescript--flow">TypeScript &amp; Flow</h3>
<p>优点：</p>
<blockquote>
<p>Benefits:</p>
</blockquote>
<ol>
<li>捕获类型相关的错误
<blockquote>
<p>Catch type-related mistakes</p>
</blockquote>
</li>
<li>交流类型的意图（直接在代码上表示出类型而不是注释，使得代码更加易读）
<blockquote>
<p>Communicate type intent</p>
</blockquote>
</li>
<li>编辑器的提示支持
<blockquote>
<p>Provide IDE feedback</p>
</blockquote>
</li>
</ol>
<p>警告：</p>
<blockquote>
<p>Caveats:</p>
</blockquote>
<ol>
<li>推断是最好的猜测，而不是保证
<blockquote>
<p>Inferencing is best-guess, not a guarantee</p>
</blockquote>
</li>
<li>注释是可选的
<blockquote>
<p>Annotations are optional</p>
</blockquote>
</li>
<li>应用程序中任何没有类型化的部分都会带来不确定性
<blockquote>
<p>Any part of the application that isn't typed introduces uncertainty</p>
</blockquote>
</li>
</ol>
<h3 id="inferencing">Inferencing</h3>
<p>有些人认为动态类型的最大的问题之一是会意外的导致变量赋值为我们预期之外的类型，对于持有这个观点的人来说，静态类型检查是一个很好的解决方案。</p>
<h3 id="custom-types--signatures">Custom Types &amp; Signatures</h3>
<p>函数的参数类似一个变量，如果你在ts中说我希望只传递数字，也就是再说我希望该变量只保存数字。</p>
<h3 id="validating-operand-types">Validating Operand Types</h3>
<p>作者认为在typescript中有一件事被低估了，除了静态类型检查，它还可以告诉我们有些操作是无效的，例如你无法用一个数字减去一个字符串，也就是说不要使用强制类型转换，这在有时对我们很有帮助。</p>
<h3 id="typescript-vs-flow">TypeScript vs. Flow</h3>
<p>嗯。。。似乎flow已经凉了。。。vue的作者已经全面转向了TypeScript，所以。。。</p>
<h3 id="typescript--flow-pros-and-cons">TypeScript &amp; Flow: Pros and Cons</h3>
<p>下面是作者认为的js的静态类型语言一些优缺点：</p>
<p>让代码的类型更为明显。</p>
<blockquote>
<p>They make types more obvious in code
与其他语言的相似性很高，减少了学习成本及思维负担。
Familiarity: they look like other language's type systems
流行程度高，社区活跃。
Extremely popular these days
对于语言特性支持的比较好。
They're very sophisticated and good at what they do
它们使用“非js标准”语法(或代码注释)。
They use &quot;non-JS-standard&quot; syntax (or code comments)
它们需要一个构建过程，这增加了进入的障碍。
They require* a build process, which raises the barrier to entry
对于那些没有正式类型经验的人来说，它们的复杂性可能令人生畏。
Their sophistication can be intimidating to those without prior formal types experience
它们更关注“静态类型”(变量、参数、返回、属性等)，而不是值类型。
They focus more on &quot;static types&quot; (variables, parameters, returns, properties, etc) than value types
对运行时行为有信心的唯一方法是限制/消除动态类型。
The only way to have confidence over the runtime behavior is to limit/eliminate dynamic typing</p>
</blockquote>
<h3 id="understanding-your-types">Understanding Your Types</h3>
<p>JavaScript有一个(动态)类型系统，它使用各种形式的强制类型转换进行值的数据类型转换，包括相等比较</p>
<blockquote>
<p>JavaScript has a (dynamic) type system, which uses various forms of coercion for value type conversion, including equality comparisons</p>
</blockquote>
<p>js的值是有类型的，变量没有。</p>
<p>然而，流行的响应似乎是:尽可能避免使用这个系统，并使用===“保护”自己，免于担心类型转换。</p>
<blockquote>
<p>However, the prevailing response seems to be: avoid as much of this system as possible, and use === to &quot;protect&quot; from needing to worry about types</p>
</blockquote>
<p>避免使用所有类型的JS(比如假装===)的部分问题在于，它可能会在系统上延续bug</p>
<blockquote>
<p>Part of the problem with avoidance of whole swaths of JS, like pretending === saves you from needing to know types, is that it tends to systemically perpetuate bugs</p>
</blockquote>
<p>如果不知道操作中涉及的类型，就无法编写高质量的JS程序。</p>
<blockquote>
<p>You simply cannot write quality JS programs without knowing the types involved in your operations.</p>
</blockquote>
<p>另外，许多人选择采用不同的“静态类型”系统
虽然在某些方面确实有帮助，但这是另一种“回避”</p>
<blockquote>
<p>Alternately, many choose to adopt a different &quot;static types&quot; system layered on top
While certainly helpful in some respects, this is &quot;avoidance&quot; of a different sort</p>
</blockquote>
<p>显然，JS的类型系统较差，所以必须替换它，而不是学习和利用
许多人声称JS的类型系统对于新开发人员来说太难学了，而且静态类型(以某种方式)更容易学
我的主张:更好的方法是接受并学习JS的类型系统，并采用一种使类型尽可能明显的编码风格
通过这样做，您将使您的代码对有经验的开发人员和新开发人员都更具可读性和健壮性</p>
<blockquote>
<p>Apparently, JS's type system is inferior so it must be replaced, rather than learned and leveraged
Many claim that JS's type system is too difficult for newer devs to learn, and that static types are (somehow) more learnable
My claim: the better approach is to embrace and learn JS's type system, and to adopt a coding style which makes types as obvious as possible
By doing so, you will make your code more readable and more robust, for experienced and new developers alike</p>
</blockquote>
<h2 id="scope%E4%BD%9C%E7%94%A8%E5%9F%9F">Scope(作用域)</h2>
<h3 id="scope">Scope</h3>
<ul>
<li>Nested Scope • Hoisting(嵌套范围•提升)</li>
<li>Closure(闭包)</li>
<li>Modules(模块化)</li>
</ul>
<p>之前作者提出了他认为的js的三大支柱，分别为类型系统(Types)，作用域(Scope)和面向对象(Object(Oriented))。</p>
<p>首先我们要理解词法作用域(lexical scope)，词法作用域时js的运行机制之一。理解词法作用域之后我们就可以理解闭包，理解闭包之后我们就能理解模块化。</p>
<blockquote>
<p>Scope: where to look for things
作用域使我们寻找数据的地方。为了理解作用域，首先要明确几个问题。</p>
</blockquote>
<p>第一，我们在寻找什么？一般而言，我们寻找的是标识符。所以当我们处理代码时，当js引擎处理作用域时，js引擎基本上是在处理这个问题：当我看到这个变量时，这个变量处于什么位置？处于哪个作用域？作者做了一个比喻，就像有几个不同颜色的桶，里面装了对应颜色的石头。当js想要找绿色石头时，显然会去绿色桶中去找。</p>
<p>在这里，作者认为js不是一个脚本语言，而是一个编译语言。js在执行前会进行编译，或者说解析。作者提出了证据，就是假设在代码第100行有一个语法错误，js会在执行一开始就报错，而不是执行完前99行后进行报错。这说明了js会在执行开始前对代码进行解析。那么，js会进行哪些解析处理？</p>
<p>在编辑器理论中，有着四个编译阶段（有时可能有的阶段合并，有的时候分开）：</p>
<ol>
<li>lexing(词法分析)</li>
<li>tokenization(标记)</li>
<li>parsing(将token转化为抽象语法树)</li>
<li>code generation(代码生成)</li>
</ol>
<p>这是文本代码转化为可执行机械码的一般过程。</p>
<p>一般认为js是脚本语言的原因之一是没有运行编译器进行编译，这是许多人区别脚本语言和编译语言的心理模型。在这里，作者认为正确的分析方式应该是代码在执行前究竟有没有进行解析执行。作者在这里提出js是编译语言的原因是引发js对作用域建立时机的思考（js是什么时候把不同颜色的石头装到不同颜色的桶之中的）。如果我们认为js是边执行边分类的话那么显然会导致一些错误。这就产生了我们预期心理模型与js执行模型的分歧。所以我们在这里所做的就是使我们的大脑的思维方式尽量与编译器一致，我们在这里希望我们能像编译器一样思考。好消息是我们可以根据二八原则，只学习百分之二十的编译器思想就可以避免百分之八十的问题，剩下的百分之二十的问题暂时与我们无关。在这里，把不同石头提前装到不同颜色的桶中就类似js处理作用域并把对应标识符放置在对应作用域。</p>
<p>所以js在执行前，会有一个编译阶段，并在编译阶段中生成抽象语法树的同时也生成了词法作用域，然后交于js引擎解析执行代码。所以js会先处理代码，生成词法作用域，然后解析执行。</p>
<p>既然在上面的例子中不同颜色的石头代表了标识符，那么水桶代表了什么？</p>
<p>函数作用域和块级作用域(ES6中新增)</p>
<blockquote>
<p>JavaScript organizes scopes with functions and blocks</p>
</blockquote>
<h3 id="compilation--scope%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F">Compilation &amp; Scope(编译和作用域)</h3>
<p>代码分析：</p>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Kyle'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">otherClass</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Suzy'</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'welcome!'</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> question = <span class="hljs-string">'why?'</span>
  <span class="hljs-built_in">console</span>.log(question)
}

otherClass()
ask()
</div></code></pre>
<p>在分析时强调了js的所有词法作用域在js执行前的编译阶段就已经创建，这样在运行时才可以顺利的访问不同词法作用域的不同变量。</p>
<h3 id="executing-code">Executing Code</h3>
<p>在js中，变量拥有两个角色，一个是存储数据，一个是在需要获取数据时代表数据。这样我们就可以把数据和变量关联起来。变量(variable)和值(value)的关系更像是源(source)和目标(target)。</p>
<p>如果试图给一个未声明的变量赋值，js会自动将该变量添加到全局作用域中。</p>
<h3 id="strict-mode">Strict Mode</h3>
<p>把<code>&quot;use strict&quot;</code>关键字放在作用域顶部，即可切换为严格模式。在严格模式下，给未声明的变量赋值会导致引用错误(ReferenceError)。</p>
<h3 id="nested-scope%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%A5%97%E5%B5%8C">Nested Scope(作用域套嵌)</h3>
<p>作用域套嵌还可以用水桶比喻，套嵌可以类比为水桶里面装水桶，里面的水桶没有就到外面的水桶中找，所以闭包也就是直接返回小水桶，但是小水桶带着外面大水桶的石头（引用了外部函数执行上下文中的变量，并且函数的参数可以视作在函数内部声明的新变量，其值与传入的实参的值相同），在内部的水桶可以找到外部水桶中的石头，但是外部的无法找到内部水桶中的石头。</p>
<h3 id="undefined-vs-undeclared">Undefined vs Undeclared</h3>
<p>变量未声明与变量未赋值到底有什么区别？undefined表示变量存在但是目前没有任何值（有可能之前有，也有可能之后有但是目前没有）；未声明表示在我们的所有作用域中不存在这个变量。</p>
<h3 id="lexical-scope-elevator">Lexical Scope Elevator</h3>
<p>在这里作者把词法作用域比作一个有电梯的高层建筑物，如果你想在这样一个大厦找东西，首先在第一层找（当前执行上下文），没有就坐电梯（作用域链）到第二层找（上级作用域），最终到顶楼找（全局作用域）。</p>
<h2 id="scope--function-expressions%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">Scope &amp; Function Expressions(作用域和函数表达式)</h2>
<h3 id="function-expressions%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">Function Expressions(函数表达式)</h3>
<p>在之前，我们在编译阶段分析函数时，将函数比喻为特殊颜色的水桶，放在全局作用域这个水桶中，并将函数内声明的变量标记为与函数代表的水桶颜色相同的石头放入当前水桶。</p>
<p>下面看一段代码</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">teacher</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/*...*/</span> }  <span class="hljs-comment">// 函数声明</span>

<span class="hljs-keyword">var</span> otherTeacher = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/* otherTeacher */</span> }

<span class="hljs-keyword">var</span> myTeacher = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anotherTeacher</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 函数表达式</span>
  <span class="hljs-built_in">console</span>.log(anotherTeacher)
}

<span class="hljs-built_in">console</span>.log(teacher) <span class="hljs-comment">// ƒ teacher() { /*...*/ }</span>
<span class="hljs-built_in">console</span>.log(otherTeacher) <span class="hljs-comment">// ƒ () { /* otherTeacher */ }</span>
<span class="hljs-built_in">console</span>.log(myTeacher) <span class="hljs-comment">// ƒ anotherTeacher() { console.log(anotherTeacher) }</span>
<span class="hljs-built_in">console</span>.log(anotherTeacher) <span class="hljs-comment">// ReferenceError: anotherTeacher is not defined</span>
</div></code></pre>
<p>但是函数声明和函数表达式是有区别的，函数表达式会将函数名作为变量注册到局部作用域中，所以在全局作用域中无法通过函数名访问通过函数表达式定义的函数，可以通过将函数表达式赋值给变量，通过变量访问函数。</p>
<h4 id="named-function-expressions">Named Function Expressions</h4>
<p>在上述代码中，<code>otherTeacher</code>与<code>anotherTeacher</code>均为函数表达式，但是可以发现，<code>otherTeacher</code>变量赋予了一个匿名函数，<code>anotherTeacher</code>后跟了一个命名函数，我们称<code>anotherTeacher</code>为命名的函数表达式。</p>
<h3 id="naming-function-expressions">Naming Function Expressions</h3>
<p>一般我们使用函数表达式都是把匿名函数赋值给变量，但是把命名函数赋值给变量有如下好处(上面代码中<code>otherTeacher</code>与<code>anotherTeacher</code>通过控制台输出也可发现)</p>
<ol>
<li>Reliable function self-reference (recursion, etc)(可靠的函数自引用(递归等))</li>
<li>More debuggable stack traces(调试时更多可堆栈跟踪)</li>
<li>More self-documenting code(更多的自我记录的代码)</li>
</ol>
<p>在函数自引用时，我们知道arguments.callee已经不推荐使用，那么我们如何在函数内部引用函数自身（递归等情况）？直接使用保存着函数指针的外部变量？还是使用只存在函数作用域内部且具有只读属性的函数名？显然后者可能是更好的选择。首先函数名不会想外部变量一样被重新赋值，所以一直指向函数本身，其次函数名只存在函数作用域内部，只要函数存在就可以调用。</p>
<p>其次在我们进行调试时，如果使用匿名函数，那么显然调用栈中是不容易看出到底执行的是哪个匿名函数。但是使用命名函数表达式，就可以在调用栈中显示出函数名称，方便调试。</p>
<p>第三，可以使得代码的可读性提高，我们可以根据函数的作用给函数命名，并且赋值给变量。</p>
<p>代码的作用是更清晰的展现编程者的意图。所以匿名函数除了减少键盘输入次数可能并没有其他好处，我们应该了解我们所写的每一个函数的功能，并且根据函数的功能给其命名，如果功能过于复杂导致名称过于抽象，那么应该把函数拆分，然后重新给每个函数命名。</p>
<h3 id="arrow-functions%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">Arrow Functions(箭头函数)</h3>
<p>下面还是看一段代码；</p>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> ids = people.map(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> person.id) <span class="hljs-comment">// 常见用法，但作者不建议</span>

<span class="hljs-keyword">var</span> ids = people.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getId</span>(<span class="hljs-params">person</span>) </span>{ <span class="hljs-comment">// 建议使用命名回调函数，可读性更强</span>
  <span class="hljs-keyword">return</span> person.id
})

<span class="hljs-comment">/****************************************************************************/</span>

getPerson()
  .then(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> getData(person.id)) <span class="hljs-comment">// 一般用法，作者不建议</span>
  .then(renderData)

getPerson()
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDataFrom</span>(<span class="hljs-params">person</span>)</span>{ <span class="hljs-comment">// 建议使用命名回调函数，可读性更强</span>
    <span class="hljs-keyword">return</span> getData(person.id)
  })
  .then(renderData)

<span class="hljs-comment">/****************************************************************************/</span>

<span class="hljs-keyword">var</span> getId = <span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> person.id
<span class="hljs-keyword">var</span> ids = people.map(getId)

<span class="hljs-keyword">var</span> getDataFrom = <span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> getData(person.id)
getPerson()
  .then(getDataFrom)
  .then(renderData)
</div></code></pre>
<h3 id="function-type-hierachy%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%B1%82%E6%AC%A1">Function Type Hierachy(函数类型层次)</h3>
<p>在这里作者认为</p>
<p>命名的函数声明 &gt; 命名函数表达式 &gt; 匿名函数表达式</p>
<blockquote>
<p>(Named) Function Declaration &gt; Named Function Expression &gt; Anonymous Function Expression</p>
</blockquote>
<h2 id="advanced-scope">Advanced Scope</h2>
<h3 id="lexical--dynamic-scope%E8%AF%8D%E6%B3%95%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F">Lexical &amp; Dynamic Scope(词法和动态作用域)</h3>
<p>词法作用域在编译时已经创建好，不受代码执行影响。动态作用域边执行边创建，代码会影响作用域。</p>
<h3 id="lexical-scope">Lexical Scope</h3>
<p>词法作用域的设计初衷就是在编译时创建好代码中已有的作用域，这样在解析代码时就不懂在创建一遍作用域，加快代码的解析速度。</p>
<h3 id="dynamic-scope%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F">Dynamic Scope(动态作用域)</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Kyle'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(teacher, question)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">otherClass</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Suzy'</span>
  ask(<span class="hljs-string">'why'</span>)
}

otherClass()
</div></code></pre>
<p>这里的代码中，控制台输出的是<code>Kyle why</code>，因为函数的作用域取决于定义是的作用域，也就是在编译时函数的作用域就已经决定。虽然<code>ask</code>在<code>otherClass</code>内调用，但就像之前所说，js是词法作用域，执行时不影响编译时创建好的作用域，所以输出的是<code>Kyle why</code>而不是<code>Suzy why</code>。</p>
<p>对应的，动态作用域语言输出<code>Suzy why</code>，因为其作用域取决于函数执行时的作用域。</p>
<p>动态作用域在运行时的条件确定作用域，词法作用域在编译时已确定，执行时不会更改已经确定的作用域。</p>
<h3 id="function-scoping">Function Scoping</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Kyle'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anotherTeacher</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Suzy'</span>
  <span class="hljs-built_in">console</span>.log(teacher) <span class="hljs-comment">// Suzy</span>
}

<span class="hljs-built_in">console</span>.log(teacher) <span class="hljs-comment">// Kyle</span>
</div></code></pre>
<p>可以看到，上述代码中，<code>teacher</code>分别被声明在两个作用域中，这就一定程度上解决了变量命名冲突问题。</p>
<p>在程序设计中，有一项原则，称为最小暴露原则或者最小特权原则：你应该保持一切都隐藏起来，只暴露必要的部分。这是一种防御姿态，保持我们程序的独立性。这事实上也解决了三个问题，首先减少了命名冲突，其次减少了意外使用或修改的风险（不暴露在外部，在外部无法访问修改私有属性方法），第三，可以帮助以后的重构（不依赖外部环境，可以放心修改）。</p>
<h3 id="iife-pattern%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F">IIFE Pattern(立即执行函数模式)</h3>
<p>立即执行函数来源于一个想法，既然我们可以把一段代码放在一个()内，使其成为一个代码段执行，那么为什么要把保存函数指针的变量后加()执行而不是函数本身放在()内，在后面加()调用呢？</p>
<p>这应该就是立即执行函数的来源。既把一个函数的声明放在一个()内，使其解析为一个代码段，并在后加()立即调用，这样就把定义函数和调用函数放在了一起。而不是在变量中保存函数指针然后使用变量调用函数。</p>
<p>在这里作者还是建议即使使用立即执行函数，也最好给函数命名。如果实在不知道叫啥，就叫IIFE。这样才方便在Chrome开发者工具中追踪调用栈目前执行的函数。</p>
<h3 id="block-scoping">Block Scoping</h3>
<p>块级作用域的原则与函数作用域一致：我们把数据和函数放在块级作用域内隐藏起来，减少命名冲突的可能性，保护私有变量及方法，方便未来进行重构。</p>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Kyle'</span>

{ <span class="hljs-comment">// 块级作用域开始</span>
  <span class="hljs-keyword">let</span> teacher = <span class="hljs-string">'Suzy'</span> <span class="hljs-comment">// 私有变量</span>
  <span class="hljs-built_in">console</span>.log(teacher) <span class="hljs-comment">// ‘Suzy’</span>
} <span class="hljs-comment">// 块级作用域结束</span>

<span class="hljs-built_in">console</span>.log(teacher)
</div></code></pre>
<p>注意，因为在es5中只有函数作用域，所以即使在{}内使用var来声明变量，变量属于其所在的函数或全局作用域内，所以在{}内不能使用var来定义私有变量。<strong>通过使用ES6的<code>let</code>及<code>const</code>定义变量，我们可以在一个{}定义私有变量及方法，既<code>let</code>和<code>const</code>会将所在的{}变成一个块级作用域，也就是说如果一个{}内没有<code>let</code>和<code>const</code>关键字，{}就不是一个块级作用域</strong>。</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diff</span>(<span class="hljs-params">x, y</span>)</span>{
  <span class="hljs-keyword">if</span>(x &gt; y) {
    <span class="hljs-keyword">var</span> tmp = x <span class="hljs-comment">// 这里使用var声明了一个if语句内的临时变量，不建议使用，因为var在整个函数的作用域中</span>
    <span class="hljs-keyword">let</span> tmp2 = x <span class="hljs-comment">// 这里使用了let关键字声明变量，是的if后的{}成为一个块级作用域，tmp2成为一个私有变量</span>
    x = y
    y = tmp
  }
  <span class="hljs-keyword">return</span> y - x
}
</div></code></pre>
<p>在这里作者还建议了谨慎使用<code>let</code>及<code>const</code>，因为这两个关键字会把当前{}变为新的作用域，但是使用<code>var</code>并不会导致作用域的增加，所以仍有使用<code>var</code>的原因。例如如下代码：</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeat</span>(<span class="hljs-params">fn, n</span>) </span>{
  <span class="hljs-keyword">var</span> result

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    result = fn( result, i )
  }

  <span class="hljs-keyword">return</span> result
}
</div></code></pre>
<h3 id="choosing-let-or-var">Choosing let or var</h3>
<p>作者认为上述代码使用es6的<code>let</code>关键字后可以修改如下</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeat</span>(<span class="hljs-params">fn, n</span>) </span>{
  <span class="hljs-keyword">var</span> result

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    result = fn( result, i )
  }

  <span class="hljs-keyword">return</span> result
}
</div></code></pre>
<p>注意在上述代码中，for循环内的关键字修改为<code>let</code>，但是函数体内第一行仍使用<code>var</code>。作者认为，只在一些需要私有变量的时候，例如for循环体内使用<code>let</code>，但是在定义一些作用域内均可使用的变量时，仍使用<code>var</code>关键字，这样可以使代码更加语义化，既使用<code>let</code>声明明确的私有变量，<code>var</code>声明作用域内的公共变量。</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookupRecord</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">var</span> id = getRecord( searchStr )
  }
  <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">var</span> id = <span class="hljs-number">-1</span>
  }
  <span class="hljs-keyword">return</span> id <span class="hljs-comment">// 如果把上面的try catch语句中的var替换为let，这里会报错，因为id在此作用域内未声明</span>
}
</div></code></pre>
<p>因为<code>var</code>关键字可以在同一作用域内多次声明同一变量，所以有时使用var重复声明变量可以使代码更加语义化，此时可以使用<code>var</code>关键字。</p>
<h3 id="explicit-let-block">Explicit let Block</h3>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatStr</span>(<span class="hljs-params">str</span>) </span>{
  { <span class="hljs-keyword">let</span> prefix, rest
      prefix = str.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
      rest = str.slice(<span class="hljs-number">3</span>)
      str = prefix.toUpperCase() + rest
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^FOO:/</span>.test(str)) {
    <span class="hljs-keyword">return</span> str
  }

  <span class="hljs-keyword">return</span> str.slice(<span class="hljs-number">4</span>)
}
</div></code></pre>
<p>在上述代码中，即使在函数作用域内，作者还是给临时变量添加了{}，使用了块级作用域来包裹声明的临时变量。这也是其他使用块级作用域语言的常用作法。</p>
<h3 id="const">Const</h3>
<p><code>const</code>不是意味着一个不变的变量，而是意味着无法重新分配的变量。在js中，基本类型传递的是基本类型的值，把基本类型值赋值给<code>const</code>定义的变量，那个就无法重新给此变量赋值。但是因为引用类型传递的是指针，所以即使改变了指针所指向的数据结构，但是只要指针本身不改变，就不会报错。所以使用<code>const</code>定义变量并把引用类型的指针赋值给变量时，仍可更改引用类型的值。</p>
<h3 id="hoisting%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">Hoisting(变量提升)</h3>
<p>js引擎其实并没有变量提升这个执行过程。变量提升是一种语言惯例，其实并不存在与js中。</p>
<pre><code class="language-js"><div>student <span class="hljs-comment">// undefined</span>
teacher <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">var</span> student = <span class="hljs-string">'you'</span>
<span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Kyle'</span>
</div></code></pre>
<p>在过去，我们把先使用变量后声明并赋值变量，但是并不报错并返回undefined的现象解释为变量提升。我们对变量提升的解释模型如下</p>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> student
<span class="hljs-keyword">var</span> teacher
student = <span class="hljs-string">'you'</span>
teacher = <span class="hljs-string">'Kyle'</span>
</div></code></pre>
<p>人们认为代码在执行时的结果如上，并将变量提升解释为js在执行时会将所有变量的声明提升到作用域顶端，但是还在代码的同样位置赋值。但事实上js的运行机制并不是这样。</p>
<p>就像我们之前所讲的一样，js在执行前的编译阶段就已经创建好了所有的作用域，并明确了作用域内声明的所有变量。所以js执行时的代码更类似如下这样：</p>
<pre><code class="language-js"><div>student
teacher
student = <span class="hljs-string">'you'</span>
teacher = <span class="hljs-string">'Kyle'</span>
</div></code></pre>
<p>js在解析编译阶段就已经将所有作用域及各个作用域的变量都创建好，只是在执行阶段进行赋值并操作修改。所以变量提升的说法并不严谨，这只是为了简化js的运行机制删除了一些细节的粗略模型。</p>
<pre><code class="language-js"><div>teacher() <span class="hljs-comment">// Kyle</span>
otherTeacher() <span class="hljs-comment">// TypeError: otherTeacher is not a function</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">teacher</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Kyle'</span>
}

<span class="hljs-keyword">var</span> otherTeacher = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Suzy'</span>
}
</div></code></pre>
<p>使用变量提升模型，我们将上述代码转换如下：</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">teacher</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Kyle'</span>
}
<span class="hljs-keyword">var</span> otherTeacher

teacher() <span class="hljs-comment">// Kyle</span>
otherTeacher() <span class="hljs-comment">// TypeError: otherTeacher is not a function</span>

otherTeacher = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Suzy'</span>
}
</div></code></pre>
<h3 id="let-dosent-hoist">let Dosen't Hoist</h3>
<p>使用let关键字不会导致变量提升？</p>
<p>我们来看一段代码</p>
<pre><code class="language-js"><div>{
  teacher = <span class="hljs-string">'Kyle'</span> <span class="hljs-comment">// TDZ error 暂时性死区(temporal dead zone)错误</span>
  <span class="hljs-keyword">let</span> teacher
}
</div></code></pre>
<p>这句话的出发点很好，但不准确。</p>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Kyle'</span>
{
  <span class="hljs-built_in">console</span>.log(teacher) <span class="hljs-comment">// TDZ error 暂时性死区(temporal dead zone)错误</span>
  <span class="hljs-keyword">let</span> teacher = <span class="hljs-string">'Suzy'</span>
}
</div></code></pre>
<p>在上述代码中，如果用let不会变量提升来解释，显然控制台应该打印”Kyle“。但是代码仍然报错暂时性死区错误。</p>
<p>这说明<code>let</code>也会有变量提升，但是提升的方式与<code>var</code>不同。首先<code>let</code>提升到块级作用域顶部，而<code>var</code>提升高函数作用域顶部。其次在使用<code>var</code>时，会将变量的值初始化为<code>undefined</code>，但是用<code>let</code>时，只会在块级作用域顶部声明变量，但是不会初始化变量，所以在初始化变量的值之前都无法使用变量，这就是暂时性死区。</p>
<p>作者在这里认为TDZ概念最早提出是基于<code>const</code>，因为<code>const</code>代表了一个不可以重新赋值的变量，如果我们把<code>const</code>定义的变量提升到作用域顶部并在赋值之前初始化为<code>undefined</code>，那么显然<code>const</code>就会在赋值时重新赋值，这显然违背了<code>const</code>设计的初衷。所以在使用<code>const</code>定义变量时，仍存在变量提升，但不会初始化，此时<code>const</code>所定义的变量也无法使用，这就是TDZ的由来。既然<code>const</code>如此，那么<code>let</code>为什么不也这样呢，所以es6中<code>let</code>和<code>const</code>都有TDZ。</p>
<p>在问答中，作者也提出了<strong>其实js在编译时也对函数进行了处理，创建了函数作用域并声明了作用域的变量，但是并没有对变量进行具体操作，这些操作都会在js执行阶段调用函数时执行</strong>。</p>
<h2 id="closure%E9%97%AD%E5%8C%85">Closure(闭包)</h2>
<h3 id="origin-of-closure%E9%97%AD%E5%8C%85%E7%9A%84%E8%B5%B7%E6%BA%90">Origin of Closure(闭包的起源)</h3>
<p>闭包的思想在计算机科学存在之前就已经存在，来源于Lambda演算。</p>
<h3 id="what-is-closure">What is Closure</h3>
<p>这里是作者认为最为准确的闭包的定义。</p>
<p><strong>闭包是即使函数是在词法作用域之外执行，函数仍然可以“记住”它的词法作用域</strong>。</p>
<blockquote>
<p>Closure is when a function “remembers” its lexical scope even when the function is executed outside that lexical scope.</p>
</blockquote>
<p>当把一个函数作为回调函数传给另一个函数作为参数时，或者把一个函数从另一个函数内部返回时，很明显函数定义时所在的作用域与执行时并不一致，此时函数的作用域在概念上应该被垃圾回收掉了。但是我们发现此时仍可以通过函数访问已经’消失‘的变量，这并不是偶然的，这就是闭包的设计初衷。</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitASec</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(question)
  }, <span class="hljs-number">100</span>)
}
ask(<span class="hljs-string">'What is Closure'</span>)
<span class="hljs-comment">// What is Closure</span>
</div></code></pre>
<p>在上述代码中可以看到，<code>setTimeout</code>内的回调函数<code>waitASec</code>访问到了其外部<code>ask</code>的实参，理论上<code>ask</code>已在100毫秒前执行完毕，其执行上下文被推出调用栈，并被垃圾回收机制回收。但是因为<code>setTimeout</code>内的回调函数<code>waitASec</code>对其实参进行了引用，所以在内存中的数据并没有消失，而是保留了下来，以供<code>waitASec</code>进行调用，这就是闭包。</p>
<p>在这里作者提出据她了解，js引擎会将作用域的全部执行上下文保留，而不仅仅是被引用的变量，这在作用域内数据量特别大的时候会有性能上的风险。</p>
<h3 id="closing-over-variables">Closing Over Variables</h3>
<p>闭包并不是把变量保存下来，而是与变量建立连接。所以如果内部函数引用了外部变量，外部变量改变，内部函数引用的外部变量也会改变。</p>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Kyle'</span>

<span class="hljs-keyword">var</span> myTeacher = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTeacherIs</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(teacher)
}

teacher = <span class="hljs-string">'Suzy'</span>

myTeacher() <span class="hljs-comment">// Suzy</span>
</div></code></pre>
<p>可以看到上述代码输出了Suzy，证明了外部变量改变后，函数内部引用的teacher的值也进行了改变。</p>
<pre><code class="language-js"><div><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++){
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberIs</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`i: <span class="hljs-subst">${i}</span>`</span>)
  }, i * <span class="hljs-number">1000</span>)
} <span class="hljs-comment">// 每隔1s输出4，共三次</span>
</div></code></pre>
<p>如果使用es6语法，将上述代码的输出结果为1，2，3。代码如下</p>
<pre><code class="language-js"><div><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++){
  <span class="hljs-keyword">let</span> j = i
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberIs</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`j: <span class="hljs-subst">${j}</span>`</span>)
  }, j * <span class="hljs-number">1000</span>)
}
</div></code></pre>
<p>上述代码中，我们在for循环内使用了<code>let</code>关键字，使得for循环的{}成为了一个块级作用域。<code>setTimeout</code>的回调函数引用的时在作用域内新建的变量，每次执行for循环，就新建一个<code>j</code>，所以可以输出1，2，3。</p>
<pre><code class="language-js"><div><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++){
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberIs</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`i: <span class="hljs-subst">${i}</span>`</span>)
  }, i * <span class="hljs-number">1000</span>)
}
</div></code></pre>
<p>或者我们可以更加简化一下，直接在for循环的()内使用<code>let</code>关键字，使for循环的{}成为一个块级作用域。</p>
<h3 id="module-pattern">Module Pattern</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> workshop = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Kyle'</span>,
  ask(question) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

workshop.ask(<span class="hljs-string">'Is this a module?'</span>) <span class="hljs-comment">// Kyle Is this a module?</span>
</div></code></pre>
<p>上述代码把方法和方法需要的数据都添加到了一个对象中，是<strong>命名空间模式</strong>。这是一种组织方法与数据的模式，但这并不是模块。命名空间模式并不是模块的原因是模块模式需要封装的概念，封装意味着要隐藏数据与行为。</p>
<p><strong>模块将数据和行为(方法)封装在一起。模块的状态(数据)由它的方法通过闭包保存</strong>。</p>
<blockquote>
<p>Modules encapsulate data and behavior(methods) together. The state (data) of a module is held by its methods via closure.</p>
</blockquote>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> workshop = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Module</span>(<span class="hljs-params">teacher</span>)</span>{
  <span class="hljs-keyword">var</span> publicAPI = { ask, }
  <span class="hljs-keyword">return</span> publicAPI

  <span class="hljs-comment">//*******************</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
    <span class="hljs-built_in">console</span>.log(teacher, question)
  }
})(<span class="hljs-string">'Kyle'</span>)

workshop.ask(<span class="hljs-string">"It's a Module, right?"</span>) <span class="hljs-comment">// Kyle It's a Module, right?</span>
</div></code></pre>
<p>可以看到，在上述代码中，我们把需要的变量变为了函数的参数传入，并且返回了引用了参数的方法，在外部是无法访问方法所引用的数据的。通过闭包，我们可以保存私有变量及方法，所以没有闭包就没有模块。</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WorkshopModule</span>(<span class="hljs-params">teacher</span>) </span>{
  <span class="hljs-keyword">var</span> publicAPI = { ask, }
  <span class="hljs-keyword">return</span> publicAPI

  <span class="hljs-comment">//***************</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
    <span class="hljs-built_in">console</span>.log(teacher,question)
  }
}

<span class="hljs-keyword">var</span> workshop = WorkshopModule(<span class="hljs-string">'Kyle'</span>)

workshop.ask(<span class="hljs-string">"It's a Module, right?"</span>) <span class="hljs-comment">// Kyle It's a Module, right?</span>
</div></code></pre>
<p>在上面的代码中，我们没有使用IIFE(立即执行函数)，而是定义了一个普通函数作为模块，在需要时创建一个实例，通过实例的方法可以访问实例的私有属性。这样只用定义一次，每创建一个实例就有了一个新的模块。我们把<code>WorkshopModule</code>称为工厂函数。</p>
<h3 id="es6-modules--nodejs">ES6 Modules &amp; Node.js</h3>
<p>ES6的模块基于文件，所以一个文件只能有一个模块。</p>
<h3 id="es6-module-syntax">ES6 Module Syntax</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Kyle'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(teacher, question)
}
</div></code></pre>
<pre><code class="language-js"><div><span class="hljs-keyword">import</span> ask <span class="hljs-keyword">from</span> <span class="hljs-string">'workshop.mjs'</span>

ask(<span class="hljs-string">"It's a default import, right?"</span>)
<span class="hljs-comment">// Kyle It's a default import, right?</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> workshop <span class="hljs-keyword">from</span> <span class="hljs-string">'workshop.mjs'</span>

workshop.ask(<span class="hljs-string">"It's a namespace import, right?"</span>)
<span class="hljs-comment">// Kyle It's a namespace import, right?</span>
</div></code></pre>
<h2 id="objects">Objects</h2>
<h3 id="objects-overview">Objects Overview</h3>
<p>Objects (Oriented)</p>
<ul>
<li>this</li>
<li>class { }</li>
<li>Prototypes</li>
<li>“Inheritance” vs. “Behavior Delegation” (OO vs. OLOO)</li>
</ul>
<h3 id="the-this-keyword">The this Keyword</h3>
<p>函数的<code>this</code>引用调用该函数的执行上下文，完全由函数的调用方式决定（函数定义时的执行上下文与<code>this</code>无关）。</p>
<blockquote>
<p>A function's this references the execution context for that call, determined entirely by how the function was called.</p>
</blockquote>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">otherClass</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> myContext = {
    <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Suzy'</span>
  }
  ask.call(myContext, <span class="hljs-string">'Why?'</span>) <span class="hljs-comment">// Suzy Why?</span>
}

otherClass()
</div></code></pre>
<p>因此，每次调用此感知函数时，它可以具有不同的上下文，这使得它更加灵活和可重用。</p>
<blockquote>
<p>A this-aware function can thus have a different context each time it's called, which makes it more flexible &amp; reusable.</p>
</blockquote>
<p>在之前我们了解到，js使用词法作用域，也就是函数的作用域完全取决于函数定义时的作用域，但是如果我们想要获得一些动态作用域的特性呢？既当前作用域不取决于定义时的作用域，而是函数调用时的作用域，所以设计出了this关键字。</p>
<p>为了区分使用时<code>this</code>的指向，js设计出了四种调用函数的方式：</p>
<ol>
<li>this: implicit binding(隐式绑定)</li>
<li>this: explicit binding(显示绑定)</li>
<li>this: hard binding(硬绑定，创建了一个新的函数，并不算函数调用)</li>
<li>this: new binding(new关键字绑定)</li>
<li>default binding</li>
</ol>
<h3 id="implicit--explicit-binding">Implicit &amp; Explicit Binding</h3>
<h4 id="implicit-binding%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A">implicit binding(隐式绑定)</h4>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> workshop = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Kyle'</span>,
  ask(question) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

workshop.ask(<span class="hljs-string">'What is implicit binding?'</span>) <span class="hljs-comment">// Kyle What is implicit binding?</span>
</div></code></pre>
<p>隐式绑定时this指向调用函数的对象的执行上下文(如果直接调用函数，指向widows对象的执行上下文，既全局作用域)。</p>
<p>通过隐式绑定，我们可以模拟出动态作用域的效果:</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

<span class="hljs-keyword">var</span> workshop1 = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Kyle'</span>,
  <span class="hljs-attr">ask</span>: ask
}

<span class="hljs-keyword">var</span> workshop2 = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Suzy'</span>,
  <span class="hljs-attr">ask</span>: ask
}

workshop1.ask(<span class="hljs-string">'How do I share a method?'</span>) <span class="hljs-comment">// Kyle How do I share a method?</span>
workshop2.ask(<span class="hljs-string">'How do I share a method?'</span>) <span class="hljs-comment">// Suzy How do I share a method?</span>
</div></code></pre>
<h4 id="explicit-binding%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A%E4%BD%BF%E7%94%A8call%E6%88%96apply%E6%96%B9%E6%B3%95">explicit binding(显示绑定，使用call或apply方法)</h4>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

<span class="hljs-keyword">var</span> workshop1 = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Kyle'</span>
}

<span class="hljs-keyword">var</span> workshop2 = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Suzy'</span>
}

ask.call(workshop1, <span class="hljs-string">'Can I explicitly set context?'</span>) <span class="hljs-comment">// Kyle Can I explicitly set context?</span>
ask.call(workshop2, <span class="hljs-string">'Can I explicitly set context?'</span>) <span class="hljs-comment">// Suzy Can I explicitly set context?</span>
</div></code></pre>
<p>上述代码可以看到，我们直接调用了函数，但是使用了<code>Function.prototype.call()</code>方法调用，手动的将<code>ask</code>内的<code>this</code>指向了<code>workshop1</code>和<code>workshop2</code>，而不是<code>windows</code>对象，输出了预期的结果</p>
<h4 id="hard-binding">hard binding</h4>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Suzy'</span>
<span class="hljs-keyword">var</span> workshop = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Kyle'</span>,
  ask(question) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

setTimeout(workshop.ask, <span class="hljs-number">1000</span>, <span class="hljs-string">'Lost this?'</span>) <span class="hljs-comment">// Suzy Lost this?</span>

setTimeout(workshop.ask.bind(workshop), <span class="hljs-number">1000</span>, <span class="hljs-string">'Hard bound this?'</span>) <span class="hljs-comment">// Kyle Hard bound this?</span>
</div></code></pre>
<p>可以看到，在上述代码中将<code>work.ask</code>作为回调函数传入其他函数作为参数时，<code>this</code>的指向进行了改变，指向了<code>windows</code>对象的执行上下文，这是因为传递的只是函数的指针，在调用时函数指向了windows。此时我们要使用<code>bind</code>方法将<code>workshop</code>的执行上下文绑定在方法内的<code>this</code>上，这样只要调用，<code>this</code>就指向了<code>workshop</code>的执行上下文，而不是当前调用的作用域。所以<code>bind()</code>方法不是调用函数，而是创建一个新的函数，在调用时设置this关键字为提供的值。</p>
<h3 id="the-new-keyword">The new Keyword</h3>
<p>使用<code>new</code>关键字，是我们第三种可以调用函数的方式（<code>bind</code>是创建了新函数，并不算调用函数）。</p>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

<span class="hljs-keyword">var</span> newEmptyObject = <span class="hljs-keyword">new</span> ask(<span class="hljs-string">"What is 'new' doing here?"</span>)
<span class="hljs-comment">// undefined "What is 'new' doing here?"</span>
</div></code></pre>
<p>当我们使用new关键字调用函数时，会有如下的过程</p>
<blockquote>
<p>js高级程序设计</p>
</blockquote>
<ol>
<li>创建一个新对象，</li>
<li>将构造函数的作用域赋给新对象（此时构造函数的this指向了新对象，新对象的原型也指向了构造函数的原型对象）</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<blockquote>
<p>此教程</p>
</blockquote>
<ol>
<li>Create a brand new empty object</li>
<li>Link that object to another object</li>
<li>Call function with this set to the new object</li>
<li>If function does not return an object, assume return of this</li>
</ol>
<p>在JavaScript: The Hard Part中，我们是通过以下代码实现<code>new</code>关键字的</p>
<pre><code class="language-js"><div><span class="hljs-comment">// 构造器</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userCreator</span>(<span class="hljs-params">name, score</span>) </span>{
  <span class="hljs-keyword">const</span> newUser = <span class="hljs-built_in">Object</span>.create(userFunctionStore)
  newUser.name = name
  newUser.score = score
  <span class="hljs-keyword">return</span> newUser
}
<span class="hljs-comment">// 原型对象</span>
<span class="hljs-keyword">let</span> userFunctionStore = {
  increment() { <span class="hljs-keyword">this</span>.score++ },
  login() { <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"you are loggedin"</span>) }
}
<span class="hljs-comment">// 实例化构造器</span>
<span class="hljs-keyword">let</span> user1 = userCreator(<span class="hljs-string">"Will"</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> user2 = userCreator(<span class="hljs-string">"Tim"</span>, <span class="hljs-number">5</span>)
user1.increment()
</div></code></pre>
<h3 id="default-binding">default binding</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> teacher = <span class="hljs-string">'Kyle'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">askAgain</span>(<span class="hljs-params">question</span>) </span>{
<span class="hljs-meta">  "use strict"</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

ask(<span class="hljs-string">"What's the none-strict-mode default?"</span>) <span class="hljs-comment">// Kyle What's the none-strict-mode default?</span>
askAgain(<span class="hljs-string">"What's the strict-mode default"</span>) <span class="hljs-comment">//  TypeError</span>
</div></code></pre>
<h3 id="binding-precedence">Binding Precedence</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> workshop = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Kyle'</span>,
  <span class="hljs-attr">ask</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

<span class="hljs-keyword">new</span> (workshop.ask.bind(workshop))(<span class="hljs-string">'What does this do'</span>) <span class="hljs-comment">// undefined "What does this do"</span>
</div></code></pre>
<p>在上面的代码中，我们首先为在<code>workshop</code>对象中调用<code>ask</code>，同时也将<code>ask</code>中的<code>this</code>手动绑定到了<code>workshop</code>上，最后使用<code>new</code>调用函数并传入参数，最后<code>this.teacher</code>输出为<code>undefined</code>。</p>
<p>以下是判断this指向的顺序：</p>
<ol>
<li>Is the function called by new?</li>
<li>Is the function called by call() or apply()? Note: bind() effectively uses apply()</li>
<li>Is the function called on a context object?</li>
<li>DEFAULT: global object (except strict mode)</li>
</ol>
<h3 id="arrow-functions--lexical-this">Arrow Functions &amp; Lexical this</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> workshop = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Kyle'</span>,
  ask(question) {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
    }, <span class="hljs-number">100</span>)
  }
}

workshop.ask(<span class="hljs-string">"Is this lexical 'this'?"</span>) <span class="hljs-comment">// Kyle Is this lexical 'this'?</span>
</div></code></pre>
<p>可以看到，在上述代码中回调函数使用了箭头函数，此时没有手动绑定<code>this</code>，但是仍输出了<code>workshop</code>的执行上下文内的变量。在这里我们把箭头函数中的<code>this</code>称为<code>lexical this</code>。在箭头函数中，并不存在<code>this</code>，在箭头函数中使用<code>this</code>就跟其他变量一样在定义时已经确定作用域，而不是执行时，并且绑定的是箭头函数的上一级作用域。</p>
<p>箭头函数是<code>this</code>-绑定(即<code>.bind()</code>)到它的父级函数。</p>
<blockquote>
<p>An arrow function is this-bound (aka .bind()) to its parent function.</p>
</blockquote>
<p>上述是绝大部分人对于箭头函数中<code>this</code>的认知，实际上，根据规范，箭头函数中并不存在<code>this</code>关键字。所以在箭头函数中使用<code>this</code>，就会像使用其他变量一样，根据作用域链指向其父级作用域的<code>this</code>。</p>
<blockquote>
<p>箭头函数并没有定义this，所以箭头函数中的this像其他普通变量一样，是按词法解析的(也就是“词法this”)。
An arrow function doesn't define a this, so it's like any normal variable, and resolves lexically (aka &quot;lexical this&quot;).</p>
</blockquote>
<p>以下是规范中关于箭头函数中this的说明：</p>
<blockquote>
<p>ArrowFunction不为arguments、super、this或new.target定义本地绑定。ArrowFunction中任何对arguments、super、this或new.target的引用必须解析为词法封闭环境中的绑定。通常，这将是立即封闭函数的函数环境。尽管ArrowFunction可能包含对super的引用，但是在步骤4中创建的函数对象并不是通过执行MakeMethod而变成方法的。引用super的ArrowFunction总是包含在非ArrowFunction中，并且可以通过ArrowFunction的函数对象捕获的范围访问实现super所需的状态。
An ArrowFunction does not define local bindings for arguments, super, this, or  new.target. Any reference to arguments, super, this, or new.target within an ArrowFunction must resolve to a binding in a lexically enclosing environment. Typically this will be the Function Environment of an immediately enclosing function. Even though an ArrowFunction may contain references to super, the function object created in step 4 is not made into a method by performing MakeMethod. An ArrowFunction that references super is always contained within a non-ArrowFunction and the necessary state to implement super is accessible via the scope that is captured by the function object of the ArrowFunction.</p>
</blockquote>
<h3 id="resolving-this-in-arrow-functions">Resolving this in Arrow Functions</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> workshop = {
  <span class="hljs-attr">teacher</span>: <span class="hljs-string">'Kyle'</span>,
  <span class="hljs-attr">ask</span>: <span class="hljs-function">(<span class="hljs-params">question</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

workshop.ask(<span class="hljs-string">"What happend to 'this'?"</span>) <span class="hljs-comment">// undefined "What happend to 'this'?"</span>
workshop.ask.call(workshop,<span class="hljs-string">"Still no 'this'?"</span>) <span class="hljs-comment">// undefined "Still no 'this'?"</span>
</div></code></pre>
<p>在上述代码中可以看到，即使显示的调用<code>call()</code>方法将箭头函数的<code>this</code>绑定在<code>workshop</code>上，仍然输出<code>undefined</code>，因为箭头函数中并没有定义<code>this</code>。</p>
<h3 id="es6-class-keyword">ES6 class Keyword</h3>
<p><code>class</code>关键字是一个基于js原型系统的语法糖。</p>
<pre><code class="language-js"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Workshop</span> </span>{
  <span class="hljs-keyword">constructor</span>(teacher) {
    <span class="hljs-keyword">this</span>.teacher = teacher
  }
  ask(question) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

<span class="hljs-keyword">var</span> deepJS = <span class="hljs-keyword">new</span> Workshop(<span class="hljs-string">'Kyle'</span>)
<span class="hljs-keyword">var</span> reactJS = <span class="hljs-keyword">new</span> Workshop(<span class="hljs-string">'Suzy'</span>)

deepJS.ask(<span class="hljs-string">"Is 'class' a class?"</span>) <span class="hljs-comment">// Kyle Is 'class' a class?</span>
reactJS.ask(<span class="hljs-string">"Is this class ok?"</span>)  <span class="hljs-comment">// Suzy Is this class ok?</span>
</div></code></pre>
<p>以上是<code>class</code>的基本用法，如果想继承一个已经定义好的类，可以像如下代码</p>
<pre><code class="language-js"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Workshop</span> </span>{ <span class="hljs-comment">// 定义一个基类</span>
  <span class="hljs-keyword">constructor</span>(teacher) {
    <span class="hljs-keyword">this</span>.teacher = teacher
  }
  ask(question) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherWorkshop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Workshop</span> </span>{ <span class="hljs-comment">// 继承基类</span>
  speakUp(msg) {
    <span class="hljs-keyword">this</span>.ask(msg)
  }
}

<span class="hljs-keyword">var</span> JSRecentParts = <span class="hljs-keyword">new</span> AnotherWorkshop(<span class="hljs-string">'Kyle'</span>)

JSRecentParts.speakUp(<span class="hljs-string">'Are classes getting better?'</span>) <span class="hljs-comment">// Kyle Are classes getting better?</span>
</div></code></pre>
<p>在上述代码中，我们使用<code>extends</code>关键字使<code>AnotherWorkshop</code>继承了<code>Workshop</code>的属性和方法。</p>
<pre><code class="language-js"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Workshop</span> </span>{
  <span class="hljs-keyword">constructor</span>(teacher) {
    <span class="hljs-keyword">this</span>.teacher = teacher
  }
  ask(question) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherWorkshop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Workshop</span> </span>{
  ask(msg) {
    <span class="hljs-keyword">super</span>.ask(msg.toUpperCase())
  }
}

<span class="hljs-keyword">var</span> JSRecentParts = <span class="hljs-keyword">new</span> AnotherWorkshop(<span class="hljs-string">'Kyle'</span>)
JSRecentParts.ask(<span class="hljs-string">'Are classes super?'</span>) <span class="hljs-comment">// Kyle ARE CLASSES SUPER?</span>
</div></code></pre>
<p>在ES6中，我们使用了<code>class</code>解决面相对象中的封装问题，使用<code>extends</code>解决继承问题，那么如何解决多态问题呢？</p>
<p>所以设计出了<code>super</code>关键字，在上述代码中，我们在<code>AnotherWorkshop</code>中使用了<code>super</code>重新定义了继承与<code>Workshop</code>的<code>ask</code>方法。</p>
<pre><code class="language-js"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Workshop</span> </span>{
  <span class="hljs-keyword">constructor</span>(teacher) {
    <span class="hljs-keyword">this</span>.teacher = teacher
  }
  ask(question) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

<span class="hljs-keyword">var</span> deepJS = <span class="hljs-keyword">new</span> Workshop(<span class="hljs-string">'Kyle'</span>)
setTimeout(deepJS.ask, <span class="hljs-number">100</span>, <span class="hljs-string">"Still losing 'this'?"</span>) <span class="hljs-comment">// undefined "Still losing 'this'?"</span>
</div></code></pre>
<p>可以看到，使用<code>class</code>定义的方法与普通函数一样，并不会绑定<code>this</code>。</p>
<h3 id="fixing-this-in-classes">Fixing this in Classes</h3>
<p><a href="https://gist.github.com/getify/86bed0bb78ccb517c84a6e61ec16adca" target="_blank" rel="noopener">作者的解决方案</a></p>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> method = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineMethod</span>(<span class="hljs-params"></span>)</span>{
   <span class="hljs-keyword">var</span> instances = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();

   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params">obj,methodName,fn</span>) </span>{
      <span class="hljs-built_in">Object</span>.defineProperty(obj,methodName,{
         <span class="hljs-keyword">get</span>() {
            <span class="hljs-keyword">if</span> (!instances.has(<span class="hljs-keyword">this</span>)) {
               instances.set(<span class="hljs-keyword">this</span>,{});
            }
            <span class="hljs-keyword">var</span> methods = instances.get(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">if</span> (!(methodName <span class="hljs-keyword">in</span> methods)) {
               methods[methodName] = fn.bind(<span class="hljs-keyword">this</span>);
            }
            <span class="hljs-keyword">return</span> methods[methodName];
         }
      });
   }
})();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindMethods</span>(<span class="hljs-params">obj</span>) </span>{
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ownProp <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj)) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[ownProp] == <span class="hljs-string">"function"</span>) {
         method(obj,ownProp,obj[ownProp]);
      }
   }
}
</div></code></pre>
<h2 id="prototypes">Prototypes</h2>
<h3 id="prototypes%E5%8E%9F%E5%9E%8B">Prototypes(原型)</h3>
<p>对象是通过“调用构造函数”创建的（使用new关键字）。</p>
<blockquote>
<p>Objects are built by &quot;constructor calls&quot; (via new)</p>
</blockquote>
<p>“调用构造函数”会创建一个“<strong>链接上</strong>”构造函数<strong>原型</strong>的对象。</p>
<blockquote>
<p>A &quot;constructor call&quot; makes an object “<strong>linked to</strong>” its own <strong>prototype</strong></p>
</blockquote>
<p>我们都知道js是一门基于对象的语言。在一些面相对象的语言中，我们会创建一个类，在使用时创造一个类的实例来进行使用。类就类似图纸，实例就类似根据图纸造出来的建筑。我们没法直接使用图纸，但是可以使用建筑，同时，我们的建筑时根据图纸制造的，可以造的不同，但是一些图纸上的特性，建筑上也存在。</p>
<p>js原型系统的关键在于<strong>实例并没有复制构造函数的原型对象，而是将实例的原型与构造函数的原型对象链接到了一起</strong>。</p>
<h3 id="prototypal-class">Prototypal Class</h3>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Workshop</span>(<span class="hljs-params">teacher</span>) </span>{
  <span class="hljs-keyword">this</span>.teacher = teacher
}
Workshop.prototype.ask = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

<span class="hljs-keyword">var</span> deepJS = <span class="hljs-keyword">new</span> Workshop(<span class="hljs-string">'Kyle'</span>)
<span class="hljs-keyword">var</span> reactJS = <span class="hljs-keyword">new</span> Workshop(<span class="hljs-string">'Suzy'</span>)

deepJS.ask(<span class="hljs-string">"Is 'prototype' a class?"</span>) <span class="hljs-comment">// Kyle Is 'prototype' a class?</span>
reactJS.ask(<span class="hljs-string">"Isn't 'prototype' ugly?"</span>) <span class="hljs-comment">// Suzy Isn't 'prototype' ugly?</span>
</div></code></pre>
<h3 id="the-prototype-chain">The Prototype Chain</h3>
<blockquote>
<p>几乎所有的 JavaScript 对象都是 Object 的实例；一个典型的对象继承了Object.prototype的属性（包括方法），尽管这些属性可能被遮蔽（亦称为覆盖）。但是有时候可能故意创建不具有典型原型链继承的对象，比如通过Object.create(null)创建的对象，或者通过Object.setPrototypeOf方法改变原型链。
改变Object原型，会通过原型链改变所有对象；除非在原型链中进一步覆盖受这些变化影响的属性和方法。这提供了一个非常强大的、但有潜在危险的机制来覆盖或扩展对象行为。</p>
</blockquote>
<h3 id="dunder-prototypesproto">Dunder Prototypes(<strong>proto</strong>)</h3>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Workshop</span>(<span class="hljs-params">teacher</span>) </span>{
  <span class="hljs-keyword">this</span>.teacher = teacher
}
Workshop.prototype.ask = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

<span class="hljs-keyword">var</span> deepJS = <span class="hljs-keyword">new</span> Workshop(<span class="hljs-string">'Kyle'</span>)

deepJS.constructor === Workshop <span class="hljs-comment">// true</span>

deepJS.__proto__ === Workshop.prototype <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Object</span>.getPrototypeOf(deepJS) === Workshop.prototype <span class="hljs-comment">// true</span>
</div></code></pre>
<blockquote>
<p>Object.prototype 的 <code>__proto__</code>  属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部[[Prototype]] (一个对象或 <code>null</code>)。
使用__proto__是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 现在更推荐使用<code>Object.getPrototypeOf</code>/<code>Reflect.getPrototypeOf</code> 和<code>Object.setPrototypeOf</code>/<code>Reflect.setPrototypeOf</code>（尽管如此，设置对象的<code>[[Prototype]]</code>是一个缓慢的操作，如果性能是一个问题，应该避免）。
<code>__proto__</code>属性也可以在对象文字定义中使用对象<code>[[Prototype]]</code>来创建，作为<code>Object.create()</code>的一个替代。 请参阅： object initializer / literal syntax.</p>
</blockquote>
<p>通过上述mdn对于<code>__proto__</code>的说明，其实所有对象的<code>__proto__</code>指向了<code>Object.prototype.__proto__</code>，这是一个访问器属性（函数），函数通过实例对象调用，就指向了实例对象的执行上下文，也就是操作了实例对象的prototype属性。</p>
<p>注意，箭头函数没有prototype属性。</p>
<h3 id="shadowing-prototype">Shadowing Prototype</h3>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Workshop</span>(<span class="hljs-params">teacher</span>) </span>{
  <span class="hljs-keyword">this</span>.teacher = teacher
}
Workshop.prototype.ask = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

<span class="hljs-keyword">var</span> deepJS = <span class="hljs-keyword">new</span> Workshop(<span class="hljs-string">'Kyle'</span>)
deepJS.ask = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-keyword">this</span>.ask(question.toUpperCase())
}

deepJS.ask(<span class="hljs-string">'Oops,is this infinite recursion?'</span>) <span class="hljs-comment">// Maximum call stack size exceeded</span>
</div></code></pre>
<h3 id="prototypal-inheritance">Prototypal Inheritance</h3>
<pre><code class="language-js"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Workshop</span>(<span class="hljs-params">teacher</span>) </span>{
  <span class="hljs-keyword">this</span>.teacher = teacher
}
Workshop.prototype.ask = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">question</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AnotherWorkshop</span>(<span class="hljs-params">teacher</span>) </span>{
  Workshop.call(<span class="hljs-keyword">this</span>, teacher) <span class="hljs-comment">// 使用call绑定this指向AnotherWorkshop</span>
}

AnotherWorkshop.prototype = <span class="hljs-built_in">Object</span>.create(Workshop.prototype) <span class="hljs-comment">// 使用Object.create继承Workshop.prototype</span>
AnotherWorkshop.prototype.speakUp = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span>{
  <span class="hljs-keyword">this</span>.ask(msg.toUpperCase())
}

<span class="hljs-keyword">var</span> JSRecentParts = <span class="hljs-keyword">new</span> AnotherWorkshop(<span class="hljs-string">'Kyle'</span>)

JSRecentParts.speakUp(<span class="hljs-string">'Is this actually inheritance?'</span>) <span class="hljs-comment">// Kyle IS THIS ACTUALLY INHERITANCE?</span>
</div></code></pre>
<h3 id="classical-vs-prototypal-inheritance">Classical vs Prototypal Inheritance</h3>
<p>在传统的面向对象语言中，实例复制了公共的属性方法。在js中，实例连接到了存储着公共属性及方法的对象。所以js的设计模式与传统的面相对象语言的设计模式并不相同。</p>
<h3 id="inheritance-is-delegation">Inheritance is Delegation</h3>
<p>在js的设计模式并不是“继承”，更像是“委托”。js使用原型系统或者说委托系统，而不是类系统或者说继承系统。</p>
<h3 id="olooobjects-linked-to-other-objects-pattern">OLOO(Objects Linked to Other Objects) Pattern</h3>
<pre><code class="language-js"><div><span class="hljs-keyword">var</span> Workshop = {
  setTeacher(teacher) {
    <span class="hljs-keyword">this</span>.teacher = teacher
  },
  ask(question) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.teacher, question)
  }
}

<span class="hljs-keyword">var</span> AnotherWorkshop = <span class="hljs-built_in">Object</span>.assign(
  <span class="hljs-built_in">Object</span>.create(Workshop),
  {
    speakUp(msg) {
      <span class="hljs-keyword">this</span>.ask(msg.toUpperCase())
    }
  }
)

<span class="hljs-keyword">var</span> deepJS = <span class="hljs-built_in">Object</span>.create(AnotherWorkshop)
deepJS.setTeacher(<span class="hljs-string">'Kyle'</span>)
deepJS.speakUp(<span class="hljs-string">'But is not this cleaner'</span>) <span class="hljs-comment">// Kyle BUT IS NOT THIS CLEANER</span>
</div></code></pre>
<p><code>Object.create()</code>的polyfill:</p>
<pre><code class="language-js"><div><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Object</span>.create) {
  <span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}
    F.prototype = object
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()
  }
}
</div></code></pre>
<h3 id="delegation-orienten-design">Delegation-Orienten Design</h3>
<p>设计模式并不仅仅影响我们组织代码的方式，也指导着我们编写代码的思维模式。</p>

    </body>
    </html>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/JavaScript-the-Hard-Part学习笔记/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/JavaScript-the-Hard-Part学习笔记/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 11:43:36" itemprop="dateCreated datePublished" datetime="2019-04-29T11:43:36+08:00">2019-04-29</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!DOCTYPE html>
    <html>
    <head><meta name="generator" content="Hexo 3.8.0">
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>成为世界级工程师的五个原则</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <hr>
<h2 id="title-javascript-the-hard-partdate-2019-04-22-232013categories-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0tags-frontendmasters-javascript-%E9%97%AD%E5%8C%85-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B%E6%9C%BA%E5%88%B6">title: JavaScript The Hard Part
date: 2019-04-22 23:20:13
categories: 学习笔记
tags: [FrontEndMasters, JavaScript, 闭包, 高阶函数, 面相对象, 原型机制]</h2>
<p>此文为学习笔记，来源FrontEndMasters的同名课程，中间加入了个人理解，以备将来复习。</p>
<h2 id="%E6%88%90%E4%B8%BA%E4%B8%96%E7%95%8C%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E4%BA%94%E4%B8%AA%E5%8E%9F%E5%88%99">成为世界级工程师的五个原则</h2>
<ol>
<li>Analytical problem solving with code
<blockquote>
<p>分析问题并用代码解决的能力</p>
</blockquote>
</li>
<li>Technical communication （can I implement your approach just from your explanation）
<blockquote>
<p>技术表达交流的能力（我能只通过看你的文档就能实现相应的功能吗）</p>
</blockquote>
</li>
<li>Engineering best practices and approach （Debugging，code structure,patience and reference to documentation)
<blockquote>
<p>工程最佳实践和方法(调试、代码结构、耐心和参考文档)</p>
</blockquote>
</li>
<li>Non-technical communication(empathetic and thoughtful communication)
<blockquote>
<p>非技术交流(有同理心、有思想的交流)</p>
</blockquote>
</li>
<li>Language and computer science experience
<blockquote>
<p>语言和计算机科学经验
其重要性依次排列</p>
</blockquote>
</li>
</ol>
<h2 id="javascript%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99principles-of-javascript">JavaScript的基本原则(Principles of JavaScript)</h2>
<p>传统的编译型语言逐行执行代码，现在js使用所谓的<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">及时汇编(Just In Time Compilation)</a>，至少是在Chrome编译执行时是这样（v8引擎的特性），但基本上也是逐行解析的。</p>
<p>如果我们自己解析存储数据，转换数据，并且逐行运行代码，那么就可以理解所有的js代码。</p>
<p>js不会初始化函数体内的代码，直到函数被调用。直到函数被调用之前，函数体内的代码没有意义。所以在函数执行前不要进入函数体，永远！线程或进程永远不会再函数调用之前执行函数体内的代码。只有在函数被调用时，线程或进程才会进入函数体内执行函数体内的代码。（所以其实函数是个锦囊？在满足条件前你也不知道锦囊里写了啥，因为锦囊有可能永远用不到，当满足条件，我们就打开锦囊，按照锦囊里的办法处理当前情况，所以是不是闭包也可以跟锦囊联系起来？我们打开一个锦囊，用完就扔了。但是如果锦囊里面有个锦囊，说我有可能用到（被外部引用），而且你得照着外面锦囊里说的啥啥啥来办，那么这两个锦囊都扔不了）。</p>
<h3 id="%E5%85%A8%E5%B1%80%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87global-execution-context">全局执行上下文(global execution context)</h3>
<p>我们开始运行代码时，开始创建全局执行上下文。执行上下文是一个比较唬人的名词，但是表示了两个简单的事。</p>
<ul>
<li>执行线程（一行行的转化并执行代码）</li>
<li>创建内存空间存储变量及数据</li>
</ul>
<p>这是全局执行上下文，在文件刚刚开始运行时创建，是一个全局环境。</p>
<h3 id="js%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8Bthread">js中的线程(Thread)</h3>
<ul>
<li>Single thread(one thing at a time)</li>
<li>Synchronous ececution(for now)</li>
</ul>
<p>众所周知，js是单线程的，既只有一个线程，也就是只能同时做一件事。那么执行顺序呢？同步进行，既一步一步，顺序执行，不会跳过当前的代码。</p>
<h3 id="%E6%9C%AC%E5%9C%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87local-execution-context">本地执行上下文(local execution context)</h3>
<p>调用函数(running/calling/invoking a functiong)与定义一个函数不同</p>
<p>当我们定义函数时，加上function关键字即可，当我们调用函数时，要在函数体后加上括号。（为了避免每次调用就重新写一遍函数，我们给函数命名一遍重复调用。并且因为不知道何时调用，我们暂时把函数体的代码放在内存中，当调用时直接访问内存，调用内存中的代码即可，所以如果我们想立即执行函数，可以直接把函数包起来，直接加括号调用，就是立即执行函数，应为垃圾回收机制，我们只想执行一次函数，用完就销毁，就可以不给函数命名，这样函数在内存中就没有其他引用，再直接加括号，那么函数执行完之后就会因为没有其他引用被垃圾回收机制销毁，这应该就是匿名立即执行函数）</p>
<p>当我们调用一个函数时，就创建了由以下两点组成的一个新的执行上下文(creat a new execution context comprising)：</p>
<ol>
<li>执行线程(thread of execution)，在函数内逐行解析代码。</li>
<li>一个本地存储空间(local memory){变量环境(Variable environment)}，其中存储函数中定义的任何内容。</li>
</ol>
<p>函数在执行结束前，返回的值就是undefined，函数内只定义了操作数据的方法，在执行结束后，才知道经过函数操作的数据内容也就是函数的返回值。函数并不关心输入与输出，函数本身只定义了方法。分析一个函数式，可以通过画图，左侧是线程区，右侧是内存区，代码沿着线程区顺序执行，在内存区存储相应的变量。</p>
<p>函数体内没有函数时，一切都很简单。但是，如果函数内调用了另一个函数，如果递归的调用函数呢？我们怎么追踪他们呢？</p>
<p>通过调用堆栈。</p>
<h3 id="%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88call-stack">调用堆栈(Call Stack)</h3>
<p>调用堆栈是一种特殊的数据结构，是一种存储数据信息的存储方式。一种能够使我们追踪到我们现在进行到哪，js现在解析到哪，线程现在执行到哪的特殊数据结构。</p>
<p>调用堆栈遵循先进后出的原则（可以看做一个桶，最先放入的最后拿出），全局执行上下文首先进入调用堆栈 <strong>（在调用堆栈的最上方就是js线程当前执行的环境）</strong> 。通过这个调用堆栈先进后出的这个机制，js解析器不用关心具体执行代码的所在位置，只关心调用堆栈最上方的执行上下文即可。当函数执行完毕时，执行上下文销毁，此时调用堆栈就回到了全局执行上下文。那么，把一个执行上下文添加到调用堆栈怎么说呢，<strong>pushing</strong>。怎么知道函数执行完毕呢（没有return的情况下），当线程执行完函数体内代码({}号内的代码)，会默认return一个undefined（这也是Chrome console中会不显式返回的情况下输出undefined的原因，既隐式返回了undefined）。把一个执行上下文从堆栈中删除怎么说呢，<strong>poping</strong>。</p>
<p>总结一下，当执行一个函数时，你创建了一个新的执行上下文，这个执行上下文包含一个线程，他逐行执行函数体内的代码，此时也开辟了一个局部存储空间(local memory)，用来存储任何不在全局存储空间(global memory)的变量及数据。此时，将这个执行上下文推到调用堆栈的顶部，js就会执行这个函数，执行完毕后，会将这个执行上下文推出调用堆栈，js继续执行调用堆栈顶部的执行上下文（既当前执行上下文的前一个执行上下文）。</p>
<p>这个本地存储空间(local memory)有一个学术化的名称--<strong>可变环境(environment of available variants)</strong>。</p>
<p>当我们定义一个函数时，我们只是在内存中开辟了一段空间存储定义函数的代码，所以如果console.log(函数名)，就会输出定义函数的代码(试验了一下，发现箭头函数和普通函数的输出内容并不一样，说明两者并不同)。</p>
<h3 id="%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0">三个基本元素</h3>
<p>执行上下文(execution context)，线程(thread)，调用堆栈(call stack)</p>
<p>深入了解js执行机制，不是出于理论目的，不是为了求知欲，我们了解这些是因为这些可以帮助我们debug，写一些干净的代码，使我们的想法实现的可能性更高。我们只需要了解其特性，并不需要我们了解具体如何实现，应为这对我们编程并没有影响。</p>
<h2 id="%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8Bfuncitional-programming">函数式编程(Funcitional Programming)</h2>
<h3 id="%E7%BA%AF%E7%B2%B9%E7%9A%84%E5%87%BD%E6%95%B0pure-functions">纯粹的函数(Pure Functions)</h3>
<p>函数式编程是一种编程范式，关于我们构建和思考如何大规模编写代码的方式。一般我们认为代码质量的评判标准是效率和性能，实际上评判代码的好坏更多的是其他开发人员是否能够快速读懂并添加功能。
在过去，最流行的编程范式是面相对象编程(OOP)，函数式编程是另一种构建代码的方式。
函数式编程有两个核心原则：</p>
<ul>
<li>纯粹的函数（没有副作用）
<blockquote>
<p>Pure functions(no side effects)</p>
</blockquote>
</li>
<li>高阶函数
<blockquote>
<p>Higher order functions - highly valuable tool &amp; often part of the Codesmith interview</p>
</blockquote>
</li>
</ul>
<p>纯粹函数追求的是除了函数的return值之外不改变其他任何值，函数中只存在用完即销毁的局部变量，函数内部没有改变(mutating)任何全局变量或不是函数内的变量。当我们改变了任何不属于函数内部的变量，会使得我们测试我们代码更加困难，增加了需要测试的范围。但是当函数除了返回值之外不做任何其他事，那么就可以在测试时只关心返回值得内容。</p>
<p>作为一个软件工程师，我们有函数，所以，Don't repeat yourself.函数出现的原因就是我们想要重复使用相同的功能，我们把他封装起来，通过一个标志来在需要的时候找到并引用它，这样，我们就可以只写一次，可以重复使用多次。这不仅仅是因为我们懒惰，更是为了写出更多可读的代码，可以重用的代码。我们不想要在需要修改同一个功能时修改多处，有了函数，我们只要修改一次。</p>
<p>函数有定义阶段和调用阶段，定义阶段，我们把函数的参数叫为形参(parameter)，就像二元一次方程中的x，是一个未知数。在调用阶段，我们会给函数一个实参(argument)，此时就是二元一次方程中明确告诉了x的值，只需要代入算式即可。所以其实形参只是一个占位符(placeholder)，代表了可能会传入函数的值，我们定义函数如何对占位符进行操作，在传入具体的参数时，我们只需要将具体值带入占位符即可。既然形参是一个站位符，那么我们是不是可以留一个占位符，代表了一些特定的功能，这个功能的返回值目前还不知道，只有调用这个功能时才能确认这个返回值呢？功能的英文就是function，翻译一下，就是我们的返回值是不是可以是一个函数？所以这个占位符代表的不是具体的数据，而是一个功能，这个函数目前没有返回值，因为只是定义没有调用，只有调用时，才能知道返回值。这应该就是高阶函数的本质。</p>
<h2 id="%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0callbacks-and-high-order-functions">回调函数和高阶函数(callbacks and high order functions)</h2>
<p>下面我们要进入一个精彩的编程世界。</p>
<p>下面是一个列表</p>
<ul>
<li>I know what a variable is
<blockquote>
<p>我知道什么是变量</p>
</blockquote>
</li>
<li>I've creat a function before
<blockquote>
<p>我之前写过一个函数</p>
</blockquote>
</li>
<li>I've add a CSS style before
<blockquote>
<p>我之前写过一个CSS样式</p>
</blockquote>
</li>
<li>I've implement a sort algorithm(bubble,merge,etc)
<blockquote>
<p>我之前完成过一个排序算法（冒泡、并归排序等）</p>
</blockquote>
</li>
<li>I can add a method to an object's prototype
<blockquote>
<p>我能在一个对象的原型上添加方法</p>
</blockquote>
</li>
<li>I understand the event loop in JavaScript
<blockquote>
<p>我理解JavaScript的事件循环</p>
</blockquote>
</li>
<li>I understand callback functions
<blockquote>
<p>我理解回调函数</p>
</blockquote>
</li>
<li>I've built a project in React or Angular
<blockquote>
<p>我写过一个React或Angular项目</p>
</blockquote>
</li>
<li>I can handle collisions in hash tables
<blockquote>
<p>我可以处理哈希表中的冲突</p>
</blockquote>
</li>
</ul>
<p>通过判断列表中所掌握的项目数量，我们可以给自己打一个分数（共九项，一至九分）。</p>
<p>这里提出了一个概念，成为一个初级开发人员相对容易，但是想要成为一个能够自主解决中级或高级问题的开发人员很难，这中间有一个陡峭的学习难度趋势图。</p>
<blockquote>
<p>我认为既是遵循了帕累托的二八原则，既想要获得百分之八十的成果需要百分之二十的努力，但想要获得剩余百分之二十的成果需要付出百分之八十的努力。</p>
</blockquote>
<h3 id="%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%BA%8B">学习困难的事</h3>
<p>在刚开始，我们只需要学习一些简单的事情即可成为一个”初级“开发者，但是要成为一个”高级开发者“，我们要学习一些难度很大的知识。就像完成一个edX课程并做完所有测试，或者Coursera的课程。当我们遇到了一个难题，我们的大脑会尝试让我们转移我们的注意力，去喝杯咖啡或者什么，但这就是我们成长的过程，必不可少。在我们学习困难的事(hard learning)时我们很容易想到放弃，但学习困难的事让我们成长。</p>
<p>即使我们没有放弃学习困难的事(刚开始我理解为努力学习，但我觉得并不准确，暂时就用学习困难的事理解)，我们仍面临两种选择。</p>
<p>在我们学习困难的事的过程中，例如LeetCode刷题或者看一个复杂项目的官方文档，你会发现你练单词都看不懂，例如LeetCode题意是啥都不明白，webpack的插件(plugin)和loading等概念。我们会做什么，我们可能会花一天时间去研究相关概念，在一天的结束时甚至没有敲一行代码，这就落入了一个<strong>研究者陷阱</strong>。</p>
<p>另一种，Stack Overflow型，我们遇见问题，去社区提问，有人之前遇到过，解决代码是这样，好，复制粘贴。什么？还是有问题？再找一个帖子，帖子里有另一段代码，复制粘贴，看看能不能解决问题。什么？还是不行。好吧，把问题和这两段代码一起发到社区上问问别人。这算是一种<strong>Stack Overflow方法</strong>。此时我们只是努力让程序正常跑起来，但是并不知道具体怎么跑起来的。</p>
<p>这里提出了结对编程的解决方案。在之前的两种情况中（一种我必须了解一切，一种我只是想让他发挥作用）折中的方案。结对编程的核心原则就是自己不写代码，而是由你像与你水平相当的小伙伴解释你的伪代码，让你的小伙伴来负责具体的代码实现。那么，如果想要解释清楚，就必须理解你的伪代码，但是也不需要理解的特别深入，因为你的小伙伴在等待你的解释。你也不能直接开始写代码，你的目的是通过代码逐行说话，把他变成实际的代码。所以你只能在这两种情况的中间（必须了解一切，但永远不会make hands dirty；什么都不懂，但是一直在敲自己不懂的代码来实现功能）。就像飞驰人生里的拉力赛，有一个领航员，一个车手，领航员负责指路，车手负责开车。实际也就是把分析写出伪代码和代码实现交给两个人，这样就可以使得每个人只专注与自己的部分，就像画画先画出轮廓，再填充细节，画轮廓时应该只关心轮廓，画细节时只关心当前部分的细节。而不是注意力来回跳转（话说有人似乎这么画画，但这不是我们选择的方式）。</p>
<h3 id="%E5%9B%9E%E8%B0%83%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0">回调和高阶函数练习</h3>
<blockquote>
<p><a href="http://csbin.io/callbacks" target="_blank" rel="noopener">callbacks</a></p>
</blockquote>
<pre><code class="language-JavaScript"><div><span class="hljs-comment">// Type JavaScript here and click "Run Code" or press Ctrl + s</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, world!'</span>);


<span class="hljs-comment">// Challenge 1</span>
<span class="hljs-comment">// Create a function addTwo that accepts one input and adds 2 to it.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTwo</span>(<span class="hljs-params">num</span>) </span>{
  <span class="hljs-keyword">return</span> num += <span class="hljs-number">2</span>
}

<span class="hljs-comment">// To check if you've completed it, uncomment these console.logs!</span>
<span class="hljs-comment">// console.log(addTwo(3));</span>
<span class="hljs-comment">// console.log(addTwo(10));</span>


<span class="hljs-comment">// Challenge 2</span>
<span class="hljs-comment">// Create a function addS that accepts one input and adds an "s" to it.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addS</span>(<span class="hljs-params">word</span>) </span>{
  <span class="hljs-keyword">return</span> word += <span class="hljs-string">'s'</span>
}

<span class="hljs-comment">// uncomment these to check your work</span>
<span class="hljs-built_in">console</span>.log(addS(<span class="hljs-string">'pizza'</span>));
<span class="hljs-built_in">console</span>.log(addS(<span class="hljs-string">'bagel'</span>));


<span class="hljs-comment">// Challenge 3</span>
<span class="hljs-comment">/*
Create a function called map that takes two inputs:
1.an array of numbers (a list of numbers)
2.a 'callback' function - a function that is applied to each element of the array (inside of the function 'map')
Have map return a new array filled with numbers that are the result of using the 'callback' function on each element of the input array.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">array, callback</span>) </span>{
  <span class="hljs-keyword">const</span> arr = []<span class="hljs-comment">// 创建一个新数组，最后返回这个数组</span>
  <span class="hljs-comment">// 遍历传入的数组，并将每一项经callback处理后添加到新数组中</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++){
    arr.push(callback(array[i]))
  }
  <span class="hljs-keyword">return</span> arr<span class="hljs-comment">// 返回处理过的数组</span>
}

<span class="hljs-built_in">console</span>.log(map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], addTwo));


<span class="hljs-comment">// Challenge 4</span>
<span class="hljs-comment">/*
  The function forEach takes an array and a callback, and runs the callback on each element of the array. forEach does not return anything.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span>(<span class="hljs-params">array, callback</span>) </span>{
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; array.length; i++){
    array[i] = callback(array[i])
  }
}
<span class="hljs-comment">// see for yourself if your forEach works!</span>
<span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
forEach(arr3,addTwo)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`forEach <span class="hljs-subst">${arr3}</span>`</span>)

<span class="hljs-comment">//--------------------------------------------------</span>
<span class="hljs-comment">// Extension</span>
<span class="hljs-comment">//--------------------------------------------------</span>

<span class="hljs-comment">//Extension 1</span>
<span class="hljs-comment">/*
  In the first part of the extension, you're going to rebuild map as mapWith. This time you're going to use forEach inside of mapWith instead of using a for loop.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapWith</span>(<span class="hljs-params">array, callback</span>) </span>{
  <span class="hljs-keyword">const</span> arr = [] <span class="hljs-comment">// 创建一个新数组</span>
  forEach(array, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{<span class="hljs-comment">// 使用forEach遍历数组</span>
    arr.push(callback(item)) <span class="hljs-comment">// 遍历时把数组的每一项都经callback处理后添加到新数组中</span>
  })
  <span class="hljs-keyword">return</span> arr <span class="hljs-comment">// 返回新数组</span>
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`mapWith <span class="hljs-subst">${mapWith([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], addTwo)}</span>`</span>)
<span class="hljs-comment">//Extension 2</span>
<span class="hljs-comment">/*
  The function reduce takes an array and reduces the elements to a single value. For example it can sum all the numbers, multiply them, or any operation that you can put into a function.
    var nums = [4, 1, 3];
    var add = function(a, b) { return a + b; }
    reduce(nums, add, 0);   //-&gt; 8
    0 + 4 = 4 =&gt; 4 + 1 = 5 =&gt; 5 + 3 = 8
  Here's how it works. The function has an "accumulator value" which starts as the initialValue and accumulates the output of each loop. The array is iterated over, passing the accumulator and the next array element as arguments to the callback. The callback's return value becomes the new accumulator value. The next loop executes with this new accumulator value. In the example above, the accumulator begins at 0. add(0,4) is called. The accumulator's value is now 4. Then add(4, 1) to make it 5. Finally add(5, 3) brings it to 8, which is returned.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">array, callback, initialValue</span>) </span>{
  <span class="hljs-keyword">let</span> total = initialValue <span class="hljs-comment">// 创建一个变量，记录最后的结果</span>
  forEach(array,item =&gt; { <span class="hljs-comment">// 遍历输入的数组</span>
    total = callback(item, total) <span class="hljs-comment">// 计算经callback处理后的当前项和前一项的值，保存在total中</span>
  })
  <span class="hljs-keyword">return</span> total <span class="hljs-comment">// 返回最终结果</span>
}
<span class="hljs-keyword">var</span> nums = [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{ <span class="hljs-keyword">return</span> a + b; }
<span class="hljs-built_in">console</span>.log(reduce(nums, add, <span class="hljs-number">0</span>))
<span class="hljs-comment">//Extension 3</span>
<span class="hljs-comment">/*
  Construct a function intersection that compares input arrays and returns a new array with elements found in all of the inputs. BONUS: Use reduce!
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>(<span class="hljs-params">arrays</span>) </span>{
  <span class="hljs-keyword">const</span> arrs = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>) <span class="hljs-comment">// 先把实参转化为数组</span>
  <span class="hljs-keyword">return</span> reduce(arrs, (previous, next) =&gt; { <span class="hljs-comment">// 遍历实参的每一项，对上次操作的结果和当前项进行操作，得出结果，供下一次循环与下一项一同传入函数进行操作</span>
    <span class="hljs-keyword">const</span> arr = [] <span class="hljs-comment">// 定义一个变量，存储交集数组</span>
    <span class="hljs-keyword">if</span> (previous.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// 因为初始化值是空的，直接跳到下一项，此时previous代表第一项，next是参数第二项</span>
    forEach(next, item =&gt; { <span class="hljs-comment">// 对第二项进行遍历</span>
      <span class="hljs-keyword">if</span>(previous.includes(item)){ <span class="hljs-comment">// 如果第二项的值包含在第一项中</span>
        arr.push(item) <span class="hljs-comment">// 把值添加到交集数组</span>
      }
    })
    <span class="hljs-keyword">return</span> arr<span class="hljs-comment">// 返回交集数组供下一次操作使用，下次执行时，previous为第二项，next为第三项</span>
  },[]) <span class="hljs-comment">// 返回最终的交集数组</span>
}

<span class="hljs-built_in">console</span>.log(intersection([<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>], [<span class="hljs-number">15</span>, <span class="hljs-number">88</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>]));
<span class="hljs-comment">// should log: [5, 15]</span>

<span class="hljs-comment">//Extension 4</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">arrays</span>) </span>{
  <span class="hljs-keyword">const</span> arrs = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>) <span class="hljs-comment">// 把实参转化为数组</span>
  <span class="hljs-comment">// 使用reduce函数，输入这个数组，传入一个callback处理这个数组，返回一个新数组</span>
  <span class="hljs-keyword">return</span> reduce(arrs, (previous, next) =&gt; {
    <span class="hljs-comment">// 传入两个数组，进行去重</span>
    forEach(next, item =&gt; {  <span class="hljs-comment">// 遍历第二个数组，此时previous为空数组，next为实参的第一个数组</span>
      <span class="hljs-keyword">if</span>(!previous.includes(item)) { <span class="hljs-comment">// 如果在第一个数组中不包含第二个数组的这一项</span>
        previous.push(item) <span class="hljs-comment">// 就添加到第一个数组中</span>
      }
    })
    <span class="hljs-keyword">return</span> previous<span class="hljs-comment">// 最终返回一个数组，数组中没有重复的项，下次调用时previous为此数组，next为实参的第二个数组</span>
  },[])
}

<span class="hljs-comment">// console.log(union([5, 10, 15], [15, 88, 1, 5, 7], [100, 15, 10, 1, 5]));</span>
<span class="hljs-comment">// should log: [5, 10, 15, 88, 1, 7, 100]</span>

<span class="hljs-comment">//Extension 5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objOfMatches</span>(<span class="hljs-params">array1, array2, callback</span>) </span>{

}

<span class="hljs-comment">// console.log(objOfMatches(['hi', 'howdy', 'bye', 'later', 'hello'], ['HI', 'Howdy', 'BYE', 'LATER', 'hello'], function(str) { return str.toUpperCase(); }));</span>
<span class="hljs-comment">// should log: { hi: 'HI', bye: 'BYE', later: 'LATER' }</span>

<span class="hljs-comment">//Extension 6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiMap</span>(<span class="hljs-params">arrVals, arrCallbacks</span>) </span>{

}

<span class="hljs-comment">// console.log(multiMap(['catfood', 'glue', 'beer'], [function(str) { return str.toUpperCase(); }, function(str) { return str[0].toUpperCase() + str.slice(1).toLowerCase(); }, function(str) { return str + str; }]));</span>
<span class="hljs-comment">// should log: { catfood: ['CATFOOD', 'Catfood', 'catfoodcatfood'], glue: ['GLUE', 'Glue', 'glueglue'], beer: ['BEER', 'Beer', 'beerbeer'] }</span>

</div></code></pre>
<h3 id="%E5%85%B3%E4%BA%8Econst%E5%92%8Clet">关于const和let</h3>
<p>我们应该尽量使用const定义变量，除非我们知道我们想要改变这个变量的值（重新给这个变量分配新的数据）。</p>
<h3 id="%E5%B9%BF%E4%B9%89%E5%87%BD%E6%95%B0generalizing-functiongs">广义函数(generalizing functiongs)</h3>
<p>这里举了个例子，我们写了一个function，给输入的数组每一项乘以2，返回一个处理后的数组；又写了一个function，给输入数组每一项加上2，返回一个处理后的数组；再写一个，给每一项除以2，返回一个处理后的数组。可以看出，function其他部分都一样，你要新建一个数组，给每一项加上/乘以/除以二，返回一个新数组。</p>
<p>那么，我们就违反了一个编程原则：Don't repeat your self!</p>
<h3 id="%E8%A7%A3%E6%9E%84%E5%B9%BF%E4%B9%89%E5%87%BD%E6%95%B0deconstructing-generalize-function">解构广义函数(deconstructing generalize function)</h3>
<p>我们可以把对每一项的处理变成一个函数，但是这个函数是不确定的，需要我们作为参数传入传入，只有在函数执行时，才知道传入的函数是什么，这就是callback。</p>
<p>在上面的例子中，我们把对每一项的处理的部分用一个占位符代替（callback），并在占位符后加括号代表这是一个function（函数），把需要处理的项作为实参传递到函数中。但是在执行这段代码前，这只是一个占位符。</p>
<p>在函数外部，我们定义一个函数，有一个形参，函数体内写入我们想要如何操作这个形参的代码，在这个阶段，函数体内的代码也没有执行，只是进行了定义。</p>
<p>最后，我们调用第一个函数，传入数据和第二个函数。在执行到处理数据的每一项时，每次处理js就执行第二个函数，把每一项作为实参传入第二个参数，返回一个新的值，添加到新数组中。</p>
<p>通过这种方法，我们降低了代码的耦合性，是的代码的复用度更高。</p>
<p>在问答环节，强调了函数的变量名只是一个占位符，并没有具体的值，只有在执行时才会发挥作用。</p>
<h3 id="%E7%AC%AC%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1first-class-object">第一等对象(first-class object)</h3>
<p>在js中，functions是第一等对象(frist-class objects)，这意味着函数像对象一样，我们可以传递一个对象作为函数的参数，那么，我们当然也可以传递一个函数作为参数。在js中，只有七种数据类型，其中六种是基本数据类型（Number、String、Null、Undefined、Boolean、Symbol）,一种复杂数据类型（Object），Array、Date、RegExp、Function都是Object的一种，是引用类型。传递基本类型是，我们直接传递基本类型的值，传递复杂数据类型或叫引用数据类型时，我们传递的是引用（指针）。</p>
<p>函数作为引用类型，可以直接把指针分配给变量，称作函数表达式，也可以作为其他对象的属性，此时我们一般把这个函数叫做这个对象的方法，函数还可以作为其他函数的参数，这些都是因为函数是一种对象，是一个引用类型，可以把指针进行传递，在需要的时候进行调用。</p>
<p>这就是函数在js中最为美妙的部分。</p>
<p>函数与相对于普通对象，有个一美妙的特性，你可以使用()调用。</p>
<h3 id="%E5%9B%9E%E8%B0%83%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0callbacks-and-high-order-functions">回调与高阶函数(callbacks and high order functions)</h3>
<p>我们传递给外部函数作为参数的函数叫做回调函数，接收这个函数作为参数的外部函数叫做高阶函数（他接受了一个函数，可以在函数内部实现其他函数的功能，所以级别比一个普通函数更高）。</p>
<p>接受一个函数作为参数或者返回一个函数作为输出结果的函数叫做高阶函数。</p>
<p>这只是描述这些函数的一个术语 - 我们把有这些行为（函数作为参数或返回一个函数）的函数叫做高阶函数 - 但是它们与普通函数本质上没有什么不同。</p>
<p>那么，既然高阶函数跟普通函数没有什么不同，为什么要提出这么一个概念呢？</p>
<p>高阶函数简化了我们的代码，使他们更加易读。(So callbacks and high order functions simplify our code and keep it DRY)</p>
<p>通过上面的例子我们可以清晰地看到这一点。</p>
<p>并且，高阶函数有更为强大的应用。(and they do something even powerful)</p>
<p>通过高阶函数，我们可以异步执行代码。(they allow us to run asynchronous code)</p>
<h2 id="%E9%97%AD%E5%8C%85closure">闭包(closure)</h2>
<p>当我们使用括号调用一个函数时，我们创建了一个变量环境(variable environment)，一般称作本地存储空间(local memory)，用于存储函数内定义的变量（本地变量，arguments等）。当函数执行完毕时，函数创建的执行上下文被调用栈推出，变量环境被销毁，<strong>除了函数的返回值</strong>。除了函数的返回值，函数的所创建的其他数据被垃圾回收机制回收删除，释放所占用的内存。那么，有没有一种办法能够在函数调用之前就保存一些数据呢？在一些情况下，我们希望函数能够保存一些数据，而不是每次都创建新的数据并在结束时全部回收（复杂计算的结果，之前运行的次数等情况）。这就是闭包存在的价值，他改变了我们编写代码的方式。这一切都从在一个函数内返回另一个函数开始。</p>
<h3 id="%E7%BB%83%E4%B9%A0">练习</h3>
<pre><code class="language-JavaScript"><div><span class="hljs-comment">/*
  Create a function createFunction that creates and returns a function. When that created function is called, it should print "hello".
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>)
  }
}

<span class="hljs-comment">// UNCOMMENT THESE TO TEST YOUR WORK!</span>
<span class="hljs-keyword">var</span> function1 = createFunction();
function1();


<span class="hljs-comment">/*
  Create a function createFunctionPrinter that accepts one input and returns a function. When that created function is called, it should print out the input that was used when the function was created.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFunctionPrinter</span>(<span class="hljs-params">input</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(input)
  }
}

<span class="hljs-comment">// UNCOMMENT THESE TO TEST YOUR WORK!</span>
<span class="hljs-keyword">var</span> printSample = createFunctionPrinter(<span class="hljs-string">'sample'</span>);
printSample();
<span class="hljs-keyword">var</span> printHello = createFunctionPrinter(<span class="hljs-string">'hello'</span>);
printHello();


<span class="hljs-comment">/*
  Examine the code for the outer function. Notice that we are returning a function and that function is using variables that are outside of its scope.
  Uncomment those lines of code. Try to deduce the output before executing.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">// this variable is outside incrementCounter's scope</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementCounter</span> (<span class="hljs-params"></span>) </span>{
    counter ++;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'counter'</span>, counter);
  }
  <span class="hljs-keyword">return</span> incrementCounter;
}

<span class="hljs-keyword">var</span> willCounter = outer();
<span class="hljs-keyword">var</span> jasCounter = outer();

<span class="hljs-comment">// Uncomment each of these lines one by one.</span>
<span class="hljs-comment">// Before your do, guess what will be logged from each function call.</span>

willCounter();<span class="hljs-comment">//1</span>
willCounter();<span class="hljs-comment">//2</span>
willCounter();<span class="hljs-comment">//3</span>

jasCounter();<span class="hljs-comment">//1</span>
willCounter();<span class="hljs-comment">//4</span>


<span class="hljs-comment">/*
  Now we are going to create a function addByX that returns a function that will add an input by x.
    var addByTwo = addByX(2);
    addByTwo(1); //should return 3
    addByTwo(2); //should return 4
    addByTwo(3); //should return 5

    var addByThree = addByX(3);
    addByThree(1); //should return 4
    addByThree(2); //should return 5

    var addByFour = addByX(4);
    addByFour(4); //should return 8
    addByFour(10); //should return 14
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addByX</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>) </span>{
    <span class="hljs-keyword">return</span> x + y
  }
}

<span class="hljs-keyword">var</span> addByTwo = addByX(<span class="hljs-number">2</span>);

<span class="hljs-comment">// now call addByTwo with an input of 1</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'addByTwo with 1'</span>,addByTwo(<span class="hljs-number">1</span>))

<span class="hljs-comment">// now call addByTwo with an input of 2</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'addByTwo with 2'</span>,addByTwo(<span class="hljs-number">2</span>))


<span class="hljs-comment">//--------------------------------------------------</span>
<span class="hljs-comment">// Extension</span>
<span class="hljs-comment">//--------------------------------------------------</span>
<span class="hljs-comment">/*
  Write a function once that accepts a callback as input and returns a function. When the returned function is called the first time, it should call the callback and return that output. If it is called any additional times, instead of calling the callback again it will simply return the output value from the first time it was called.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span>(<span class="hljs-params">func</span>) </span>{
  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>,
      result = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...arg</span>)</span>{
    <span class="hljs-keyword">if</span>(flag){
      result = func(...arg)
      flag = <span class="hljs-literal">false</span>
    }<span class="hljs-keyword">else</span>{
    <span class="hljs-keyword">return</span> result
    }
  }
}

<span class="hljs-keyword">var</span> onceFunc = once(addByTwo);

<span class="hljs-comment">// UNCOMMENT THESE TO TEST YOUR WORK!</span>
<span class="hljs-built_in">console</span>.log(onceFunc(<span class="hljs-number">4</span>));  <span class="hljs-comment">//should log 6</span>
<span class="hljs-built_in">console</span>.log(onceFunc(<span class="hljs-number">10</span>));  <span class="hljs-comment">//should log 6</span>
<span class="hljs-built_in">console</span>.log(onceFunc(<span class="hljs-number">9001</span>));  <span class="hljs-comment">//should log 6</span>

<span class="hljs-comment">/*
  Write a function after that takes the number of times the callback needs to be called before being executed as the first parameter and the callback as the second parameter.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">after</span>(<span class="hljs-params">count, func</span>) </span>{
  <span class="hljs-keyword">let</span> innerCount = <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span>(innerCount &lt; count){
      innerCount += <span class="hljs-number">1</span>
    } <span class="hljs-keyword">else</span> {
      func()
    }
  }
}

<span class="hljs-keyword">var</span> called = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>) };
<span class="hljs-keyword">var</span> afterCalled = after(<span class="hljs-number">3</span>, called);

afterCalled(); <span class="hljs-comment">// -&gt; nothing is printed</span>
afterCalled(); <span class="hljs-comment">// -&gt; nothing is printed</span>
afterCalled(); <span class="hljs-comment">// -&gt; 'hello' is printed</span>

<span class="hljs-comment">/*
  Write a function delay that accepts a callback as the first parameter and the wait in milliseconds before allowing the callback to be invoked as the second parameter. Any additional arguments after wait are provided to func when it is invoked. HINT: research setTimeout();
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">func, wait</span>) </span>{
  <span class="hljs-keyword">let</span> timeout
  clearTimeout(timeout)
  timeout = setTimeout(func, wait)
}

delay(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>)
}, <span class="hljs-number">2000</span>)

</div></code></pre>
<p>当我们调用一个函数，函数创建一个新的执行上下文，并将其推入调用栈的最顶端，使js优先执行。在执行完毕后，会返回一个返回值，然后函数的执行上下文被推出调用栈，执行上下文被垃圾回收机制回收，这是一个函数的生命周期。</p>
<p>但是，当函数返回一个在函数内部定义的函数时，情况变得稍微复杂起来。</p>
<p>当我们定义一个函数时，为了确保该函数能够访问其外部作用域的变量，js保留内部函数对外部函数变量的引用，此时，我们返回的不仅仅是一个函数体的代码，还有对齐定义时所在执行上下文的引用。所以即使外部执行函数已经执行完毕，但返回了内部函数，及内部函数与外部函数局部变量之间的联系。为了保持这种联系，也因为垃圾回收机制的原理，外部函数的变量数据并不会消失，仍保持着与内部函数的联系。但应为外部函数已经执行完毕，所以除了与内部函数之间的联系，通过其他方式无法找到这些数据。所以闭包的特殊之处在于它不仅仅是一个普通函数，还携带了定义时所在执行上下文（外部函数执行上下文）的数据，而且这个数据是存储在全局执行上下文中，但是除了内部函数外没有其他访问方式的。</p>
<p>这是js中最为美妙，最为深刻的概念！</p>
<p>在闭包中，js会保留内部函数引用的数据，回收其他未被引用的数据。复述一遍，我们得到了不止一个函数，还得到了一些因为被引用而保留下来的数据。</p>
<p>我想，这与引用类型传递的是指针而不是值本身有关系。（垃圾回收机制查看内存中那些数据没有被外部引用并进行回收，当我们执行外部函数时，数据被创建在内存中，外部函数执行完毕后，执行上下文被销毁。但是部分数据因为被内部函数引用，内部函数又因为被外部所引用，而保存下来。但是因为数据在外部函数的引用已经被销毁，只保留了内部函数对其的引用，所以只能通过内部函数来进行访问。）</p>
<h3 id="%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9Flexical-scope">词法作用域(lexical scope)</h3>
<p>定义函数时，它会获得一个[[scope]]属性，该属性引用已定义它的本地内存/变量环境</p>
<blockquote>
<p>When a function is defined, it gets a [[scope]] property that references the Local Memory/Variable
Environment in which it has been defined</p>
</blockquote>
<pre><code class="language-JavaScript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementCounter</span> (<span class="hljs-params"></span>)</span>{
    counter ++;
  }
  <span class="hljs-keyword">return</span> incrementCounter;
}
<span class="hljs-keyword">let</span> myNewFunction = outer(); <span class="hljs-comment">// myNewFunction = incrementCounter</span>
myNewFunction();
myNewFunction();
</div></code></pre>
<p>当我们调用incrementCounter函数时，会首先查找他自己的本地存储空间（变量环境），然后在[[scope]]的next的属性中查找</p>
<blockquote>
<p>Wherever we call that incrementCounter function - it will always look first in its immediate local
memory (variable environment), and then in the [[scope]] property next before it looks any further up</p>
</blockquote>
<p>所以是否是因为函数也是一个对象，对象就有属性和方法，每一个函数都是Function的实例，在实例创建时，会有一个[[scope]]属性，这个属性应该也是一个对象，然后在[[scope]]中有一个next属性，指向了其定义时函数的[[scope]]属性。这样就可以沿着这个原型链来访问其中的数据。</p>
<h3 id="javascript%E7%9A%84%E9%9D%99%E6%80%81%E8%AF%8D%E6%B3%95%E8%8C%83%E5%9B%B4javascript-staticlexical-scoping">JavaScript的静态/词法范围(JavaScript static/lexical scoping)</h3>
<p>这就是当我们说JavaScript是词法或静态范围时，所表达的意思
我们的词法作用域（函数定义时可以使用的实时数据）决定了函数执行时可以访问的变量以及访问变量的优先顺序，而不是在函数调用时决定可以访问的数据及访问优先级。</p>
<blockquote>
<p>This is what it means when we say JavaScript is lexically or statically scoped
Our lexical scope (the available live data when our function was defined) is what determines our available variables and prioritization at function execution, not where our function is called</p>
</blockquote>
<p>当我们定义一个函数时，函数所能访问的数据就会被函数的[[scope]]属性所引用，这样就不会被垃圾回收机制回收，就会被一直保存下来，直到函数被销毁。</p>
<p>所以闭包是一个名词，代表着函数携带的数据，或者叫lexical scope reference。</p>
<p>当我们想访问闭包中的数据时，我们可以通过在内部函数中return来获取数据的指针。</p>
<p>当我们重新执行外部函数时，创建了一个新的执行上下文，返回了一个新的内部函数，如果新的内部函数引用了了新的外部函数执行上下文中的数据，那么显然，是一个新的数据。</p>
<p>在我们定义或者说声明一个函数时，我们给函数创建了一个新的词法作用域，引用了函数可以访问的数据。函数内部如果定义一个函数，同样会创建一个新的词法作用域，当然这个内部函数的词法作用域可以指向外部函数。当我们返回内部函数时，外部函数已经执行完毕，其执行上下文销毁，但是因为内部函数的词法作用域存在着对外部函数局部数据的引用，所以返回内部函数时也会返回一个词法作用域引用，也就是闭包。</p>
<h3 id="%E9%97%AD%E5%8C%85%E7%9A%84%E5%8A%9B%E9%87%8Fthe-power-of-closure">闭包的力量(The power of Closure)</h3>
<p>闭包可以使我们的函数有”记忆“，既可以操作闭包中的数据（私有变量）的内部函数来实现一个计时器或者”自动销毁“（执行一定次数后就不在执行回调函数）的函数。</p>
<p>我们也可应在js中通过闭包实现模块模式。（我们不想污染全局作用域）</p>
<blockquote>
<p>Now: Our functions get 'memories' - once, memoize
Advanced: We can implement the module pattern in JavaScript</p>
</blockquote>
<h2 id="%E5%BC%82%E6%AD%A5%E7%9A%84javascriptasynchrous-javascript">异步的JavaScript(Asynchrous JavaScript)</h2>
<p>异步是现代JavaScript网络开发的基石</p>
<blockquote>
<p>Asynchronicity is the backbone of modern web development in JavaScript</p>
</blockquote>
<p>JavaScript是单线程的（一次执行一个命令），并具有同步执行模型(按照每行代码的顺序执行)</p>
<blockquote>
<p>JavaScript is single threaded (one command executing at a time) and has a synchronous execution model (each line is executed in order the code appears)</p>
</blockquote>
<p>通过上面的学习，我们知道，JavaScript是单线程的(single thread)。这就意味着在js执行代码时一般是一行行解析执行。但这就引申出来一个问题，或者说一个需求：如果我们需要等待一段时间在执行一个功能(function)怎么办？</p>
<p>在实际的开发情况中，这是一个常见的需求。例如我们需要等待服务器返回一段数据之后再进行相应的操作，又或者设置一个定时器等。此时，我们就有了一个新的需求，既如何在不阻碍js继续解析执行的前提下，定义一个在一段时间后执行的函数（例如先获取用户数据，再根据用户的数据信息显示对应评论，同时不影响页面加载）。</p>
<pre><code class="language-JavaScript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printHello</span>(<span class="hljs-params"></span>)</span>{
 <span class="hljs-built_in">console</span>.log(“Hello”);
}
setTimeout(printHello,<span class="hljs-number">1000</span>);
<span class="hljs-built_in">console</span>.log(“Me first!”);
</div></code></pre>
<p>如果了解setTimeout函数的作用，我们知道，上面的代码首先会在控制台打印出Me first!，然后才是Hello。但是这与我们前面所学习的知识并不一致。那么，setTimeout函数的原理是什么，它为什么可以做出不符合我们之前所学习知识的行为？</p>
<pre><code class="language-JavaScript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printHello</span>(<span class="hljs-params"></span>)</span>{
 <span class="hljs-built_in">console</span>.log(“Hello”);
}
setTimeout(printHello,<span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(“Me first!”);
</div></code></pre>
<p>分析上面代码，根据我们对setTimeout的函数作用的了解，我们可以知道控制台会首先打印出Me first!，然后是Hello。</p>
<p>以上两种结果的出现，并不是因为我们之前所学是错误的，是因为我们所学习的JavaScript执行模型是不完整的。</p>
<blockquote>
<p>Our previous model of JavaScript execution is insufficient</p>
</blockquote>
<p>既然有了新的需求，那么我们就要在JavaScript这个平台上添加新的功能。</p>
<p>在之前的学习中，我们在函数执行时，我们有如下三个组件</p>
<ul>
<li>Thread of execution（执行线程）</li>
<li>Memory/variable environment（变量环境）</li>
<li>Call stack（调用栈）</li>
</ul>
<p>现在因为新的需求，我们添加了一下三个组件</p>
<ul>
<li>Web Browser APIs/Node background threads（浏览器内置功能 /节点后台线程）</li>
<li>Callback/Message queue（回调函数/消息队列）</li>
<li>Event loop（事件循环）</li>
</ul>
<h3 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BDweb-browser-api">浏览器内置功能(Web Browser API)</h3>
<p>这里，我们首先学习浏览器的API(Application Program Interface)，通过上面代码的执行结果，我们知道，只有之前的三种模型（线程、执行上下文，调用栈）是无法解释这个执行结果的。</p>
<p>让我们逐步分析下面代码的执行过程</p>
<pre><code class="language-JavaScript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printHello</span>(<span class="hljs-params"></span>)</span>{
 <span class="hljs-built_in">console</span>.log(“Hello”);
}
setTimeout(printHello,<span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(“Me first!”);
</div></code></pre>
<p>在代码执行最开始，我们首先创建了一个全局执行上下文，并将全局执行上下文推动到调用栈，然后线程执行到函数第一行。</p>
<p>在函数第一行，我们声明了一个函数，将这个函数的指针赋值给printHello这个变量。在声明函数时，同时也给函数创建了一个引用了当前全局作用域的词法作用域引用。</p>
<p>然后代码执行到第二行，我们调用了setTimeout函数，并将printHello变量的值，既我们声明的printHello函数的指针和一个基本类型值0作为两个参数传入。</p>
<p>按照我们之前所学，此时应该创建setTimeout的执行上下文，执行函数内的代码，又因为setTimeout是一个延时执行的函数，所以我们在等待一段时间后返回结果，将执行上下文推出调用栈，线程回到全局执行上下文，执行console.log()。</p>
<p>如果我们按照这个步骤执行，那么显然，代码的执行进程会卡在setTimeout上，等待setTimeout执行完毕后才会进行下一步。</p>
<p>但明显，这段代码并不是如此运行的，如果因为延时函数阻塞了js的进程也与我们的常见需求不符。那么，是因为什么代码才会如此执行呢？</p>
<p>在我们执行js时，js的执行环境中并不只有js，我们还有其他的外部环境，最常见的就是网络浏览器。</p>
<p>所以在js执行时，我们不仅有js，还有Web Browser APIs。这些API不止在js执行时发挥作用，这些功能(feature)还有许多其他功能供浏览器使用。其中一个很重要的工具就是一个计时器(timer)。</p>
<p>因为js是单线程的，为了不阻塞后面代码的执行，js会调用浏览器的API，通过浏览器来创建一个新的线程。此时，浏览器会创建一个后台计时器(background timer)。此时，我们使用的并不是js本身，而是一个浏览器的API。</p>
<p>所以当我们执行setTimeout函数时，并不是像js函数一样的执行过程。此时，setTimeout并不会在js的执行环境中创建执行上下文，而是会调用浏览器API，在浏览器的执行环境内创建一个执行环境，并开始计时。此时js代码调用浏览器api后并不会等待返回结果，而是为了不阻塞代码的执行而直接执行下一行console.log()，在控制台输出”me first“。在浏览器的计时器计时结束后，浏览器会将传入的函数返回到全局执行上下文，并调用函数，创建执行上下文，推入调用栈，执行函数，返回结果后将执行上下文从调用栈中推出。此时执行结果是在控制台打印”hello“。</p>
<h3 id="%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0">编程练习</h3>
<pre><code class="language-JavaScript"><div><span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">// CHALLENGE 1 //</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">/*
  Write code that will log to the console, 'I am at the beginning of the code'.

  Beneath that console log, set a timer (see setTimeout) that will log to the console 'I am in the setTimeout callback function' after 3 seconds (3000 ms)

  Next, add code to the end of the challenge to log 'I am at the end of the code'. Now re-run the code.

  Make sure the 'console' and 'output' panes are showing (click the tabs above if not) and then run your code with the 'Run with JS' button.

  Clear the console. Change the delay time in the time from 3000 ms to 0. Think hard about how the order should change and then run the code again.
*/</span>
<span class="hljs-comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start of Challenge 1'</span>);
<span class="hljs-comment">// ...your code below</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am at the beginning of the code'</span>)

<span class="hljs-comment">// setTimeout(() =&gt; {</span>
<span class="hljs-comment">//   console.log('I am in the setTimeout callback function')</span>
<span class="hljs-comment">// }, 3000) // 会在所有控制台打印完毕后打印。</span>

setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am in the setTimeout callback function'</span>)
}, <span class="hljs-number">0</span>) <span class="hljs-comment">// 还是会在所有控制台打印完毕后打印。</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am at the end of the code'</span>)





<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End of Challenge 1'</span>);
<span class="hljs-comment">// */// (do not alter this line)</span>




<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">// CHALLENGE 2 //</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">/////////////////</span>

<span class="hljs-comment">/*
  Write code that will log to the console "Interval Hello!" every 2 seconds (see setInterval). Use the given clearAllIntervals function to clear all the messages when you have this functionality working.

  Next, modify your code so that the "Interval Hello!" messages will automatically stop after 10 seconds.

  Then, modify your code again so that the "Interval Hello!" messages will automatically stop after 10 seconds without use of the clearAllIntervals function, and using clearInterval only once. Perform research if you are unsure how to do this.
*/</span>

<span class="hljs-comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start of Challenge 2'</span>);
<span class="hljs-comment">// ...your code below</span>

<span class="hljs-keyword">const</span> timeId = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Interval Hello!'</span>)
}, <span class="hljs-number">2000</span>) <span class="hljs-comment">// 会在控制台最后打印</span>

setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  clearInterval(timeId)
}, <span class="hljs-number">10000</span>)



<span class="hljs-comment">// ...your code above</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearAllIntervals</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
    clearInterval(i);
  }
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End of Challenge 2'</span>);
<span class="hljs-comment">// */// (do not alter this line)</span>



<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">// CHALLENGE 3 //</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">/////////////////</span>

<span class="hljs-comment">/*
  Write a function everyXsecsForYsecs that will accept three arguments: a function, an interval time in seconds, and a total time in seconds. everyXsecsForYsecs should invoke the given function every X times 1000 milliseconds, but then stop invoking the function after Y times 1000 milliseconds.

  Write function sayHowdy that will log "Howdy" to the console. Then test your everyXsecsForYsecs function by using it to invoke sayHowdy every 1 second for 5 seconds.

  Now, modify your everyXsecsForYsecs function so it does not use setInterval, but still keeps the same functionality.
*/</span>

<span class="hljs-comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start of Challenge 3'</span>);
<span class="hljs-comment">// ...your code below</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">everyXsecsForYsecs</span>(<span class="hljs-params">func, intervalTime, totalTime</span>) </span>{
  <span class="hljs-keyword">const</span> timeId = setInterval(func, intervalTime * <span class="hljs-number">500</span>)
  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    clearInterval(timeId)
  }, totalTime * <span class="hljs-number">500</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHowdy</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Howdy'</span>)
}

everyXsecsForYsecs(sayHowdy, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">everyXsecsForYsecs2</span>(<span class="hljs-params">func, intervalTime, totalTime</span>) </span>{
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalTime / intervalTime; i++){
    setTimeout(func, intervalTime * <span class="hljs-number">500</span>)
  }
}

everyXsecsForYsecs2(sayHowdy, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>)


<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End of Challenge 3'</span>);
<span class="hljs-comment">// */// (do not alter this line)</span>




<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">// CHALLENGE 4 //</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">/*
  Recreate the built in array method, forEach: Write a function that takes as parameters an array, arr, and a callback function, cb. The forEach function will iterate through arr passing each element and its index as arguments to cb.

  Create a variable named delays and assign to it an array with the numbers 2000, 5000, 0, and 3500 (in that order).

  Write a function, delayLog, that takes as input a delayTime and an index, i. When invoked, the function should wait delayTime milliseconds before logging to the console, "printing element i" (with "i" replaced with the actual index passed in).

  Putting it all together, run the delayLog function on each item of the delays array using the forEach function you created.
*/</span>
<span class="hljs-comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start of Challenge 4'</span>);
<span class="hljs-comment">// ...your code below</span>
<span class="hljs-comment">// part 1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span>(<span class="hljs-params">arr, callback</span>) </span>{
  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Array</span>.isArray(arr)) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++){
    callback(arr[i], i)
  }
}
<span class="hljs-comment">// part 2</span>
delay = [<span class="hljs-number">2000</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3500</span>]
<span class="hljs-comment">// part 3</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delayLog</span>(<span class="hljs-params">delayTime, index</span>) </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`print element <span class="hljs-subst">${index}</span>`</span>)
  }, delayTime)
}
<span class="hljs-comment">// part 4</span>
forEach(delay, delayLog)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End of Challenge 4'</span>);
<span class="hljs-comment">// */// (do not alter this line)</span>



<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">// CHALLENGE 5 //</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">/*
  Write a function changeColor that when invoked will first check if the current page background color is "rgb(221, 238, 255)". If it is, it changes the color to "rgb(255, 238, 221)". If it isn't, it sets the color to "rgb(221, 238, 255)".

  Add a click event listener to button #1 above (it has an id of "activate"). On click, the button should log to the console "clicked #1". It should also set up a click event listener on button #2 (id of "color"). That listener should log to console "clicked #2" and then call the changeColor function you just created.

  Clear the console and hit the 'Run with JS' button. Look at what code has run by analyzing the console. Then try to change the background color by clicking button #2. What needs to happen for the button to work?
*/</span>
<span class="hljs-comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start of Challenge 5'</span>);
<span class="hljs-comment">// ...your code below</span>
<span class="hljs-comment">// part 1</span>
<span class="hljs-keyword">let</span> background = <span class="hljs-built_in">document</span>.body.style.background
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span>(background === <span class="hljs-string">"rgb(221, 238, 255)"</span>){
    background = <span class="hljs-string">"rgb(255, 238, 221)"</span>
  }<span class="hljs-keyword">else</span>{
     background = <span class="hljs-string">"rgb(221, 238, 255)"</span>
  }
  <span class="hljs-built_in">console</span>.log(background)
}
<span class="hljs-comment">// part 2</span>
<span class="hljs-keyword">const</span> activateBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"activate"</span>)
<span class="hljs-keyword">const</span> colorBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"color"</span>)
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleColorBtn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"clicked #2"</span>)
  changeColor()
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleActivateBtn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"clicked #1"</span>)
  colorBtn.addEventListener(<span class="hljs-string">'click'</span>, handleColorBtn)
}

activateBtn.addEventListener(<span class="hljs-string">'click'</span>, handleActivateBtn)

<span class="hljs-comment">// ...your code above</span>
<span class="hljs-built_in">document</span>.body.style.background = <span class="hljs-string">'#def'</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End of Challenge 3'</span>);
<span class="hljs-comment">// */// (do not alter this line)</span>



<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">// CHALLENGE 6 //</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">/*
  In this challenge we are going to simulate an AJAX call to get information from a server. This is not a real AJAX call, but the asynchonicity is similar.

  Modify the function ajaxSimulate to take an id and a callback function as input. After the database array, set a timer that will pass the element of database whose index matches id to the callback function after 0 ms.

  Create a second function storeData (outside of ajaxSimulate) that takes data as input and assigns it to the dataReceived variable already defined.

  Invoke the ajaxSimulate function with an id of 1 and the storeData function as the callback. Immediately after, log to the console the value of dataReceived. What do you expect it to be?

  Without changing anything else, copy-paste the console.log statement somewhere where it will log with the info we need.
*/</span>
<span class="hljs-comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start of Challenge 6'</span>);
<span class="hljs-keyword">var</span> dataReceived;
<span class="hljs-comment">// part 1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajaxSimulate</span>(<span class="hljs-params">id, callback</span>) </span>{
  <span class="hljs-keyword">var</span> database = [<span class="hljs-string">'Aaron'</span>, <span class="hljs-string">'Barbara'</span>, <span class="hljs-string">'Chris'</span>];
  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    callback(database[id])
  }, <span class="hljs-number">0</span>)
}
<span class="hljs-comment">// ...your code below</span>
<span class="hljs-comment">// part 2</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">storeData</span>(<span class="hljs-params">data</span>) </span>{
  dataReceived = data
}
<span class="hljs-comment">// part 3</span>
ajaxSimulate(<span class="hljs-number">1</span>, (data) =&gt; {
  storeData(data)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`part 4 <span class="hljs-subst">${dataReceived}</span>`</span>)
})
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`part 3 <span class="hljs-subst">${dataReceived}</span>`</span>) <span class="hljs-comment">// undefined</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End of Challenge 6'</span>);
<span class="hljs-comment">// */// (do not alter this line)</span>



<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">// CHALLENGE 7 //</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">/*
  Perform a GET request to the Bandsintown API (hosted by swaggerhub) (follow this link and then make sure 'UI' is sellected at the upper left, to read how to use their API) to search for your favorite band. For the 'app_id', use the string 'jshp'.

  Then in the returned JSON, find the URL for the image associated with the band and display it in the DOM.

  Make sure to use 'https' for JSBIN to allow the request. There is a div with the ID 'ch2' for you to target. If you want, you can view this div by opening the HTML pane, by clicking the HTML button at the top.
*/</span>
<span class="hljs-comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start of Challenge 7'</span>);
<span class="hljs-comment">// ...your code below</span>
<span class="hljs-keyword">const</span> Http = <span class="hljs-keyword">new</span> XMLHttpRequest() <span class="hljs-comment">//新建一个异步请求对象</span>
<span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://rest.bandsintown.com/artists/sleepingwithsirens?app_id=jshp'</span> <span class="hljs-comment">// 把请求地址及请求id保存在url中</span>
Http.open(<span class="hljs-string">'get'</span>, url) <span class="hljs-comment">// 新建一个get请求</span>
Http.send() <span class="hljs-comment">// 发起一个请求</span>

Http.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readyState == <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-keyword">this</span>.status == <span class="hljs-number">200</span>){
    <span class="hljs-keyword">let</span> response = Http.responseText
    dataHandler(<span class="hljs-built_in">JSON</span>.parse(response))
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataHandler</span>(<span class="hljs-params">data</span>) </span>{
  $(<span class="hljs-string">"#ch2"</span>).append(<span class="hljs-string">`&lt;img src="<span class="hljs-subst">${data.image_url}</span>"/&gt;`</span>)
}


<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End of Challenge 7'</span>);
<span class="hljs-comment">// */// (do not alter this line)</span>



<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">// CHALLENGE 8 //</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">/////////////////</span>

<span class="hljs-comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start of Challenge 8'</span>);
<span class="hljs-comment">// ...your code below</span>






<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End of Challenge 8'</span>);
<span class="hljs-comment">// */// (do not alter this line)</span>



<span class="hljs-comment">/////////////////</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">// CHALLENGE 9 //</span>
<span class="hljs-comment">//             //</span>
<span class="hljs-comment">/////////////////</span>

<span class="hljs-comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start of Challenge 9'</span>);
<span class="hljs-comment">// ...your code below</span>







<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End of Challenge 9'</span>);
<span class="hljs-comment">// */// (do not alter this line)</span>



</div></code></pre>
<h3 id="%E5%9B%9E%E8%B0%83%E9%98%9F%E5%88%97callback-queue">回调队列(callback queue)</h3>
<p>既然我们调用的是浏览器的api，并且此api与js的执行模型并不一样，那么我们就需要了解此api的执行模型，以便我们预测api执行的行为结果。</p>
<p>当我们执行一个setTimeout或者setInterval时，我们把参数传递给函数后，不会等待方法执行，阻碍线程，而是直接进行下一步。那么，setTimeout或setInterval计时完毕后，什么时候通知js执行对应的函数呢？直接将函数推入调用栈？那这样是不是会影响到当前调用栈的执行？此时我们需要一个工具来解决js执行函数的顺序。</p>
<p>这个工具有两个部分：</p>
<ol>
<li>回调函数/消息/任务队列(callback/message/task queue)</li>
<li>事件循环(event loop)</li>
</ol>
<h4 id="%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97">任务队列</h4>
<p>如果计时器计时结束，我们并不会把回调函数立即推入调用栈，以免扰乱调用栈内函数的执行顺序，所以我们新建一个队列（先进先出），计时结束后，我们就将回调函数推入队列，该任务队列会在js的主线程执行完毕后（调用栈内全部线程执行完成，所有执行上下文被推出，调用栈为空）将队列内的首个函数推入js的调用栈，此时队列内第二个函数成为首个函数，调用栈主线程执行完毕后，再将首个函数推入调用栈，依次循环。</p>
<p>举例：就像一个非常忙的领导(JavaScript)交给属下(Web Browser API)一件事，属下可能立马就办完了，但是领导非常忙，属下不能立马汇报给领导，只能等领导忙完了在汇报。那么，如果有多件事交给属下，属下一件件办好，然后把结果按照办完的顺序记录下来，等领导忙完了，按照记录的顺序一件件汇报给领导。</p>
<h3 id="%E5%9B%9E%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFcallback-queue--event-loop">回调队列和事件循环(callback queue &amp; event loop)</h3>
<p>对于异步延迟代码的执行，我们有两条规则</p>
<blockquote>
<p>We have two rules for the execution of our asynchronously delayed code</p>
</blockquote>
<ol>
<li>当API“完成”时，在队列(回调队列)中保存每个延迟函数
<blockquote>
<p>Hold each deferred function in a queue (the Callback Queue) when the API ‘completes’</p>
</blockquote>
</li>
<li>只有当调用堆栈完全为空时才将函数添加到调用堆栈(即执行函数)(让事件循环检查此条件)
<blockquote>
<p>Add the function to the Call stack (i.e. execute the function) ONLY when the call stack is totally empty (Have the Event Loop check this condition)</p>
</blockquote>
</li>
</ol>
<p>这个异步的线程不是发生在js中的，js是单线程的，js只有依靠网络浏览器提供的api来模拟出异步执行。</p>
<p>事件循环就是一个不断检查js调用栈是否为空，然后检查任务队列是否为空的过程。</p>
<p>所以即使把延时设置为0，传入的回调函数也只能在js主线程全部执行完之后，才会在任务队列中推出回调函数到调用栈中执行。除了setTimeout，我们还有其他方法是按照此模型来进行的。</p>
<h3 id="%E9%97%AE%E7%AD%94%E7%8E%AF%E8%8A%82">问答环节</h3>
<p>是否有办法绕过事件循环？并没有，要按照此模型严格执行，否则无法预测函数的执行顺序。</p>
<h3 id="%E5%85%B6%E4%BB%96%E6%B5%8F%E8%A7%88%E5%99%A8apiintroduce-more-browser-apis">其他浏览器API(introduce more Browser APIs)</h3>
<p>在很多情况下，等待会阻塞线程，我们使用浏览器api来代替</p>
<blockquote>
<p>There are many things where waiting would block our thread and we use Browser APIs for instead</p>
</blockquote>
<ul>
<li>A timer to finish running(一个计时器)</li>
<li>New information from a server (Ajax)（一个服务器请求Ajax）</li>
<li>Indication that a portion of the page has loaded（指示页面的一部分已加载）</li>
<li>User interaction (clicks, mouseovers, drags)（用户交互(单击、鼠标移动、拖动)）</li>
<li>Writing/Reading to File system (Node)（写入/读取文件系统(node.js)）</li>
<li>Writing/reading database (Node)（写入/读取数据库(node.js)）</li>
</ul>
<p>在返回数据时。我们使用的浏览器的API的设计决定了我们如何接受这些数据。</p>
<blockquote>
<p>Some come back with data. The design of the Browser API we are using determines how we access the returned data</p>
</blockquote>
<p>在强调一遍，浏览器API并不属于js，是一个native code，使用c++等语言编写的内置于浏览器的功能。Js本身无法进行网络请求，Js通过XMLHttpRequest这个浏览器内置功能来进行网络请求。</p>
<p>所以setTimeout是js与本地浏览器之间的交互功能，XMLHttpRequest是js与其他网络服务器见交换数据的功能（feature）</p>
<h3 id="xmlhttprequest">XMLHttpRequest</h3>
<p>就像setTimeout一样，我们传入的回调函数并不会在XMLHTTPRequest()中执行，而是在XMLHttpRequest方法中，获取到数据后，将回调函数推送到任务队列，在主线程执行完毕后，将回调函数推送到调用栈的最顶端，并将XMLHttpRequest内获取到的数据作为一个实参传递给回调函数。</p>
<p>因为XMLHttpRequest也是一个函数，只不过用其他语言编写，所以传递给回调函数的参数的顺序要查询文档，根据作者文档中的定义顺序来决定我们编写回调函数时形参的顺序。</p>
<p>与setTimeout一样，XMLHttpRequest执行完毕后会将回调函数及获取的数据推入任务队列中，此时事件循环会不断检查js的调用栈是否清空，如果清空将任务队列的第一个回调函数及其参数推送到调用栈最顶端执行。</p>
<p>异步回调函数、Web API、回调队列和事件循环允许我们延迟操作，直到“工作”(API请求、计时器等)完成并同时逐行运行代码</p>
<blockquote>
<p>Asynchronous callbacks, Web APIs, the Callback Queue and Event loop allow us to defer our actions until the ‘work’ (an API request, timer etc) is completed and continue running our code line by line in the meantime</p>
</blockquote>
<h4 id="%E5%BC%82%E6%AD%A5javascript%E6%98%AF%E7%8E%B0%E4%BB%A3web%E7%9A%84%E6%94%AF%E6%9F%B1%E8%AE%A9%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%9E%84%E5%BB%BA%E5%BF%AB%E9%80%9F%E7%9A%84%E6%B2%A1%E6%9C%89%E9%98%BB%E5%A1%9E%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">异步JavaScript是现代web的支柱——让我们可以构建快速的“没有阻塞的”应用程序</h4>
<blockquote>
<p>Asynchronous JavaScript is the backbone of the modern web - letting us build fast ‘nonblocking’ applications</p>
</blockquote>
<h2 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84javascript---%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Bobject-oriented-javascript-%E2%80%93-approaches-to-oop">面向对象的JavaScript - 理解面向对象编程(Object-oriented JavaScript – Approaches to OOP)</h2>
<h3 id="%E4%BB%8B%E7%BB%8Djs%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1introducing-object-oriented-javascript">介绍JS中的面向对象(introducing Object-Oriented JavaScript)</h3>
<p>面相对象编程(Object-Oriented Programming)——一种非常流行的用于构造复杂代码的范例</p>
<blockquote>
<p>OOP - an enormously popular paradigm for structuring ourcomplex code</p>
</blockquote>
<ul>
<li>easy to add features and functionality(轻松地添加功能并且功能化代码)</li>
<li>performant(efficient in terms of memory)(性能更好(在内存方面的效率))</li>
<li>easy for us and other developers to reason about(a clear structure)(代码的可读化，语义化更好（结构清晰）)</li>
</ul>
<p>当我们的代码越来越复杂，规模越来越庞大时，我们需要一种结构化的方式来将代码组织起来。面相对象编程范式可以让我们轻松的添加功能。
可以互相引用方法，因为方法存储在内存中，传递的只是一个指针，所以互相引用，而不是在开辟一块内存空间，可以提高内存的使用效率。
而且是其他人更容易推测出代码代表的功能。</p>
<p>我们想要实现一个功能，就要有相应的输入和方法，这样我们把数据和方法提供给计算机，计算机才能根据我们提供的数据和方法计算出结果返回给我们。面相对象编程就是利用这个原理，把计算所需的数据及方法都封装到一起，使用一个对象来组织所需的数据与方法，在需要时调用，提供给计算机进行计算。</p>
<p>此时举了一个例子，我们有一场比赛，希望统计每个人的分数。显而易见，每个人都有名字和分数，然后我们有一些公用的方法，适用于比赛的所有选手（增加得分，减少得分，删除选手，增加选手，增加角色，获取某选手得分。。。）。</p>
<p>对象——可以存储功能和与其相关的数据！</p>
<blockquote>
<p>Objects - store functions with their associated data!</p>
</blockquote>
<h4 id="%E8%BF%99%E7%A7%8D%E5%B0%86%E6%88%91%E4%BB%AC%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E6%93%8D%E4%BD%9C%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%91%E5%AE%9A%E5%9C%A8%E4%B8%80%E8%B5%B7%E6%83%B3%E6%B3%95%E5%B0%B1%E5%8F%AB%E5%B0%81%E8%A3%85">这种将我们所需要的数据和操作这些数据的方法绑定在一起想法，就叫封装。</h4>
<pre><code class="language-JavaScript"><div><span class="hljs-keyword">let</span> user1 = {
 <span class="hljs-attr">name</span>: <span class="hljs-string">"Will"</span>,
 <span class="hljs-attr">score</span>: <span class="hljs-number">3</span>,
 <span class="hljs-attr">increment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
 user1.score++;
 }
};
user1.increment(); <span class="hljs-comment">//user1.score =&gt; 4</span>
</div></code></pre>
<p>在上述代码开始执行时，我们首先声明了一个变量user，并创建了一个新的对象，将对象的引用赋值给user。然后就进行到了全局执行上下文的下一步，及代码最后一行。首先我们使用了点方法调用了user的increment方法。我们首先找到user，然后查找里面的方法，此时处于全局执行上下文，然后执行方法，首先新建一个执行上下文，然后逐行执行函数体内代码，函数体内，我们使用了点方法访问了user1对象的score属性并自增1。为了执行这段代码，我们会在次执行上下文内寻找user1对象，发现并不存在，然后在调用栈的下一层执行上下文及全局执行上下文中寻找，找到了user1，并在user1内找到了score属性，此时我们给属性值自增1。函数执行完毕，执行上下文推出调用栈，线程回到全局执行上下文，发现并没有进程执行完毕，任务队列也没有需要执行的函数。代码执行完毕。</p>
<p>通过分析，我们把我们需要的数组和方法都组织到了一起，这样我们就可以更加容易的移动代码，而不用在移动时把他们拼凑在一起。我们只需要了解对象的组成结构就可以实现我们想要的功能。</p>
<p>我们有什么其他的技术来创建对象?</p>
<blockquote>
<p>What alternative techniques do we have for creating objects?</p>
</blockquote>
<p>使用点方法创建user2</p>
<blockquote>
<p>Creating user2 user 'dot notation'</p>
</blockquote>
<pre><code class="language-JavaScript"><div><span class="hljs-keyword">let</span> user2 = {}; <span class="hljs-comment">//create an empty object</span>
user2.name = <span class="hljs-string">"Tim"</span>; <span class="hljs-comment">//assign properties to that object</span>
user2.score = <span class="hljs-number">6</span>;
user2.increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
 user2.score++;
};
</div></code></pre>
<p>使用Object.create()方法创建user3</p>
<blockquote>
<p>Creating user3 using Object.create</p>
</blockquote>
<pre><code class="language-JavaScript"><div><span class="hljs-keyword">let</span> user3 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
user3.name = <span class="hljs-string">"Eva"</span>;
user3.score = <span class="hljs-number">9</span>;
user3.increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
 user3.score++;
};
</div></code></pre>
<p>在这里再重复我们的目标，我们想构建一个应用程序，我想要把我需要的数据和方法组织在其内部。我已经决定了把每个用户封装成一个对象来进行实现。</p>
<p>在上诉代码开始执行时，我们创建了一个空对象(实参null的传入并不影响空对象的创建)，然后我们通过点方法给对象增加属性和方法，并将一些基本类型值赋值给属性，将函数的引用赋值给方法。</p>
<p>在创建了三个对象后可见我们的代码越来越重复，我们打破了枯燥的原则
假设我们有数百万user需要创建!
我们要怎么做?</p>
<blockquote>
<p>Our code is getting repetitive, we're breaking our DRY principle
And suppose we have millions of users!
What could we do?</p>
</blockquote>
<p>此时我们发现了重复的代码，及代表了一段重复的执行过程，那么，我们可以把这段执行过程封装成函数。</p>
<h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">解决方案1：使用函数创建对象</h4>
<blockquote>
<p>Solution 1. Generate objects using a function</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userCreator</span>(<span class="hljs-params">name, score</span>) </span>{
  <span class="hljs-keyword">let</span> newUser = {}
  newUser.name = name
  newUser.score = score
  newUser.increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    newUser.score++
  }
  <span class="hljs-keyword">return</span> newUser
}

<span class="hljs-comment">//later</span>

<span class="hljs-keyword">let</span> user1 = userCreator(<span class="hljs-string">'Will'</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> user2 = userCreator(<span class="hljs-string">'Tim'</span>, <span class="hljs-number">5</span>)
user1.increment()
user2.increment()
</div></code></pre>
<p>在上述代码中，我们先是声明了一个函数，将函数保存到内存中并将指针赋值给函数名，然后进程跳转到倒数第四行，
我们声明了user1，并调用了userCreator函数，将”Will“和3作为两个参数传递给userCreator，将执行结果赋值给user1，在执行完毕前，我们会先将undefined赋值给user1。此时执行userCreator。首先创建一个新的执行上下文，并将其推入调用栈顶端，然后执行函数内代码。首先我们在执行上下文中声明了一个newUser变量，并在局部缓存区中创建了一个新的空对象，并将此空对象的指针赋值给newUser变量。然后我们通过点方法给空对象添加了对应的属性及方法，在赋值方法时，在userCreator的缓存区中新开辟了一块空间保存方法的代码。最后，函数执行完毕，返回变量，注意，此时返回的时新建对象的指针。此时将此执行上下文从调用栈中推出，回到全局执行上下文，将函数执行结果也就是返回的对象的引用赋值给user1，此时user1指向了函数执行时创建的对象，因为外部保持了对对象的引用，所以此对象并不会被垃圾回收机制回收。后面的过程与此及上面函数的执行过程类似，并不具体展开。</p>
<p>缺点：</p>
<blockquote>
<p>Problems:</p>
</blockquote>
<p>每次创建一个新的user，我们都会在计算机的内存中为所有数据和函数开辟空间。但是我们的函数功能明显是一样的。
有没有更好的方法？</p>
<blockquote>
<p>Each time we create a new user we make space in our computer's memory for all our data and functions. But our functions are just copies
Is there a better way?</p>
</blockquote>
<p>优点：</p>
<blockquote>
<p>Benefits:</p>
</blockquote>
<p>简单！
It's simple!</p>
<p>此时谈到了高级开发者面试时会提问什么问题，其中一个经典的问题就是如何设计new关键词，怎么实现类。</p>
<h4 id="%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0">代码练习</h4>
<pre><code class="language-javascript"><div><span class="hljs-comment">/****************************************************************
                  WORKING WITH OBJECT LITERALS
****************************************************************/</span>
<span class="hljs-comment">/*** CHALLENGE 1 of 1 ***/</span>
<span class="hljs-comment">/*
  Create a function that accepts two inputs (name and age) and returns an object. Let's call this function makePerson. This function will:
  create an empty object
  add a name property to the newly created object with its value being the 'name' argument passed into the function
  add an age property to the newly created object with its value being the 'age' argument passed into the function
  return the object
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePerson</span>(<span class="hljs-params">name, age</span>) </span>{
<span class="hljs-comment">// add code here</span>
  <span class="hljs-keyword">const</span> newPerson = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)
  newPerson.name = name
  newPerson.age = age
  <span class="hljs-keyword">return</span> newPerson
}
<span class="hljs-keyword">var</span> vicky = makePerson(<span class="hljs-string">'Vicky'</span>, <span class="hljs-number">24</span>);
<span class="hljs-comment">// /********* Uncomment these lines to test your work! *********/</span>
<span class="hljs-built_in">console</span>.log(vicky.name); <span class="hljs-comment">// -&gt; Logs 'Vicky'</span>
<span class="hljs-built_in">console</span>.log(vicky.age); <span class="hljs-comment">// -&gt; Logs 24</span>
<span class="hljs-comment">/****************************************************************
                       USING OBJECT.CREATE
****************************************************************/</span>
<span class="hljs-comment">/*
Challenge 3/3
Without editing the code you've already written, add an introduce method to the personStore object that logs "Hi, my name is [name]".
*/</span>
<span class="hljs-comment">/*** CHALLENGE 1 of 3 ***/</span>
<span class="hljs-comment">/*
  Inside personStore object, create a property greet where the value is a function that logs "hello".
*/</span>
<span class="hljs-keyword">var</span> personStore = {
<span class="hljs-comment">// add code here</span>
  greet: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>)
  }

};
<span class="hljs-comment">// /********* Uncomment this line to test your work! *********/</span>
personStore.greet(); <span class="hljs-comment">// -&gt; Logs 'hello'</span>
<span class="hljs-comment">/*** CHALLENGE 2 of 3 ***/</span>
<span class="hljs-comment">/*
  Create a function personFromPersonStore that takes as input a name and an age. When called, the function will create person objects using the Object.create method on the personStore object.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">personFromPersonStore</span>(<span class="hljs-params">name, age</span>) </span>{
<span class="hljs-comment">// add code here</span>
  <span class="hljs-keyword">const</span> newPerson = <span class="hljs-built_in">Object</span>.create(personStore)
  newPerson.name = name
  newPerson.age = age
  <span class="hljs-keyword">return</span> newPerson
}
<span class="hljs-keyword">var</span> sandra = personFromPersonStore(<span class="hljs-string">'Sandra'</span>, <span class="hljs-number">26</span>);
<span class="hljs-comment">// /********* Uncomment these lines to test your work! *********/</span>
<span class="hljs-built_in">console</span>.log(sandra.name); <span class="hljs-comment">// -&gt; Logs 'Sandra'</span>
<span class="hljs-built_in">console</span>.log(sandra.age); <span class="hljs-comment">//-&gt; Logs 26</span>
sandra.greet(); <span class="hljs-comment">//-&gt; Logs 'hello'</span>
<span class="hljs-comment">/*** CHALLENGE 3 of 3 ***/</span>
<span class="hljs-comment">/*
  Without editing the code you've already written, add an introduce method to the personStore object that logs "Hi, my name is [name]".
*/</span>
<span class="hljs-comment">// add code here</span>
personStore.introduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi, my name is <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>)
}
sandra.introduce(); <span class="hljs-comment">// -&gt; Logs 'Hi, my name is Sandra'</span>
<span class="hljs-comment">/****************************************************************
                    USING THE 'NEW' KEYWORD
****************************************************************/</span>
<span class="hljs-comment">/*** CHALLENGE 1 of 3 ***/</span>
<span class="hljs-comment">/*
  Create a function PersonConstructor that uses the this keyword to save a single property onto its scope called greet. greet should be a function that logs the string 'hello'.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonConstructor</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// add code here</span>
  <span class="hljs-keyword">this</span>.greet = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>)
  }
}
<span class="hljs-comment">// /********* Uncomment this line to test your work! *********/</span>
<span class="hljs-keyword">var</span> simon = <span class="hljs-keyword">new</span> PersonConstructor;
simon.greet(); <span class="hljs-comment">// -&gt; Logs 'hello'</span>
<span class="hljs-comment">/*** CHALLENGE 2 of 3 ***/</span>
<span class="hljs-comment">/*
  Create a function personFromConstructor that takes as input a name and an age. When called, the function will create person objects using the new keyword instead of the Object.create method.
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">personFromConstructor</span>(<span class="hljs-params">name, age</span>) </span>{
  <span class="hljs-comment">// add code here</span>
  <span class="hljs-keyword">const</span> newPerson = <span class="hljs-keyword">new</span> PersonConstructor
  newPerson.name = name
  newPerson.age = age
  <span class="hljs-keyword">return</span> newPerson
}
<span class="hljs-keyword">var</span> mike = personFromConstructor(<span class="hljs-string">'Mike'</span>, <span class="hljs-number">30</span>);
<span class="hljs-comment">// /********* Uncomment these lines to test your work! *********/</span>
<span class="hljs-built_in">console</span>.log(mike.name); <span class="hljs-comment">// -&gt; Logs 'Mike'</span>
<span class="hljs-built_in">console</span>.log(mike.age); <span class="hljs-comment">//-&gt; Logs 30</span>
mike.greet(); <span class="hljs-comment">//-&gt; Logs 'hello'</span>
<span class="hljs-comment">/*** CHALLENGE 3 of 3 ***/</span>
<span class="hljs-comment">/*
  Without editing the code you've already written, add an introduce method to the PersonConstructor function that logs "Hi, my name is [name]".
*/</span>
<span class="hljs-comment">// add code here</span>
PersonConstructor.prototype.introduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi, my name is <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>)
}
<span class="hljs-comment">// mike.introduce(); // -&gt; Logs 'Hi, my name is Mike'</span>
<span class="hljs-comment">/****************************************************************
                        USING ES6 CLASSES
****************************************************************/</span>
<span class="hljs-comment">/*** CHALLENGE 1 of 3 ***/</span>
<span class="hljs-comment">/*
  Create a class PersonClass. PersonClass should have a constructor that is passed an input of name and saves it to a property by the same name. PersonClass should also have a method called greet that logs the string 'hello'.
*/</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonClass</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-comment">// add code here</span>
    <span class="hljs-keyword">this</span>.name = name
  }
  <span class="hljs-comment">// add code here</span>
  greet(){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>)
  }
}
<span class="hljs-comment">// /********* Uncomment this line to test your work! *********/</span>
<span class="hljs-keyword">var</span> george = <span class="hljs-keyword">new</span> PersonClass;
george.greet(); <span class="hljs-comment">// -&gt; Logs 'hello'</span>

<span class="hljs-comment">/*** CHALLENGE 2 of 3 ***/</span>
<span class="hljs-comment">/*
  Create a class DeveloperClass that creates objects by extending the PersonClass class. In addition to having a name property and greet method, DeveloperClass should have an introduce method. When called, introduce should log the string 'Hello World, my name is [name]'.
*/</span>
<span class="hljs-comment">// add code here</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Developer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PersonClass</span></span>{
  <span class="hljs-keyword">constructor</span>(name){
    <span class="hljs-keyword">super</span>(name)
  }
  introduce(){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello World, my name is <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>)
  }
}
<span class="hljs-comment">// /********* Uncomment these lines to test your work! *********/</span>
<span class="hljs-comment">// var thai = new DeveloperClass('Thai', 32);</span>
<span class="hljs-comment">// console.log(thai.name); // -&gt; Logs 'Thai'</span>
<span class="hljs-comment">// thai.introduce(); //-&gt; Logs 'Hello World, my name is Thai'</span>
<span class="hljs-comment">/****************************************************************
                      EXTENSION: SUBCLASSING
****************************************************************/</span>
<span class="hljs-keyword">var</span> userFunctionStore = {
  <span class="hljs-attr">sayType</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"I am a "</span> + <span class="hljs-keyword">this</span>.type);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userFactory</span>(<span class="hljs-params">name, score</span>) </span>{
  <span class="hljs-keyword">let</span> user = <span class="hljs-built_in">Object</span>.create(userFunctionStore);
  user.type = <span class="hljs-string">"User"</span>;
  user.name = name;
  user.score = score;
  <span class="hljs-keyword">return</span> user;
}

<span class="hljs-keyword">var</span> adminFunctionStore <span class="hljs-comment">/* Put code here */</span> ;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adminFactory</span>(<span class="hljs-params">name, score</span>) </span>{
  <span class="hljs-comment">// Put code here</span>
}

<span class="hljs-comment">/* Put code here for a method called sharePublicMessage*/</span>

<span class="hljs-keyword">var</span> adminFromFactory = adminFactory(<span class="hljs-string">"Eva"</span>, <span class="hljs-number">5</span>);

<span class="hljs-comment">// /********* Uncomment these lines to test your work! *********/</span>
<span class="hljs-comment">// adminFromFactory.sayType() // -&gt; Logs "I am a Admin"</span>
<span class="hljs-comment">// adminFromFactory.sharePublicMessage() // -&gt; Logs "Welcome users!"</span>
</div></code></pre>
<h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882">解决方案2：</h4>
<blockquote>
<p>Solution 2:</p>
</blockquote>
<p>我们可以把increment这个方法保存在一个对象中并给使user与其进行引用，如果我们没有在user上找到这个方法，就到这个对象中寻找这个方法。
那么怎么才能实现这个引用？</p>
<blockquote>
<p>Store the increment function in just one object and have the interpreter, if it doesn't find the function on user1, look up to that object to check if it's there
How to make this link?</p>
</blockquote>
<h4 id="%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8javascript%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%89%B9%E6%80%A7-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882">充分利用JavaScript的原型特性-解决方案2</h4>
<blockquote>
<p>Using the prototypal nature of JavaScript - Solution 2 in full</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userCreator</span> (<span class="hljs-params">name, score</span>) </span>{
 <span class="hljs-keyword">let</span> newUser = <span class="hljs-built_in">Object</span>.create(userFunctionStore);
 newUser.name = name;
 newUser.score = score;
 <span class="hljs-keyword">return</span> newUser;
};
<span class="hljs-keyword">let</span> userFunctionStore = {
 <span class="hljs-attr">increment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">this</span>.score++;},
 <span class="hljs-attr">login</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"You're loggedin"</span>);}
};
<span class="hljs-keyword">let</span> user1 = userCreator(<span class="hljs-string">"Will"</span>, <span class="hljs-number">3</span>);
<span class="hljs-keyword">let</span> user2 = userCreator(<span class="hljs-string">"Tim"</span>, <span class="hljs-number">5</span>);
user1.increment();
</div></code></pre>
<p>js中的原型模式并不是实例”继承“了父级构造函数的原型，而是与父级构造函数指向了同一个对象，这个对象就是原型对象。</p>
<p>原型机制的问题是什么？</p>
<blockquote>
<p>Problem
没有问题！漂亮的答案！
No problems! It's beautiful
就是代码有点长
Maybe a little long-winded
<code>let newUser = Object.create(functionStore);</code>
<code>...</code>
<code>return newUser</code></p>
</blockquote>
<p>每次要写六个单词！</p>
<blockquote>
<p>Write this every single time - but it's 6 words!
超级复杂也不标准
Super sophisticated but not standard</p>
</blockquote>
<h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%883">解决方案3：</h4>
<blockquote>
<p>Solution 3</p>
</blockquote>
<p>介绍一个神奇的关键字new</p>
<blockquote>
<p>Introduce magic keyword new</p>
</blockquote>
<p><code>let user1 = new userCreator(&quot;Will&quot;, 3)</code></p>
<p>当我们调用userCreator(“Will”，3)而没有new关键字时会发生什么?</p>
<blockquote>
<p>What happens when we invoke userCreator(&quot;Will&quot;, 3) without the new keyword?</p>
</blockquote>
<p>就是解决方案2。</p>
<p>当我们使用new关键字调用构造函数时，我们自动完成了两件事</p>
<blockquote>
<p>When we call the constructor function with new in front we automate 2 things</p>
</blockquote>
<ol>
<li>创建了一个新的user对象（Create a new user object）</li>
<li>返回了这个对象（return the new user object）</li>
</ol>
<p>new关键字自动帮我们完成了许多程序化工作</p>
<blockquote>
<p>The new keyword automates a lot of our manual work</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userCreator</span>(<span class="hljs-params">name, score</span>) </span>{
<span class="hljs-comment">/*let newUser = Object.create(functionStore);*/</span>
<span class="hljs-comment">/*newUser*/</span> <span class="hljs-keyword">this</span>.name = name;
<span class="hljs-comment">/*newUser*/</span> <span class="hljs-keyword">this</span>.score = score;
<span class="hljs-comment">/*return newUser;*/</span>
};
<span class="hljs-comment">/*functionStore*/</span> userCreator.prototype <span class="hljs-comment">// {};</span>
<span class="hljs-comment">/*functionStore*/</span> userCreator.prototype.increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
 <span class="hljs-keyword">this</span>.score++;
}
<span class="hljs-keyword">let</span> user1 = <span class="hljs-keyword">new</span> userCreator(<span class="hljs-string">"Will"</span>, <span class="hljs-number">3</span>);
</div></code></pre>
<h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%883%E7%9A%84%E5%AE%8C%E6%95%B4%E7%AD%94%E6%A1%88">解决方案3的完整答案：</h4>
<blockquote>
<p>Complete Solution 3</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, score</span>)</span>{
 <span class="hljs-keyword">this</span>.name = name;
 <span class="hljs-keyword">this</span>.score = score;
}
User.prototype.increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
 <span class="hljs-keyword">this</span>.score++;
};
User.prototype.login = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"login"</span>);
};
<span class="hljs-keyword">let</span> user1 = <span class="hljs-keyword">new</span> User(“Eva”, <span class="hljs-number">9</span>)
user1.increment();
</div></code></pre>
<p>优点</p>
<blockquote>
<p>Benefits</p>
</blockquote>
<ul>
<li>写起来更快(Faster to write)</li>
<li>仍然是专业代码中的典型实践(Still typical practice in professional code)</li>
</ul>
<h5 id="99%E7%9A%84%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E4%B8%8D%E7%9F%A5%E9%81%93%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%9B%A0%E6%AD%A4%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95">99%的开发人员不知道它是如何工作的，因此无法通过面试</h5>
<blockquote>
<p>99% of developers have no idea how it works and therefore fail interviews</p>
</blockquote>
<h4 id="%E5%AF%B9%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3">对于构造函数、原型对象的理解</h4>
<p>在js高级程序设计中说，当我们使用new关键字时，会自动实行以下4个步骤</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（this就指向了这个新对象）</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<p>但是构造函数也是函数，在我们创建一个函数时，会自动给函数添加一个prototype属性，这个属性存储了一个指针，指向了一个对象。</p>
<p>在方案一中，我们发现如果要创建多个对象，但是对象的一部分属性和方法是一样的，那么我们就没有必要为每个对象都开辟一块内存空间保存这些公共的属性和方法。所以在解决方案二中，我们创建了一个对象，来存储我们公共的属性和防范，应为对象是引用类型，在赋值时传递的是指针而不是全部数据，所以我们把存储公共方法的对象的指针赋值给模板函数，这样，每个通过模板函数所创建的新对象，都添加了公共对象的指针，解决了这个问题。但是，这又引申出了一个新的问题，及流程的重复。为了减少重复性的工作，我们设计了一个新的关键字new，通过使用new操作符，我们很大幅度的简化了代码的数量。</p>
<p>这里我们要理解一下prototype原型对象。</p>
<p>出于跟上述解决方案同样的思路，我们没有必要把一些公共的方法在每个实例上都开辟一块内存空间进行存储，这样会极大地浪费我们的资源，那么解决的办法就是新建一个公共的对象，把公共对象的指针传递给实例，这样实例上想调用公共的方法就可以通过这个对象。</p>
<p>我们知道，函数也是一个对象，我们创建的每个函数都是Function对象的一个实例，所以基于以上的解决方案，我们每创建一个新的函数，就给函数添加一个属性，这个属性就指向一个对象，可以用来存储公共的属性和方法，这个属性名就是prototype，我们把这个与每个函数实例联系起来的对象叫做原型对象。</p>
<p>在解决方案二中，我们首先做的就是手动创建一个存储公共方法的新对象，然后把公共方法的对象手动的与函数中创建的对象进行绑定。那么，既然有了原型对象，就可以省略这一步骤。</p>
<p>就像之前所说，在我们使用new关键字后，会自动将函数的作用域赋给新对象。那么，函数的作用域应该包含了prototype属性，存储了指向原型对象的指针。所以在使用new关键字调用函数后，通过函数创建的新对象包含了函数的prototype属性存储的指针，但是在创建的新对象中这个属性名并不叫prototype。ECMA规定中管这个指针叫[[Prototype]]。</p>
<p>众所周知，ECMA只是规范的制定者，具体实现要看各家浏览器厂商。各大厂商在具体的实现中把这个指针命名为__proto__。通过双下划线的命名方式可以看出，这个属性是不期望被我们直接修改的，他只是一个指针，指向了构造函数的prototype属性，通过阅读mdn的文档也支出直接修改__proto__会产生许多问题，首先他只是浏览器厂商约定俗成的一个命名，并不规范所以肯能会被修改，其次还会产生性能为题，还有可能有命名冲突而导致新定义的属性或方法覆盖默认属性或方法的种种问题。</p>
<p>那么，现在我们知道，每通过使用new关键字创建一个新对象，新对象就会有一个属性，指向创建这个函数的prototype属性所指向的对象，也就是通过在函数与实例中各创建一个新属性，指向同一个对象的方法来实现方法及属性的公用。这个对象就是原型对象。函数的prototype属性指向这个对象，函数创建的对象，有一个属性（<strong>proto</strong>）也指向这个对象。</p>
<p>如上所述，不推荐直接在对象上更改__proto__来给这个公共对象添加属性及方法。所以我们一般通过函数的prototype来访问这个原型对象。同时，因为属性保存的只是一个指针，那么我们就不能修改这个指针，不然指向的就是其他对象了。</p>
<p>那么，我们有怎么知道这个原型对象是那个函数创建的呢？为了解决这个问题，回到函数创建时，我们在内存中开辟一块空间创建一个对象，同时给对象一个新属性，这个属性名规定为constructor，保存的时创建这个对象的函数的指针，然后再把这个对象的指针赋值给函数的prototype属性。</p>
<p>这样，因为函数创建的实例中保存着原型对象的指针，所以我们可以在函数创建的实例对象上访问constructor属性，在访问时，js会在实例对象的属性中查找，当查找不到时就会查找__proto__（这个属性名是被隐藏起来不希望我们修改的，但是我们可以访问，来实现方法属性的共享），这个属性保存的是一个指针，指向了与创建实例对象的函数的prototype属性所指向的同一个对象。在函数创建时，这个对象就自动创建了一个constructor，保存了只想这个函数的指针。所以访问实例对象的constructor属性时，经过这样一级级查找，就指向了创建对象的函数。</p>
<p>以上为了明确流程，减少思维负担，我把创建对象的函数就叫做函数，实际上，我们把这种用来创建对象的函数叫做构造函数。在js高级程序设计中强调，使用new关键字调用的函数才是构造函数，为了区分构造函数与普通函数，我们将构造函数的首字母名称大写。所以实际上，首字母大写是为了区分函数作用而约定俗成的，并不会改变函数的作用。在js高级程序设计中也强调，构造函数（用来创建实例对象）的函数直接使用括号调用，就与普通函数没有任何区别。通过解决方案2和解决方案3我们也可以看出：new关键字是为了简化我们创建对象流程而设计出的，如果不使用new关键字就直接调用简化后的函数，当然会导致许多问题。</p>
<p>顺便说一下，this指向当前作用域，我们使用new关键字调用构造函数时，会自动创建一个新对象，并将新对象的作用域绑定在this上，所以此时this可以理解为函数内创建的新对象，函数执行完之后，返回新对象的指针，将指针赋值为变量，此时变量就指向了通过构造函数创建的新对象，既新的实例对象。</p>
<p>理解原型对象，首先要理解函数也是对象，是Function的实例对象。所以函数可以也有属性和方法。每个函数创建时就会创建一个prototype属性，并且指向一个新创建的对象，这个新创建的对象有一个属性constructor，保存着这个函数的指针。所以我们可以手动的在函数内部把函数内新建的对象的一个属性赋值为函数prototype所保存的指针，也可以通过new关键字调用函数简化书写的流程，但是只是简化了书写的流程，过程还是一样的。</p>
<p>使用new关键字的代码大概等同如下</p>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserCreator</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span> = <span class="hljs-built_in">Object</span>.create(UserCreator.prototype) <span class="hljs-comment">// 创建一个新对象，并将this指向这个新对象，同时将新对象的__proto__指向函数的原型对象</span>
  <span class="hljs-keyword">this</span>.name = name <span class="hljs-comment">// 执行构造函数中的代码</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> <span class="hljs-comment">// 返回这个新对象</span>
}
</div></code></pre>
<p>在js中，我们定义一个‘类‘，需要定义一个构造函数来创建实例对象，在构造函数内部我们实现创建实例对象的私有属性方法，在通过构造函数的原型对象来给所有的实例对象添加公共的属性和方法。</p>
<p>显而易见，为了定义一个’类‘，我们需要最少两段代码，但是其他语言中只需要一段。那么有没有什么办法解决这个问题呢？</p>
<h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%884">解决方案4：</h4>
<blockquote>
<p>Solution 4</p>
</blockquote>
<p>我们直接在构造函数本身编写公共的属性和方法（而不是在构造函数的原型对象上）</p>
<blockquote>
<p>We’re writing our shared methods separately from our object ‘constructor’ itself (off in the User.prototype object)</p>
</blockquote>
<p>其他语言可以让我们把所有内容都写在一起，ES2015的新功能可以使我们也这样写</p>
<blockquote>
<p>Other languages let us do this all in one place. ES2015 lets us do so too</p>
</blockquote>
<h5 id="class%E8%AF%AD%E6%B3%95%E7%B3%96">class语法糖</h5>
<blockquote>
<p>The class 'syntactic sugar'</p>
</blockquote>
<pre><code class="language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
 <span class="hljs-keyword">constructor</span> (name, score){
 <span class="hljs-keyword">this</span>.name = name;
 <span class="hljs-keyword">this</span>.score = score;
 }
 increment (){
 <span class="hljs-keyword">this</span>.score++;
 }
 login (){
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"login"</span>);
 }
}
<span class="hljs-keyword">let</span> user1 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Eva"</span>, <span class="hljs-number">9</span>);
user1.increment();
</div></code></pre>
<p>在前面也提到，构造函数也是普通函数，即使不适用new关键字也可以调用，但显然构造函数的作用与普通函数并不相同，如果不适用new关键字，很可能会产生一些意想不到的效果，也就是bug。为了区分构造函数与普通函数，我们约定了将所有构造函数的首字母大写，但这只是一个人为约定，即使不这样做也能正常使用构造函数。</p>
<p>为了解决代码分离及上述问题，es2015中提出了class解决方案。</p>
<p>通过上面的代码可以看出，我们使用class关键字定义一个类，在后面书写类名，然后使用{}把代码段包裹起来形成一个局部作用域。然后constructor(){}函数就是以前我们书写的构造函数，在这之后我们直接在这个类的作用域中添加公共的属性和方法，也就是之前prototype上添加的属性及方法。</p>
<p>可以看到，使用class与使用构造函数一样需要时会用new调用，使用new调用并传入参数时，会调用class内的constructor方法，并将参数传递给该方法，此时与之前调用构造函数的运行机制一样。</p>
<p>使用class类，我们并不需要深入理解js底层实现机制（对目前来说），就像课程刚开始所讲，我们没必要做一个彻底的researcher，这并不能帮我们写出条理清晰，容易调试，容错率高的代码，或者说帮助不大，但是我们一定到搞清楚它的作用。</p>
<p>js的类实现机制是建立在原型及原型链上的，与其他语言可能并不一致，这是js语言的特性。</p>
<p>优点：</p>
<blockquote>
<p>Benefits:</p>
</blockquote>
<ul>
<li>成为一种新的标准
<blockquote>
<p>Emerging as a new standard</p>
</blockquote>
</li>
<li>与其他语言的风格感觉上更一致(例如Python)
<blockquote>
<p>Feels more like style of other languages (e.g. Python)</p>
</blockquote>
</li>
</ul>
<p>缺点：</p>
<blockquote>
<p>Problems</p>
</blockquote>
<ul>
<li>99%的开发人员不知道它是如何工作的，因此无法通过面试
<blockquote>
<p>99% of developers have no idea how it works and therefore fail interviews</p>
</blockquote>
</li>
</ul>
<p>class关键字定义类已经成为新的标准。</p>
<h2 id="%E5%90%8E%E8%AE%B0">后记</h2>
<p>以上，就是JavaScript: The Hard Part的学习笔记。在强调一遍，以上笔记是我用来总结思考所学内容的，来源于FrontEndMaster的付费课程。内容写的又乱又啰嗦，来源我也不是很确定是否可以转载。笔记只发表在我的个人博客，一般也不会有人来看。如果有人看到学到了，那么我很荣幸。如果看到觉得写得不好，有疏漏，不严谨，逻辑错误或根本性概念错误，那么真的欢迎批评指正。如果想转载，那么请先与我进行沟通，我不想要什么稿费，写得这么乱也不值几个钱，就像知道我的文章到底被谁用了，用在哪了。而且也会与FrontEndMaster那边沟通，看看是否可以转载。</p>

    </body>
    </html>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/Deep-JavaScript-Foundations/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/Deep-JavaScript-Foundations/" class="post-title-link" itemprop="url">Deep JavaScript Foundations</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 11:42:32 / 修改时间：11:43:41" itemprop="dateCreated datePublished" datetime="2019-04-29T11:42:32+08:00">2019-04-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍-Introduction"><a href="#介绍-Introduction" class="headerlink" title="介绍(Introduction)"></a>介绍(Introduction)</h2><p>我们为什么要深入了解JavaScript？我们现在有了babel，我们有typescript，问什么还要学习JavaScript？</p>
<p>我们为什么要深入了解JavaScript？我们现在有了babel，我们有typescript，问什么还要学习JavaScript？<br>无论是vue、react、angular，都是建立在js之上的，并不能脱离js的范畴。js有的特性他们也有，js会产生的问题他们也会产生。</p>
<p>我们作为开发人员是有着有倾向性的，假设好的心理模型，当bug出现时，我们有时会责怪编程语言，但这并不是js的问题。js的设计有着复杂的历史原因，显然，更主要的原因使我们没有阅读规范。</p>
<p><a href="https://www.ecma-international.org/ecma-262/9.0/index.html#Title" target="_blank" rel="noopener">ECMA规范</a></p>
<p>问题出现时，你首先要找到那么权威的说明在哪里，然后阅读他。</p>
<p>首先应该问自己，规范是这样规定的吗？我所做的是否符合规范？</p>
<p>如果你想要代码按照你所设想的执行，那么唯一的方式就是了解你的代码时怎样执行的。</p>
<p>这节课的根本目的是了解js的底层原理（算法设计）。这样才能使我们成为一个更加高效的开发人员。如果我们不知道我们所编写的代码的作用，并且只是单纯的希望不要有bug，显然是个不切实际的想法。</p>
<p>这里举了一个例子：你能说出一个职业，一个完全建立在猜测之上的职业吗？</p>
<p>如果我们不了解js的运行机制，代码是如何工作的，而只是看到代码跑起来了，产生了一些结果，那么，我们是不是一个合格的开发人员呢？有的时候，我们会建立一个符合我们预期的心理模型，并且希望js能按照我们的心理模型计算出我们预期的结果。但显然，我们所建立的心理模型很有可能与js的运行模型并不一致，那么，bug的产生也就理所当然了。就像你不能指望一个建筑设计师说我认为这个墙有用，这个房子很结实，让大家住进去吧，看看是不是这样。</p>
<p>一般我们发现问题时，我们一般会在MDN上搜索查看资料，但是MDN并不是规范。所以当MDN无法解释时，我们要阅读规范。我们通过不断阅读规范修正我们的心理模型使其与js工作的模型逐渐一致，这样，我们也就能越来越接近bug free了。</p>
<p>作者认为js可以分为三个核心部分，不论是VUE、ANGULAR、REACT甚至是JQuery，都是js，都建立在以下三个支柱之上：</p>
<ol>
<li>类型(type)<ul>
<li>原始类型(Primitive Type)</li>
<li>抽象操作(Abstract Operations)</li>
<li>强制转换(Coercion)</li>
<li>等于(Equality)</li>
<li>其他js语言(TypeScript,Flow,etc)</li>
</ul>
</li>
<li>作用域(Scope)<ul>
<li>作用域范围(Nested Scope)</li>
<li>变量提升(Hoisting)</li>
<li>闭包(Closure)</li>
<li>模块化(Modules)</li>
</ul>
</li>
<li>面相对象(Objects(Oriented))<ul>
<li>this</li>
<li>class{}</li>
<li>Prototypes</li>
<li>OO vs. OLOO</li>
</ul>
</li>
</ol>
<h2 id="类型-Type"><a href="#类型-Type" class="headerlink" title="类型(Type)"></a>类型(Type)</h2><h3 id="原始类型-Primitive-Types"><a href="#原始类型-Primitive-Types" class="headerlink" title="原始类型(Primitive Types)"></a>原始类型(Primitive Types)</h3><p>在js中，一切都是对象。</p>
<blockquote>
<p>“In JavaScript, everything is an object.”</p>
</blockquote>
<p>这是不正确的说法。</p>
<p>这个说法的来源是js中的绝大部分值可以表现为对象，但他们并不是对象。</p>
<p>也许有许多人都是这样认为的，但是规范上并不是这样。</p>
<p>规范是这样说的：<br>ECMAScript语言类型对应于由使用ECMAScript语言的ECMAScript程序员直接操作的值。ECMAScript语言类型有Undefined、Null、Boolean、String、Symbol、Number和Object。ECMAScript语言值是以ECMAScript语言类型为特征的值。</p>
<blockquote>
<p>An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Symbol, Number, and Object. An ECMAScript language value is a value that is characterized by an ECMAScript language type.</p>
</blockquote>
<p>就像规范所规定一样，js中有七种原始类型</p>
<ol>
<li>undefined</li>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>symbol</li>
</ol>
<p>注意，在这里作者并没有将null放在原始类型中，作者认为null来源于js的历史错误之一，并在后面会解释他这样认为的原因。</p>
<p>在这里作者还举出了一些平时经常被我们误认为原始类型的“类型”</p>
<ul>
<li>undeclared(未声明的变量)</li>
<li>null(同上所述，被认为是历史错误)</li>
<li>function(不是原始类型，只是Object的“子对象”)</li>
<li>array(不是原始类型，只是Object的“子对象”)</li>
<li>bigint(即将加入到最新的规范中，已经在chrome v8引擎中实现。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="noopener">MDN文档</a>)</li>
</ul>
<p>所以除了Object、function以及array，其他并不是“对象”。</p>
<p>在js中，变量没有类型，但是变量的值有类型。</p>
<blockquote>
<p>In JavaScript, variables don’t have types, values do.</p>
</blockquote>
<h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><blockquote>
<p>typeof操作符返回一个字符串，表示未经计算的操作数的类型。</p>
</blockquote>
<p>首先来看一段代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v</span><br><span class="line"><span class="keyword">typeof</span> v    <span class="comment">// "undefined"</span></span><br><span class="line">v = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">typeof</span> v    <span class="comment">// "string"</span></span><br><span class="line">v = <span class="number">2</span></span><br><span class="line"><span class="keyword">typeof</span> v    <span class="comment">// "number"</span></span><br><span class="line">v = <span class="literal">true</span></span><br><span class="line"><span class="keyword">typeof</span> v    <span class="comment">// "boolean"</span></span><br><span class="line">v = &#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> v    <span class="comment">// "object"</span></span><br><span class="line">v = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">typeof</span> v    <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>
<p>当我们使用typeof后加上变量v时，我们判断的不是变量v的类型，而是变量v当前值得类型。通过代码我们可以发现这一点，在我们给变量v重新赋值之后，typeof返回的结果也做出了变化，返回了我们所赋给变量v的值得类型的字符串。</p>
<p>在第二行，我们看到返回了一个undefined，这说明在我们声明一个变量时，会自动给变量赋值为undefined。我们理解undefined一般理解为变量还没有赋值，但我们可以理解为当前还没有值但可能会有。</p>
<p>这里注意，typeof操作符返回的是字符串，所以比较时应该也用字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> doesnotExist   <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="literal">null</span></span><br><span class="line"><span class="keyword">typeof</span> v              <span class="comment">// "object" 注意，这里返回的预期是null，但是是object</span></span><br><span class="line"></span><br><span class="line">v = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> v              <span class="comment">// “function” 这里很奇怪，因为预期返回object</span></span><br><span class="line"></span><br><span class="line">v = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">typeof</span> v              <span class="comment">// "object" 因为数组也是object类型，所以返回object</span></span><br></pre></td></tr></table></figure>
<p>作者在这里认为使用typeof判断null时返回”object”是因为ES1中的历史问题。当然，typeof判断函数时返回”function”可以帮助我们判断是不是函数，但是在判断数组时又失去了作用（现在使用Array.isArray()判断）。作者认为这也是历史原因，并且我们无法进行修复，因为这会导致许多建立与此的代码发生错误。</p>
<h3 id="Bigint"><a href="#Bigint" class="headerlink" title="Bigint"></a>Bigint</h3><p>bigint是规范中即将可能推出的新的原始类型,给一个变量赋值为42n时，代表了不仅仅是数字42，还代表了数字可以无限大，直到填满内存空间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 即将推出</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="number">42</span>n  <span class="comment">//or BigInt(42)</span></span><br><span class="line"><span class="keyword">typeof</span> v     <span class="comment">// "bigint"</span></span><br></pre></td></tr></table></figure>
<h3 id="Kind-of-Emptiness"><a href="#Kind-of-Emptiness" class="headerlink" title="Kind of Emptiness"></a>Kind of Emptiness</h3><p>这里对未声明变量和变量的undefined进行了说明。在js中，变量未声明和变量声明后未赋值完全是两个概念。这也是因为历史原因，可能是不希望因为没有声明变量而阻断程序的运行。</p>
<p>在这里，为了解决这个问题，es6提出了uninitialized(也成为TDZ-the temporal dead zone-暂时性死区)。这个想法的初衷在于变量，例如块级作用域变量，不会进行初始化。一个未声明的变量不会被自动赋值为undefined。在一个未被初始化的作用域中，会被报错。</p>
<h3 id="NaN-amp-isNaN"><a href="#NaN-amp-isNaN" class="headerlink" title="NaN &amp; isNaN"></a>NaN &amp; isNaN</h3><p>NaN是not a number的缩写，顾名思义，应该代表了变量的值不是number类型。但实际上NaN代表了无效数字的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAge = <span class="built_in">Number</span>(<span class="string">'0o46'</span>)        <span class="comment">// 38</span></span><br><span class="line"><span class="keyword">var</span> myNextAge = <span class="built_in">Number</span>(<span class="string">'39'</span>)      <span class="comment">// 39</span></span><br><span class="line"><span class="keyword">var</span> myCatsAge = <span class="built_in">Number</span>(<span class="string">'n/a'</span>)     <span class="comment">// NaN</span></span><br><span class="line">myAge - <span class="string">"my son's age"</span>            <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line">myCatsAge === myCatsAge           <span class="comment">// false  注意此处!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(myAge)                      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(myCatsAge)                  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"my son's age"</span>)             <span class="comment">// true   注意此处！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isNaN(myCatsAge)           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"my son's age"</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在数学中，0是一个有意义的数字，但是当我们想给一个数字类型变量赋值，表示这不在是一个数字该怎么办（作者举了猫的例子，因为作者不再养猫，所以作者的猫的年龄不是数字）。在js中，减号表示数学相减运算，js会将符号两边的变量的值强制转换为数字，所以数字减去字符串，得到的是NaN。</p>
<p>在一般情况下，我们不希望使用==，以防止js自动为我们进行类型转换。而是使用===来判断两个变量代表的值是否相等。但是在上述代码中，因为ieee规定NaN不等于NaN自身，所以使用===判断时，即使两边变量代表的值是一样的，还是不相等。所以除了ieee规定的NaN不等于NaN，其他变量都全等于自身。</p>
<p>为了分清楚变量的值是否是NaN，我们有了isNaN运算符。同时要注意的是，在上述代码中我们给isNaN传入了一个字符串，理论上应该返回false，但是在isNaN进行判断前js认为我们传入的是一个数字，会进行强制的类型转换，所以最后判断为true。为了避免这种现象，我们有设计出了Number.isNaN()来避免强制类型转换，所以在最后一行我们传入string类型的值，得到了false。</p>
<p>NaN：无效的数字</p>
<blockquote>
<p>NaN: Invalid Number</p>
</blockquote>
<h3 id="负零-Negative-Zero"><a href="#负零-Negative-Zero" class="headerlink" title="负零(Negative Zero)"></a>负零(Negative Zero)</h3><p>如果你问一个数学家，数学家会告诉你不存在负零，但是在js中是存在的，是存在于ieee 754规范中的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trendRate = <span class="number">-0</span></span><br><span class="line">trendRate === <span class="number">-0</span>            <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">trendRate.toString()        <span class="comment">// “0”   注意！</span></span><br><span class="line">trendRate === <span class="number">0</span>             <span class="comment">// true  注意！</span></span><br><span class="line">trendRate &lt; <span class="number">0</span>               <span class="comment">// false</span></span><br><span class="line">trendRate &gt; <span class="number">0</span>               <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(trendRate, <span class="number">-0</span>)    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(trendRate, <span class="number">0</span>)     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当我们把-0转化为字符串是，得到的是”0”，并且-0全等于（===）0。在这里作者也介绍了Object.is(),并将其比喻为====。顺便，Object.is()也可以用来进行比较NaN。</p>
<p>在这里作者也举例了-0的应用实例：如果设计了一款游戏，想要让速度代表汽车行进方向，那么当汽车停止时，我们就需要0和-0来判断汽车停止时的行进方向。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-3</span>)       <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">3</span>)        <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-0</span>)       <span class="comment">// -0   注意这里！</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>)        <span class="comment">// 0   注意这里！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "fix" Math.sign(...)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sign</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v !== <span class="number">0</span> ? <span class="built_in">Math</span>.sign(v) : <span class="built_in">Object</span>.is(v, <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sign(<span class="number">-3</span>)            <span class="comment">// -1</span></span><br><span class="line">sign(<span class="number">3</span>)             <span class="comment">// 1</span></span><br><span class="line">sign(<span class="number">-0</span>)            <span class="comment">// -1</span></span><br><span class="line">sign(<span class="number">0</span>)             <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="基本对象-Fundamental-Objects"><a href="#基本对象-Fundamental-Objects" class="headerlink" title="基本对象(Fundamental Objects)"></a>基本对象(Fundamental Objects)</h3><p>基本对象(Fundamental Objects)也称作内置对象(Built-In Objects)或者原生功能(Native Functions)。</p>
<p>在一下功能中，作者建议一定要使用new关键字调用(可以看出，首字母均为大写，说明是一种构造函数)</p>
<ul>
<li>Object()</li>
<li>Array()</li>
<li>Function()</li>
<li>Date()</li>
<li>RegExp()</li>
<li>Error()</li>
</ul>
<p>一下是作者不建议使用new关键字的</p>
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
</ul>
<h2 id="强制类型转换-Coercion"><a href="#强制类型转换-Coercion" class="headerlink" title="强制类型转换(Coercion)"></a>强制类型转换(Coercion)</h2><h3 id="抽象运算-Abstract-Operations"><a href="#抽象运算-Abstract-Operations" class="headerlink" title="抽象运算(Abstract Operations)"></a>抽象运算(Abstract Operations)</h3><blockquote>
<p>这些操作不是ECMAScript语言的一部分;在这里定义它们仅仅是为了帮助ECMAScript语言的语义规范。在整个规范中定义了其他更专门化的抽象操作。<br>These operations are not a part of the ECMAScript language; they are defined here to solely to aid the specification of the semantics of the ECMAScript language. Other, more specialized abstract operations are defined throughout this specification.</p>
</blockquote>
<p>这段讲的就是js中的一些列抽象操作，主要就是类型转换(Type Conversion)，我们一般把js的类型转换成为强制类型转换(Coercion)，或则隐式类型转换，目前看来，这几个术语表达的应该是同一件事，及js自动进行的一系列操作。</p>
<h4 id="ToPrimitive-hint-7-1-1"><a href="#ToPrimitive-hint-7-1-1" class="headerlink" title="ToPrimitive(hint) (7.1.1)"></a>ToPrimitive(hint) (7.1.1)</h4><blockquote>
<p>抽象操作ToPrimitive接受输入参数和可选参数PreferredType。抽象操作ToPrimitive将其输入参数转换为非Object类型。如果一个对象能够转换为多个基本类型，它可以使用可选提示PreferredType来支持该类型。<br>The abstract operation ToPrimitive takes an input argument and an optional argument PreferredType. The abstract operation ToPrimitive converts its input argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint PreferredType to favour that type.</p>
</blockquote>
<p>注意，<code>ToPrimitive</code>并不是js引擎所实现的一个功能，我们并不能在js中进行调用。这是一个概念性的操作，是一个功能需求的描述，是一个算法描述。这个需求要求了在js中要把一些不是原始类型的值转化为原始类型。</p>
<p><code>ToPrimitive</code>描述了如果你有一个非原始类型的值，你希望他转化成哪种基本类型。就像进行数学运算，会自动调用<code>ToPrimitive</code>将运算符两边的值转化为数字类型，但是注意，这并不能保证这个值一定能转化为<code>Nubmer</code>类型。</p>
<p>在js的算法设计中，递归是很主要的一部分。例如调用<code>ToPrimitive</code>后返回的仍不是一个属于原始类型的值，就会不断调用<code>ToPrimitive</code>知道返回一个可以操作的值。</p>
<p>基本上<code>ToPrimitive</code>会传入两种参数<code>number</code>和<code>string</code>，如果<code>number</code>，首先会调用<code>valueOf()</code>方法进行转换，如果转换失败，会调用<code>toString()</code>方法。传入<code>string</code>时正好相反，会首先调用<code>toString()</code>，然后调用<code>valueOf()</code>方法。</p>
<h4 id="ToString-7-1-12"><a href="#ToString-7-1-12" class="headerlink" title="ToString (7.1.12)"></a>ToString (7.1.12)</h4><blockquote>
<p>抽象操作ToString:根据参数将参数转换为String类型的值<br>The abstract operation ToString converts argument to a value of type String</p>
</blockquote>
<p><code>null      &quot;null&quot;</code><br><code>undefined &quot;undefined&quot;</code><br><code>true      &quot;true&quot;</code><br><code>false     &quot;false&quot;</code><br><code>3.14159   &quot;3.14159&quot;</code><br><code>0         &quot;0&quot;</code><br><code>-0        &quot;0&quot; // 注意，这里返回的与预期有一些出入</code></p>
<p>以上是对一些值调用<code>toString()</code>方法后的返回结果，在大多数情况下，返回的结果与我们的预期也相符</p>
<p>当接收数组作为参数时，会有如下返回结果</p>
<p><code>[]               &quot;&quot;</code><br><code>[1,2,3]          &quot;1,2,3&quot;</code><br><code>[null,undefined] &quot;,&quot;</code><br><code>[[[],[],[]],[]]  &quot;,,,&quot;</code><br><code>[,,,,]           &quot;,,,&quot;</code></p>
<p>可以发现，<code>toString()</code>方法传入数组时，会将数组的[]去掉并返回值，当值为null或undefined时，会保留位置但是并没有值，所以在传入数组时返回的结果与我们的预期很不相符。</p>
<p>当接收对象作为参数时，有如下表现：</p>
<p><code>{}                             &quot;[object Object]&quot;</code><br><code>{a:2}                          &quot;[object Object]&quot;</code><br><code>{ toString(){ return &quot;X&quot;; } }  &quot;X&quot;</code></p>
<h4 id="ToNumber-7-1-3"><a href="#ToNumber-7-1-3" class="headerlink" title="ToNumber (7.1.3)"></a>ToNumber (7.1.3)</h4><blockquote>
<p>抽象操作ToNumber将参数转换为类型为Number的值<br>The abstract operation ToNumber converts argument to a value of type Number</p>
</blockquote>
<p>上面也提到过，当我们想做一件事，这件事需要操作数字时，就会自动调用<code>ToNumber()</code>将值转为Number类型。</p>
<p><code>&quot;&quot;         0</code><br><code>&quot;0&quot;        0</code><br><code>&quot;-0&quot;      -0</code><br><code>&quot;009&quot;      9</code><br><code>&quot;3.14159&quot;  3.14159</code><br><code>&quot;0.&quot;       0</code><br><code>&quot;.0&quot;       0</code><br><code>&quot;.&quot;        NaN</code><br><code>&quot;0xaf&quot;     175</code></p>
<p>通过上面的调用结果，比较值得注意的就是空字符会转为0。</p>
<p><code>false      0</code><br><code>true       1</code><br><code>null       0</code><br><code>undefined  NaN</code></p>
<p>上面比较值得注意的是null会转化为0，而不是像undefined一样转化为NaN。</p>
<p>在传入数组时，会有以下表现（会先将数组调用toString，所以空数组返回0）</p>
<p><code>[&quot;&quot;]          0</code><br><code>[&quot;0&quot;]         0</code><br><code>[&quot;-0&quot;]       -0</code><br><code>[null]        0</code><br><code>[undefined]   0</code><br><code>[1,2,3]       NaN</code><br><code>[[[[]]]]      0</code></p>
<p>传入对象时，有如下表现：</p>
<p><code>{ .. }                        NaN</code><br><code>{ valueOf() { return 3; } }   3</code></p>
<h4 id="ToBoolean-7-1-2"><a href="#ToBoolean-7-1-2" class="headerlink" title="ToBoolean (7.1.2)"></a>ToBoolean (7.1.2)</h4><blockquote>
<p>抽象操作ToBoolean将参数转换为Boolean类型的值<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-toboolean" target="_blank" rel="noopener">7.1.2ToBoolean ( argument )</a><br>The abstract operation ToBoolean converts argument to a value of type Boolean</p>
</blockquote>
<p><code>Falsy             Truthy</code><br><code>“”                “foo”</code><br><code>0,-0              23</code><br><code>null              { a:1 }</code><br><code>NaN               [1,3]</code><br><code>false             true</code><br><code>undefined         function(){..}  ...</code></p>
<p>一般我们只需记住Falsy部分即可，其他不属于Falsy的均转换为true。当我们仅仅只调用<code>ToBoolean</code>时并没与其他强制转换发生，所以将一个空数组输入会返回true。</p>
<h4 id="强制类型转换Coercion"><a href="#强制类型转换Coercion" class="headerlink" title="强制类型转换Coercion"></a>强制类型转换Coercion</h4><p>在我们学习js时，我们都知道js是一门动态类型语言，会进行类型转换，我们也在极力避免类型转换的发生</p>
<blockquote>
<p>You claim to avoid coercion because it’s evil, but…</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numStudents = <span class="number">16</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`there are <span class="subst">$&#123;numStudents&#125;</span> students`</span>) <span class="comment">// there are 16 students</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们就进行了类型转换。在这方面，类型转换是的输出结果符合了我们的心理预期。在这里我们使用了类型转换，我们就要了解类型转换帮我们做了什么。</p>
<p>这里还举例了许多其他案例，不一一叙述。</p>
<h4 id="Boxing"><a href="#Boxing" class="headerlink" title="Boxing"></a>Boxing</h4><p>我们知道我们可以通过.value.length访问一个原始类型值得值得长度。这是因为原始类型值是对象吗？根据规范可知并不是，这是应为在我们通过点方法访问一个非对象的属性时，js使用类型转换帮我们转换为了对象，以防报错阻止程序运行。</p>
<h2 id="Philosophy-of-Coercion"><a href="#Philosophy-of-Coercion" class="headerlink" title="Philosophy of Coercion"></a>Philosophy of Coercion</h2><h3 id="Intentional-Coercion"><a href="#Intentional-Coercion" class="headerlink" title="Intentional Coercion"></a>Intentional Coercion</h3><p>您不需要通过避免强制转换来处理这些类型转换的特殊情况。</p>
<blockquote>
<p>You don’t deal with these type conversion corner cases by avoiding coercions.</p>
</blockquote>
<p>相反，您必须采用一种使值类型简单明了的编码风格。</p>
<blockquote>
<p>Instead, you have to adopt a coding style that makes value types plain and obvious.</p>
</blockquote>
<p>一个高质量的JS程序应该积极拥抱强制类型转换，确保每个操作涉及的类型都是清晰的。因此，边缘案例是处于安全管理下的。</p>
<blockquote>
<p>A quality JS program embraces coercions, making sure the types involved in every operation are clear. Thus, corner cases are safely managed.</p>
</blockquote>
<p>JavaScript的动态类型不是缺点，而是它的一个优点</p>
<blockquote>
<p>JavaScript’s dynamic typing is not a weakness, it’s one of its strong qualities</p>
</blockquote>
<h3 id="Culture-of-Learning"><a href="#Culture-of-Learning" class="headerlink" title="Culture of Learning"></a>Culture of Learning</h3><p>这里作者对于初级开发者的学习也提出了一些建议。初级开发者会在一些基本问题上犯错误，这很正常。如果一个初级开发者碰到了边缘案例没有发现错误，应该与其讨论边缘案例所发生的情况。一个比较懒惰的观点就是指望团队的每一个人都一直学习，一直进步。但这也是不现实的，我们首先应该确保自身在不断学习进步，更加了解我们使用的工具。代码是一种交流方式。</p>
<h3 id="Implicit-Coercion"><a href="#Implicit-Coercion" class="headerlink" title="Implicit Coercion"></a>Implicit Coercion</h3><p>隐式类型转换不是魔术，也不是一件坏事，是一个抽象的方法。</p>
<p>我们会隐藏不必要的细节，避免读者注意力的分散，并使读者更清楚所做的事。</p>
<blockquote>
<p>Hiding unnecessary details, re-focusing the reader and increasing clarity</p>
</blockquote>
<p>js更好入门的原因之一就是不会强迫开发人员处理各种复杂的类型转换。</p>
<p>这里作者认为问题的关键还是对开发人员的思维负担到底是增加了还是减少了。</p>
<blockquote>
<p>Is showing the reader the extra type details helpful or distracting?</p>
</blockquote>
<h3 id="Understanding-Feature"><a href="#Understanding-Feature" class="headerlink" title="Understanding Feature"></a>Understanding Feature</h3><p>以下是道格拉斯克劳柯福德在js语言精粹中的观点：</p>
<blockquote>
<p>“If a feature is sometimes <strong>useful</strong> and sometimes <strong>dangerous</strong> and if there is a better option then always use the <strong>better</strong> option.”<br>– “The Good Parts”, Crockford</p>
</blockquote>
<p>在这里，作者提出了他的观点：</p>
<blockquote>
<p>Useful: when the reader is focused on what’s important<br>Dangerous: when the reader can’t tell what will happen<br>Better: when the reader understands the code<br>作者还认为：<br>故意避免使用可以提高代码可读性的特性是不负责任的<br>It is irresponsible to knowingly avoid usage of a feature that can improve code readability</p>
</blockquote>
<h2 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a>Equality</h2><h3 id="Double-amp-Triple-Equals"><a href="#Double-amp-Triple-Equals" class="headerlink" title="Double &amp; Triple Equals"></a>Double &amp; Triple Equals</h3><p>一般我们把==成为松散比较或者不严格比较，===成为严格比较。</p>
<blockquote>
<p>== checks value (loose)<br>=== checks value and type (strict)</p>
</blockquote>
<p>但事实上可能并不如此。</p>
<blockquote>
<p>If you’re trying to understand your code, it’s critical you learn to think like JS</p>
</blockquote>
<p>这里作者深入的讲述了==和===所表现出的一些行为及其导致的问题。</p>
<p>这是关于==及===的规范链接<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-abstract-equality-comparison" target="_blank" rel="noopener">ECMA</a>。</p>
<p>以下是规范中关于==部分：</p>
<blockquote>
<p>Abstract Equality Comparison<br>The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:<br>1.If Type(x) is the same as Type(y), then<br>1.1.Return the result of performing Strict Equality Comparison x === y.<br>2.If x is null and y is undefined, return true.<br>3.If x is undefined and y is null, return true.<br>4.If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y).<br>5.If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y.<br>6.If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y.<br>7.If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y).<br>8.If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).<br>9.If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.<br>Return false.</p>
</blockquote>
<p>以下是关于===部分：</p>
<blockquote>
<p>Strict Equality Comparison<br>The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows:<br>1.If Type(x) is different from Type(y), return false.<br>2.If Type(x) is Number, then<br>2.1.If x is NaN, return false.<br>2.2.If y is NaN, return false.<br>2.3.If x is the same Number value as y, return true.<br>2.4.If x is +0 and y is -0, return true.<br>2.5.If x is -0 and y is +0, return true.<br>2.6.Return false.<br>3.Return SameValueNonNumber(x, y).</p>
</blockquote>
<p>关键注意关于==的第一条，第一条说明了即使使用==号，也会先进行===比较，如果类型一致，直接返回===比较后的结果。之前说过，规范是js代码实现的算法描述，在实现==的算法描述第一步，就进行了类型比较。所以==和===都进行了类型比较，只不过==要在===比较失败时进行一些其他情况的判定并返回比较结果。所以当两个值得类型相同时，==与===没有任何区别。</p>
<p>所以真正重要的是作为开发人员要清楚地知道自己要比较的两个值是什么类型。</p>
<p>所以==与===的区别就在于我们是否允许两个比较值进行类型转换。因为===是短路操作，如果类型不同直接返回false。但是==允许在类型不同时进行类型转换后递归比较。</p>
<p>在这里注意，比较两个对象时，应为变量保存的是对象的引用地址，所以即使两个对象的结构及字面量一致，返回的也是false。</p>
<blockquote>
<p>== allows coercion (types different)<br>=== disallows coercion (types same)</p>
</blockquote>
<h3 id="Coercive-Equality"><a href="#Coercive-Equality" class="headerlink" title="Coercive Equality"></a>Coercive Equality</h3><p>和其他操作一样，强制类型转换是否有助于等于比较?</p>
<blockquote>
<p>Like every other operation, is coercion helpful in an equality comparison or not?</p>
</blockquote>
<p>你可以问自己，如果我很明确要比较的数据类型，强制类型转换是否对我有帮助？</p>
<p>使用==并不意味着坏的，而是意味着我是否允许比较的数据进行类型转换。如果当前情况下进行类型转换对我是否更有帮助，是更安全还是更危险。如果你不确定要比较的数据的类型，那么想办法在其他部分是数据类型更加明确是不是更好的选择？</p>
<p>使用==的优势之一可以参考规范的第2条及第3条，既免于我们判断数据类型为空时，到底是<code>===null</code>还是<code>===undefined</code>。</p>
<p>这里作者也提出了lint工具只是一个参考，lint工具通过预先制定好的规则来判断代码是否符合规范，但是规范只是参考，并不能保证代码就一定不出错。关于代码规范，每个人也有不同的看法。我们应该让团队自己决定团队的代码规范。</p>
<h3 id="Double-Equals-Algorithm"><a href="#Double-Equals-Algorithm" class="headerlink" title="Double Equals Algorithm"></a>Double Equals Algorithm</h3><p>可以从上面的规范看出，==号的算法设计倾向于把两个值转化为数字类型进行比较，当比较值不是原始类型值（数组等），会转化为原始类型值进行比较。</p>
<h3 id="Double-Equals-Summary"><a href="#Double-Equals-Summary" class="headerlink" title="Double Equals Summary"></a>Double Equals Summary</h3><blockquote>
<p>If the types are the same: ===<br>If null or undefined: equal<br>If non-primitives: ToPrimitive<br>Prefer: ToNumber</p>
</blockquote>
<p>==的算法摘要：如果类型一致就是用===判断，如果是null或者undefined就返回true，如果不是原始类型就转化为原始类型进行比较，最后比较时倾向于把值转化为number类型进行比较</p>
<h3 id="Corner-Cases-Summary"><a href="#Corner-Cases-Summary" class="headerlink" title="Corner Cases: Summary"></a>Corner Cases: Summary</h3><p>我们应在使用==判断时避开边缘案例的几个主要场景</p>
<ol>
<li>== with 0 or “” (or even “ “)</li>
<li>== with non-primitives</li>
<li>== true or == false : allow ToBoolean or use ===</li>
</ol>
<p>不要使用==比较0，空字符串，或包含空格的空字符串。<br>不要用==比较非原始类型的值。<br>不要判断一个值是否==true或者==false，如果不得不比较，使用===。</p>
<h3 id="The-case-for-preferring"><a href="#The-case-for-preferring" class="headerlink" title="The case for preferring =="></a>The case for preferring ==</h3><p>了解类型总是比不了解它们好</p>
<blockquote>
<p>Knowing types is always better than not knowing them<br>静态类型不是了解类型的唯一(甚至不一定是最好的)方法<br>Static Types is not the only (or even necessarily best) way to know your types<br>如果你不了解你要比较的数据类型，不要使用==<br>== is not about comparisons with unknown types<br>==是关于与已知类型的比较，在类型转换非常有帮助的情况下可以选择<br>== is about comparisons with known type(s), optionally where conversions are helpful</p>
</blockquote>
<h2 id="Static-Typing"><a href="#Static-Typing" class="headerlink" title="Static Typing"></a>Static Typing</h2><h3 id="TypeScript-amp-Flow"><a href="#TypeScript-amp-Flow" class="headerlink" title="TypeScript &amp; Flow"></a>TypeScript &amp; Flow</h3><p>优点：</p>
<blockquote>
<p>Benefits:</p>
</blockquote>
<ol>
<li>捕获类型相关的错误<blockquote>
<p>Catch type-related mistakes</p>
</blockquote>
</li>
<li>交流类型的意图（直接在代码上表示出类型而不是注释，使得代码更加易读）<blockquote>
<p>Communicate type intent</p>
</blockquote>
</li>
<li>编辑器的提示支持<blockquote>
<p>Provide IDE feedback</p>
</blockquote>
</li>
</ol>
<p>警告：</p>
<blockquote>
<p>Caveats:</p>
</blockquote>
<ol>
<li>推断是最好的猜测，而不是保证<blockquote>
<p>Inferencing is best-guess, not a guarantee</p>
</blockquote>
</li>
<li>注释是可选的<blockquote>
<p>Annotations are optional</p>
</blockquote>
</li>
<li>应用程序中任何没有类型化的部分都会带来不确定性<blockquote>
<p>Any part of the application that isn’t typed introduces uncertainty</p>
</blockquote>
</li>
</ol>
<h3 id="Inferencing"><a href="#Inferencing" class="headerlink" title="Inferencing"></a>Inferencing</h3><p>有些人认为动态类型的最大的问题之一是会意外的导致变量赋值为我们预期之外的类型，对于持有这个观点的人来说，静态类型检查是一个很好的解决方案。</p>
<h3 id="Custom-Types-amp-Signatures"><a href="#Custom-Types-amp-Signatures" class="headerlink" title="Custom Types &amp; Signatures"></a>Custom Types &amp; Signatures</h3><p>函数的参数类似一个变量，如果你在ts中说我希望只传递数字，也就是再说我希望该变量只保存数字。</p>
<h3 id="Validating-Operand-Types"><a href="#Validating-Operand-Types" class="headerlink" title="Validating Operand Types"></a>Validating Operand Types</h3><p>作者认为在typescript中有一件事被低估了，除了静态类型检查，它还可以告诉我们有些操作是无效的，例如你无法用一个数字减去一个字符串，也就是说不要使用强制类型转换，这在有时对我们很有帮助。</p>
<h3 id="TypeScript-vs-Flow"><a href="#TypeScript-vs-Flow" class="headerlink" title="TypeScript vs. Flow"></a>TypeScript vs. Flow</h3><p>嗯。。。似乎flow已经凉了。。。vue的作者已经全面转向了TypeScript，所以。。。</p>
<h3 id="TypeScript-amp-Flow-Pros-and-Cons"><a href="#TypeScript-amp-Flow-Pros-and-Cons" class="headerlink" title="TypeScript &amp; Flow: Pros and Cons"></a>TypeScript &amp; Flow: Pros and Cons</h3><p>下面是作者认为的js的静态类型语言一些优缺点：</p>
<p>让代码的类型更为明显。</p>
<blockquote>
<p>They make types more obvious in code<br>与其他语言的相似性很高，减少了学习成本及思维负担。<br>Familiarity: they look like other language’s type systems<br>流行程度高，社区活跃。<br>Extremely popular these days<br>对于语言特性支持的比较好。<br>They’re very sophisticated and good at what they do<br>它们使用“非js标准”语法(或代码注释)。<br>They use “non-JS-standard” syntax (or code comments)<br>它们需要一个构建过程，这增加了进入的障碍。<br>They require* a build process, which raises the barrier to entry<br>对于那些没有正式类型经验的人来说，它们的复杂性可能令人生畏。<br>Their sophistication can be intimidating to those without prior formal types experience<br>它们更关注“静态类型”(变量、参数、返回、属性等)，而不是值类型。<br>They focus more on “static types” (variables, parameters, returns, properties, etc) than value types<br>对运行时行为有信心的唯一方法是限制/消除动态类型。<br>The only way to have confidence over the runtime behavior is to limit/eliminate dynamic typing</p>
</blockquote>
<h3 id="Understanding-Your-Types"><a href="#Understanding-Your-Types" class="headerlink" title="Understanding Your Types"></a>Understanding Your Types</h3><p>JavaScript有一个(动态)类型系统，它使用各种形式的强制类型转换进行值的数据类型转换，包括相等比较</p>
<blockquote>
<p>JavaScript has a (dynamic) type system, which uses various forms of coercion for value type conversion, including equality comparisons</p>
</blockquote>
<p>js的值是有类型的，变量没有。</p>
<p>然而，流行的响应似乎是:尽可能避免使用这个系统，并使用===“保护”自己，免于担心类型转换。</p>
<blockquote>
<p>However, the prevailing response seems to be: avoid as much of this system as possible, and use === to “protect” from needing to worry about types</p>
</blockquote>
<p>避免使用所有类型的JS(比如假装===)的部分问题在于，它可能会在系统上延续bug</p>
<blockquote>
<p>Part of the problem with avoidance of whole swaths of JS, like pretending === saves you from needing to know types, is that it tends to systemically perpetuate bugs</p>
</blockquote>
<p>如果不知道操作中涉及的类型，就无法编写高质量的JS程序。</p>
<blockquote>
<p>You simply cannot write quality JS programs without knowing the types involved in your operations.</p>
</blockquote>
<p>另外，许多人选择采用不同的“静态类型”系统<br>虽然在某些方面确实有帮助，但这是另一种“回避”</p>
<blockquote>
<p>Alternately, many choose to adopt a different “static types” system layered on top<br>While certainly helpful in some respects, this is “avoidance” of a different sort</p>
</blockquote>
<p>显然，JS的类型系统较差，所以必须替换它，而不是学习和利用<br>许多人声称JS的类型系统对于新开发人员来说太难学了，而且静态类型(以某种方式)更容易学<br>我的主张:更好的方法是接受并学习JS的类型系统，并采用一种使类型尽可能明显的编码风格<br>通过这样做，您将使您的代码对有经验的开发人员和新开发人员都更具可读性和健壮性</p>
<blockquote>
<p>Apparently, JS’s type system is inferior so it must be replaced, rather than learned and leveraged<br>Many claim that JS’s type system is too difficult for newer devs to learn, and that static types are (somehow) more learnable<br>My claim: the better approach is to embrace and learn JS’s type system, and to adopt a coding style which makes types as obvious as possible<br>By doing so, you will make your code more readable and more robust, for experienced and new developers alike</p>
</blockquote>
<h2 id="Scope-作用域"><a href="#Scope-作用域" class="headerlink" title="Scope(作用域)"></a>Scope(作用域)</h2><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><ul>
<li>Nested Scope • Hoisting(嵌套范围•提升)</li>
<li>Closure(闭包)</li>
<li>Modules(模块化)</li>
</ul>
<p>之前作者提出了他认为的js的三大支柱，分别为类型系统(Types)，作用域(Scope)和面向对象(Object(Oriented))。</p>
<p>首先我们要理解词法作用域(lexical scope)，词法作用域时js的运行机制之一。理解词法作用域之后我们就可以理解闭包，理解闭包之后我们就能理解模块化。</p>
<blockquote>
<p>Scope: where to look for things<br>作用域使我们寻找数据的地方。为了理解作用域，首先要明确几个问题。</p>
</blockquote>
<p>第一，我们在寻找什么？一般而言，我们寻找的是标识符。所以当我们处理代码时，当js引擎处理作用域时，js引擎基本上是在处理这个问题：当我看到这个变量时，这个变量处于什么位置？处于哪个作用域？作者做了一个比喻，就像有几个不同颜色的桶，里面装了对应颜色的石头。当js想要找绿色石头时，显然会去绿色桶中去找。</p>
<p>在这里，作者认为js不是一个脚本语言，而是一个编译语言。js在执行前会进行编译，或者说解析。作者提出了证据，就是假设在代码第100行有一个语法错误，js会在执行一开始就报错，而不是执行完前99行后进行报错。这说明了js会在执行开始前对代码进行解析。那么，js会进行哪些解析处理？</p>
<p>在编辑器理论中，有着四个编译阶段（有时可能有的阶段合并，有的时候分开）：</p>
<ol>
<li>lexing(词法分析)</li>
<li>tokenization(标记)</li>
<li>parsing(将token转化为抽象语法树)</li>
<li>code generation(代码生成)</li>
</ol>
<p>这是文本代码转化为可执行机械码的一般过程。</p>
<p>一般认为js是脚本语言的原因之一是没有运行编译器进行编译，这是许多人区别脚本语言和编译语言的心理模型。在这里，作者认为正确的分析方式应该是代码在执行前究竟有没有进行解析执行。作者在这里提出js是编译语言的原因是引发js对作用域建立时机的思考（js是什么时候把不同颜色的石头装到不同颜色的桶之中的）。如果我们认为js是边执行边分类的话那么显然会导致一些错误。这就产生了我们预期心理模型与js执行模型的分歧。所以我们在这里所做的就是使我们的大脑的思维方式尽量与编译器一致，我们在这里希望我们能像编译器一样思考。好消息是我们可以根据二八原则，只学习百分之二十的编译器思想就可以避免百分之八十的问题，剩下的百分之二十的问题暂时与我们无关。在这里，把不同石头提前装到不同颜色的桶中就类似js处理作用域并把对应标识符放置在对应作用域。</p>
<p>所以js在执行前，会有一个编译阶段，并在编译阶段中生成抽象语法树的同时也生成了词法作用域，然后交于js引擎解析执行代码。所以js会先处理代码，生成词法作用域，然后解析执行。</p>
<p>既然在上面的例子中不同颜色的石头代表了标识符，那么水桶代表了什么？</p>
<p>函数作用域和块级作用域(ES6中新增)</p>
<blockquote>
<p>JavaScript organizes scopes with functions and blocks</p>
</blockquote>
<h3 id="Compilation-amp-Scope-编译和作用域"><a href="#Compilation-amp-Scope-编译和作用域" class="headerlink" title="Compilation &amp; Scope(编译和作用域)"></a>Compilation &amp; Scope(编译和作用域)</h3><p>代码分析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Kyle'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">otherClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> teacher = <span class="string">'Suzy'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'welcome!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> question = <span class="string">'why?'</span></span><br><span class="line">  <span class="built_in">console</span>.log(question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">otherClass()</span><br><span class="line">ask()</span><br></pre></td></tr></table></figure>
<p>在分析时强调了js的所有词法作用域在js执行前的编译阶段就已经创建，这样在运行时才可以顺利的访问不同词法作用域的不同变量。</p>
<h3 id="Executing-Code"><a href="#Executing-Code" class="headerlink" title="Executing Code"></a>Executing Code</h3><p>在js中，变量拥有两个角色，一个是存储数据，一个是在需要获取数据时代表数据。这样我们就可以把数据和变量关联起来。变量(variable)和值(value)的关系更像是源(source)和目标(target)。</p>
<p>如果试图给一个未声明的变量赋值，js会自动将该变量添加到全局作用域中。</p>
<h3 id="Strict-Mode"><a href="#Strict-Mode" class="headerlink" title="Strict Mode"></a>Strict Mode</h3><p>把<code>&quot;use strict&quot;</code>关键字放在作用域顶部，即可切换为严格模式。在严格模式下，给未声明的变量赋值会导致引用错误(ReferenceError)。</p>
<h3 id="Nested-Scope-作用域套嵌"><a href="#Nested-Scope-作用域套嵌" class="headerlink" title="Nested Scope(作用域套嵌)"></a>Nested Scope(作用域套嵌)</h3><p>作用域套嵌还可以用水桶比喻，套嵌可以类比为水桶里面装水桶，里面的水桶没有就到外面的水桶中找，所以闭包也就是直接返回小水桶，但是小水桶带着外面大水桶的石头（引用了外部函数执行上下文中的变量，并且函数的参数可以视作在函数内部声明的新变量，其值与传入的实参的值相同），在内部的水桶可以找到外部水桶中的石头，但是外部的无法找到内部水桶中的石头。</p>
<h3 id="Undefined-vs-Undeclared"><a href="#Undefined-vs-Undeclared" class="headerlink" title="Undefined vs Undeclared"></a>Undefined vs Undeclared</h3><p>变量未声明与变量未赋值到底有什么区别？undefined表示变量存在但是目前没有任何值（有可能之前有，也有可能之后有但是目前没有）；未声明表示在我们的所有作用域中不存在这个变量。</p>
<h3 id="Lexical-Scope-Elevator"><a href="#Lexical-Scope-Elevator" class="headerlink" title="Lexical Scope Elevator"></a>Lexical Scope Elevator</h3><p>在这里作者把词法作用域比作一个有电梯的高层建筑物，如果你想在这样一个大厦找东西，首先在第一层找（当前执行上下文），没有就坐电梯（作用域链）到第二层找（上级作用域），最终到顶楼找（全局作用域）。</p>
<h2 id="Scope-amp-Function-Expressions-作用域和函数表达式"><a href="#Scope-amp-Function-Expressions-作用域和函数表达式" class="headerlink" title="Scope &amp; Function Expressions(作用域和函数表达式)"></a>Scope &amp; Function Expressions(作用域和函数表达式)</h2><h3 id="Function-Expressions-函数表达式"><a href="#Function-Expressions-函数表达式" class="headerlink" title="Function Expressions(函数表达式)"></a>Function Expressions(函数表达式)</h3><p>在之前，我们在编译阶段分析函数时，将函数比喻为特殊颜色的水桶，放在全局作用域这个水桶中，并将函数内声明的变量标记为与函数代表的水桶颜色相同的石头放入当前水桶。</p>
<p>下面看一段代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">teacher</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;  <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherTeacher = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* otherTeacher */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myTeacher = <span class="function"><span class="keyword">function</span> <span class="title">anotherTeacher</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 函数表达式</span></span><br><span class="line">  <span class="built_in">console</span>.log(anotherTeacher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(teacher) <span class="comment">// ƒ teacher() &#123; /*...*/ &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(otherTeacher) <span class="comment">// ƒ () &#123; /* otherTeacher */ &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(myTeacher) <span class="comment">// ƒ anotherTeacher() &#123; console.log(anotherTeacher) &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherTeacher) <span class="comment">// ReferenceError: anotherTeacher is not defined</span></span><br></pre></td></tr></table></figure>
<p>但是函数声明和函数表达式是有区别的，函数表达式会将函数名作为变量注册到局部作用域中，所以在全局作用域中无法通过函数名访问通过函数表达式定义的函数，可以通过将函数表达式赋值给变量，通过变量访问函数。</p>
<h4 id="Named-Function-Expressions"><a href="#Named-Function-Expressions" class="headerlink" title="Named Function Expressions"></a>Named Function Expressions</h4><p>在上述代码中，<code>otherTeacher</code>与<code>anotherTeacher</code>均为函数表达式，但是可以发现，<code>otherTeacher</code>变量赋予了一个匿名函数，<code>anotherTeacher</code>后跟了一个命名函数，我们称<code>anotherTeacher</code>为命名的函数表达式。</p>
<h3 id="Naming-Function-Expressions"><a href="#Naming-Function-Expressions" class="headerlink" title="Naming Function Expressions"></a>Naming Function Expressions</h3><p>一般我们使用函数表达式都是把匿名函数赋值给变量，但是把命名函数赋值给变量有如下好处(上面代码中<code>otherTeacher</code>与<code>anotherTeacher</code>通过控制台输出也可发现)</p>
<ol>
<li>Reliable function self-reference (recursion, etc)(可靠的函数自引用(递归等))</li>
<li>More debuggable stack traces(调试时更多可堆栈跟踪)</li>
<li>More self-documenting code(更多的自我记录的代码)</li>
</ol>
<p>在函数自引用时，我们知道arguments.callee已经不推荐使用，那么我们如何在函数内部引用函数自身（递归等情况）？直接使用保存着函数指针的外部变量？还是使用只存在函数作用域内部且具有只读属性的函数名？显然后者可能是更好的选择。首先函数名不会想外部变量一样被重新赋值，所以一直指向函数本身，其次函数名只存在函数作用域内部，只要函数存在就可以调用。</p>
<p>其次在我们进行调试时，如果使用匿名函数，那么显然调用栈中是不容易看出到底执行的是哪个匿名函数。但是使用命名函数表达式，就可以在调用栈中显示出函数名称，方便调试。</p>
<p>第三，可以使得代码的可读性提高，我们可以根据函数的作用给函数命名，并且赋值给变量。</p>
<p>代码的作用是更清晰的展现编程者的意图。所以匿名函数除了减少键盘输入次数可能并没有其他好处，我们应该了解我们所写的每一个函数的功能，并且根据函数的功能给其命名，如果功能过于复杂导致名称过于抽象，那么应该把函数拆分，然后重新给每个函数命名。</p>
<h3 id="Arrow-Functions-箭头函数"><a href="#Arrow-Functions-箭头函数" class="headerlink" title="Arrow Functions(箭头函数)"></a>Arrow Functions(箭头函数)</h3><p>下面还是看一段代码；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ids = people.map(<span class="function"><span class="params">person</span> =&gt;</span> person.id) <span class="comment">// 常见用法，但作者不建议</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ids = people.map(<span class="function"><span class="keyword">function</span> <span class="title">getId</span>(<span class="params">person</span>) </span>&#123; <span class="comment">// 建议使用命名回调函数，可读性更强</span></span><br><span class="line">  <span class="keyword">return</span> person.id</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************/</span></span><br><span class="line"></span><br><span class="line">getPerson()</span><br><span class="line">  .then(<span class="function"><span class="params">person</span> =&gt;</span> getData(person.id)) <span class="comment">// 一般用法，作者不建议</span></span><br><span class="line">  .then(renderData)</span><br><span class="line"></span><br><span class="line">getPerson()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="title">getDataFrom</span>(<span class="params">person</span>)</span>&#123; <span class="comment">// 建议使用命名回调函数，可读性更强</span></span><br><span class="line">    <span class="keyword">return</span> getData(person.id)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(renderData)</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getId = <span class="function"><span class="params">person</span> =&gt;</span> person.id</span><br><span class="line"><span class="keyword">var</span> ids = people.map(getId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getDataFrom = <span class="function"><span class="params">person</span> =&gt;</span> getData(person.id)</span><br><span class="line">getPerson()</span><br><span class="line">  .then(getDataFrom)</span><br><span class="line">  .then(renderData)</span><br></pre></td></tr></table></figure>
<h3 id="Function-Type-Hierachy-函数类型层次"><a href="#Function-Type-Hierachy-函数类型层次" class="headerlink" title="Function Type Hierachy(函数类型层次)"></a>Function Type Hierachy(函数类型层次)</h3><p>在这里作者认为</p>
<p>命名的函数声明 &gt; 命名函数表达式 &gt; 匿名函数表达式</p>
<blockquote>
<p>(Named) Function Declaration &gt; Named Function Expression &gt; Anonymous Function Expression</p>
</blockquote>
<h2 id="Advanced-Scope"><a href="#Advanced-Scope" class="headerlink" title="Advanced Scope"></a>Advanced Scope</h2><h3 id="Lexical-amp-Dynamic-Scope-词法和动态作用域"><a href="#Lexical-amp-Dynamic-Scope-词法和动态作用域" class="headerlink" title="Lexical &amp; Dynamic Scope(词法和动态作用域)"></a>Lexical &amp; Dynamic Scope(词法和动态作用域)</h3><p>词法作用域在编译时已经创建好，不受代码执行影响。动态作用域边执行边创建，代码会影响作用域。</p>
<h3 id="Lexical-Scope"><a href="#Lexical-Scope" class="headerlink" title="Lexical Scope"></a>Lexical Scope</h3><p>词法作用域的设计初衷就是在编译时创建好代码中已有的作用域，这样在解析代码时就不懂在创建一遍作用域，加快代码的解析速度。</p>
<h3 id="Dynamic-Scope-动态作用域"><a href="#Dynamic-Scope-动态作用域" class="headerlink" title="Dynamic Scope(动态作用域)"></a>Dynamic Scope(动态作用域)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Kyle'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">otherClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> teacher = <span class="string">'Suzy'</span></span><br><span class="line">  ask(<span class="string">'why'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">otherClass()</span><br></pre></td></tr></table></figure>
<p>这里的代码中，控制台输出的是<code>Kyle why</code>，因为函数的作用域取决于定义是的作用域，也就是在编译时函数的作用域就已经决定。虽然<code>ask</code>在<code>otherClass</code>内调用，但就像之前所说，js是词法作用域，执行时不影响编译时创建好的作用域，所以输出的是<code>Kyle why</code>而不是<code>Suzy why</code>。</p>
<p>对应的，动态作用域语言输出<code>Suzy why</code>，因为其作用域取决于函数执行时的作用域。</p>
<p>动态作用域在运行时的条件确定作用域，词法作用域在编译时已确定，执行时不会更改已经确定的作用域。</p>
<h3 id="Function-Scoping"><a href="#Function-Scoping" class="headerlink" title="Function Scoping"></a>Function Scoping</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Kyle'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherTeacher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> teacher = <span class="string">'Suzy'</span></span><br><span class="line">  <span class="built_in">console</span>.log(teacher) <span class="comment">// Suzy</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(teacher) <span class="comment">// Kyle</span></span><br></pre></td></tr></table></figure>
<p>可以看到，上述代码中，<code>teacher</code>分别被声明在两个作用域中，这就一定程度上解决了变量命名冲突问题。</p>
<p>在程序设计中，有一项原则，称为最小暴露原则或者最小特权原则：你应该保持一切都隐藏起来，只暴露必要的部分。这是一种防御姿态，保持我们程序的独立性。这事实上也解决了三个问题，首先减少了命名冲突，其次减少了意外使用或修改的风险（不暴露在外部，在外部无法访问修改私有属性方法），第三，可以帮助以后的重构（不依赖外部环境，可以放心修改）。</p>
<h3 id="IIFE-Pattern-立即执行函数模式"><a href="#IIFE-Pattern-立即执行函数模式" class="headerlink" title="IIFE Pattern(立即执行函数模式)"></a>IIFE Pattern(立即执行函数模式)</h3><p>立即执行函数来源于一个想法，既然我们可以把一段代码放在一个()内，使其成为一个代码段执行，那么为什么要把保存函数指针的变量后加()执行而不是函数本身放在()内，在后面加()调用呢？</p>
<p>这应该就是立即执行函数的来源。既把一个函数的声明放在一个()内，使其解析为一个代码段，并在后加()立即调用，这样就把定义函数和调用函数放在了一起。而不是在变量中保存函数指针然后使用变量调用函数。</p>
<p>在这里作者还是建议即使使用立即执行函数，也最好给函数命名。如果实在不知道叫啥，就叫IIFE。这样才方便在Chrome开发者工具中追踪调用栈目前执行的函数。</p>
<h3 id="Block-Scoping"><a href="#Block-Scoping" class="headerlink" title="Block Scoping"></a>Block Scoping</h3><p>块级作用域的原则与函数作用域一致：我们把数据和函数放在块级作用域内隐藏起来，减少命名冲突的可能性，保护私有变量及方法，方便未来进行重构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Kyle'</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// 块级作用域开始</span></span><br><span class="line">  <span class="keyword">let</span> teacher = <span class="string">'Suzy'</span> <span class="comment">// 私有变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(teacher) <span class="comment">// ‘Suzy’</span></span><br><span class="line">&#125; <span class="comment">// 块级作用域结束</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(teacher)</span><br></pre></td></tr></table></figure>
<p>注意，因为在es5中只有函数作用域，所以即使在{}内使用var来声明变量，变量属于其所在的函数或全局作用域内，所以在{}内不能使用var来定义私有变量。<strong>通过使用ES6的<code>let</code>及<code>const</code>定义变量，我们可以在一个{}定义私有变量及方法，既<code>let</code>和<code>const</code>会将所在的{}变成一个块级作用域，也就是说如果一个{}内没有<code>let</code>和<code>const</code>关键字，{}就不是一个块级作用域</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; y) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x <span class="comment">// 这里使用var声明了一个if语句内的临时变量，不建议使用，因为var在整个函数的作用域中</span></span><br><span class="line">    <span class="keyword">let</span> tmp2 = x <span class="comment">// 这里使用了let关键字声明变量，是的if后的&#123;&#125;成为一个块级作用域，tmp2成为一个私有变量</span></span><br><span class="line">    x = y</span><br><span class="line">    y = tmp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y - x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里作者还建议了谨慎使用<code>let</code>及<code>const</code>，因为这两个关键字会把当前{}变为新的作用域，但是使用<code>var</code>并不会导致作用域的增加，所以仍有使用<code>var</code>的原因。例如如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result = fn( result, i )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Choosing-let-or-var"><a href="#Choosing-let-or-var" class="headerlink" title="Choosing let or var"></a>Choosing let or var</h3><p>作者认为上述代码使用es6的<code>let</code>关键字后可以修改如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result = fn( result, i )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在上述代码中，for循环内的关键字修改为<code>let</code>，但是函数体内第一行仍使用<code>var</code>。作者认为，只在一些需要私有变量的时候，例如for循环体内使用<code>let</code>，但是在定义一些作用域内均可使用的变量时，仍使用<code>var</code>关键字，这样可以使代码更加语义化，既使用<code>let</code>声明明确的私有变量，<code>var</code>声明作用域内的公共变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lookupRecord</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id = getRecord( searchStr )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> id <span class="comment">// 如果把上面的try catch语句中的var替换为let，这里会报错，因为id在此作用域内未声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>var</code>关键字可以在同一作用域内多次声明同一变量，所以有时使用var重复声明变量可以使代码更加语义化，此时可以使用<code>var</code>关键字。</p>
<h3 id="Explicit-let-Block"><a href="#Explicit-let-Block" class="headerlink" title="Explicit let Block"></a>Explicit let Block</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatStr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  &#123; <span class="keyword">let</span> prefix, rest</span><br><span class="line">      prefix = str.slice(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">      rest = str.slice(<span class="number">3</span>)</span><br><span class="line">      str = prefix.toUpperCase() + rest</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/^FOO:/</span>.test(str)) &#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str.slice(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，即使在函数作用域内，作者还是给临时变量添加了{}，使用了块级作用域来包裹声明的临时变量。这也是其他使用块级作用域语言的常用作法。</p>
<h3 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h3><p><code>const</code>不是意味着一个不变的变量，而是意味着无法重新分配的变量。在js中，基本类型传递的是基本类型的值，把基本类型值赋值给<code>const</code>定义的变量，那个就无法重新给此变量赋值。但是因为引用类型传递的是指针，所以即使改变了指针所指向的数据结构，但是只要指针本身不改变，就不会报错。所以使用<code>const</code>定义变量并把引用类型的指针赋值给变量时，仍可更改引用类型的值。</p>
<h3 id="Hoisting-变量提升"><a href="#Hoisting-变量提升" class="headerlink" title="Hoisting(变量提升)"></a>Hoisting(变量提升)</h3><p>js引擎其实并没有变量提升这个执行过程。变量提升是一种语言惯例，其实并不存在与js中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student <span class="comment">// undefined</span></span><br><span class="line">teacher <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> student = <span class="string">'you'</span></span><br><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Kyle'</span></span><br></pre></td></tr></table></figure>
<p>在过去，我们把先使用变量后声明并赋值变量，但是并不报错并返回undefined的现象解释为变量提升。我们对变量提升的解释模型如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student</span><br><span class="line"><span class="keyword">var</span> teacher</span><br><span class="line">student = <span class="string">'you'</span></span><br><span class="line">teacher = <span class="string">'Kyle'</span></span><br></pre></td></tr></table></figure>
<p>人们认为代码在执行时的结果如上，并将变量提升解释为js在执行时会将所有变量的声明提升到作用域顶端，但是还在代码的同样位置赋值。但事实上js的运行机制并不是这样。</p>
<p>就像我们之前所讲的一样，js在执行前的编译阶段就已经创建好了所有的作用域，并明确了作用域内声明的所有变量。所以js执行时的代码更类似如下这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student</span><br><span class="line">teacher</span><br><span class="line">student = <span class="string">'you'</span></span><br><span class="line">teacher = <span class="string">'Kyle'</span></span><br></pre></td></tr></table></figure>
<p>js在解析编译阶段就已经将所有作用域及各个作用域的变量都创建好，只是在执行阶段进行赋值并操作修改。所以变量提升的说法并不严谨，这只是为了简化js的运行机制删除了一些细节的粗略模型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">teacher() <span class="comment">// Kyle</span></span><br><span class="line">otherTeacher() <span class="comment">// TypeError: otherTeacher is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">teacher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Kyle'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherTeacher = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Suzy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用变量提升模型，我们将上述代码转换如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">teacher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Kyle'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> otherTeacher</span><br><span class="line"></span><br><span class="line">teacher() <span class="comment">// Kyle</span></span><br><span class="line">otherTeacher() <span class="comment">// TypeError: otherTeacher is not a function</span></span><br><span class="line"></span><br><span class="line">otherTeacher = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Suzy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="let-Dosen’t-Hoist"><a href="#let-Dosen’t-Hoist" class="headerlink" title="let Dosen’t Hoist"></a>let Dosen’t Hoist</h3><p>使用let关键字不会导致变量提升？</p>
<p>我们来看一段代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  teacher = <span class="string">'Kyle'</span> <span class="comment">// TDZ error 暂时性死区(temporal dead zone)错误</span></span><br><span class="line">  <span class="keyword">let</span> teacher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这句话的出发点很好，但不准确。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Kyle'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(teacher) <span class="comment">// TDZ error 暂时性死区(temporal dead zone)错误</span></span><br><span class="line">  <span class="keyword">let</span> teacher = <span class="string">'Suzy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，如果用let不会变量提升来解释，显然控制台应该打印”Kyle“。但是代码仍然报错暂时性死区错误。</p>
<p>这说明<code>let</code>也会有变量提升，但是提升的方式与<code>var</code>不同。首先<code>let</code>提升到块级作用域顶部，而<code>var</code>提升高函数作用域顶部。其次在使用<code>var</code>时，会将变量的值初始化为<code>undefined</code>，但是用<code>let</code>时，只会在块级作用域顶部声明变量，但是不会初始化变量，所以在初始化变量的值之前都无法使用变量，这就是暂时性死区。</p>
<p>作者在这里认为TDZ概念最早提出是基于<code>const</code>，因为<code>const</code>代表了一个不可以重新赋值的变量，如果我们把<code>const</code>定义的变量提升到作用域顶部并在赋值之前初始化为<code>undefined</code>，那么显然<code>const</code>就会在赋值时重新赋值，这显然违背了<code>const</code>设计的初衷。所以在使用<code>const</code>定义变量时，仍存在变量提升，但不会初始化，此时<code>const</code>所定义的变量也无法使用，这就是TDZ的由来。既然<code>const</code>如此，那么<code>let</code>为什么不也这样呢，所以es6中<code>let</code>和<code>const</code>都有TDZ。</p>
<p>在问答中，作者也提出了<strong>其实js在编译时也对函数进行了处理，创建了函数作用域并声明了作用域的变量，但是并没有对变量进行具体操作，这些操作都会在js执行阶段调用函数时执行</strong>。</p>
<h2 id="Closure-闭包"><a href="#Closure-闭包" class="headerlink" title="Closure(闭包)"></a>Closure(闭包)</h2><h3 id="Origin-of-Closure-闭包的起源"><a href="#Origin-of-Closure-闭包的起源" class="headerlink" title="Origin of Closure(闭包的起源)"></a>Origin of Closure(闭包的起源)</h3><p>闭包的思想在计算机科学存在之前就已经存在，来源于Lambda演算。</p>
<h3 id="What-is-Closure"><a href="#What-is-Closure" class="headerlink" title="What is Closure"></a>What is Closure</h3><p>这里是作者认为最为准确的闭包的定义。</p>
<p><strong>闭包是即使函数是在词法作用域之外执行，函数仍然可以“记住”它的词法作用域</strong>。</p>
<blockquote>
<p>Closure is when a function “remembers” its lexical scope even when the function is executed outside that lexical scope.</p>
</blockquote>
<p>当把一个函数作为回调函数传给另一个函数作为参数时，或者把一个函数从另一个函数内部返回时，很明显函数定义时所在的作用域与执行时并不一致，此时函数的作用域在概念上应该被垃圾回收掉了。但是我们发现此时仍可以通过函数访问已经’消失‘的变量，这并不是偶然的，这就是闭包的设计初衷。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">waitASec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(question)</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">ask(<span class="string">'What is Closure'</span>)</span><br><span class="line"><span class="comment">// What is Closure</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中可以看到，<code>setTimeout</code>内的回调函数<code>waitASec</code>访问到了其外部<code>ask</code>的实参，理论上<code>ask</code>已在100毫秒前执行完毕，其执行上下文被推出调用栈，并被垃圾回收机制回收。但是因为<code>setTimeout</code>内的回调函数<code>waitASec</code>对其实参进行了引用，所以在内存中的数据并没有消失，而是保留了下来，以供<code>waitASec</code>进行调用，这就是闭包。</p>
<p>在这里作者提出据她了解，js引擎会将作用域的全部执行上下文保留，而不仅仅是被引用的变量，这在作用域内数据量特别大的时候会有性能上的风险。</p>
<h3 id="Closing-Over-Variables"><a href="#Closing-Over-Variables" class="headerlink" title="Closing Over Variables"></a>Closing Over Variables</h3><p>闭包并不是把变量保存下来，而是与变量建立连接。所以如果内部函数引用了外部变量，外部变量改变，内部函数引用的外部变量也会改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Kyle'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myTeacher = <span class="function"><span class="keyword">function</span> <span class="title">myTeacherIs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(teacher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">teacher = <span class="string">'Suzy'</span></span><br><span class="line"></span><br><span class="line">myTeacher() <span class="comment">// Suzy</span></span><br></pre></td></tr></table></figure>
<p>可以看到上述代码输出了Suzy，证明了外部变量改变后，函数内部引用的teacher的值也进行了改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">numberIs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i: <span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125; <span class="comment">// 每隔1s输出4，共三次</span></span><br></pre></td></tr></table></figure>
<p>如果使用es6语法，将上述代码的输出结果为1，2，3。代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> j = i</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">numberIs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`j: <span class="subst">$&#123;j&#125;</span>`</span>)</span><br><span class="line">  &#125;, j * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们在for循环内使用了<code>let</code>关键字，使得for循环的{}成为了一个块级作用域。<code>setTimeout</code>的回调函数引用的时在作用域内新建的变量，每次执行for循环，就新建一个<code>j</code>，所以可以输出1，2，3。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">numberIs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i: <span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者我们可以更加简化一下，直接在for循环的()内使用<code>let</code>关键字，使for循环的{}成为一个块级作用域。</p>
<h3 id="Module-Pattern"><a href="#Module-Pattern" class="headerlink" title="Module Pattern"></a>Module Pattern</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workshop = &#123;</span><br><span class="line">  teacher: <span class="string">'Kyle'</span>,</span><br><span class="line">  ask(question) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workshop.ask(<span class="string">'Is this a module?'</span>) <span class="comment">// Kyle Is this a module?</span></span><br></pre></td></tr></table></figure>
<p>上述代码把方法和方法需要的数据都添加到了一个对象中，是<strong>命名空间模式</strong>。这是一种组织方法与数据的模式，但这并不是模块。命名空间模式并不是模块的原因是模块模式需要封装的概念，封装意味着要隐藏数据与行为。</p>
<p><strong>模块将数据和行为(方法)封装在一起。模块的状态(数据)由它的方法通过闭包保存</strong>。</p>
<blockquote>
<p>Modules encapsulate data and behavior(methods) together. The state (data) of a module is held by its methods via closure.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workshop = (<span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">teacher</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> publicAPI = &#123; ask, &#125;</span><br><span class="line">  <span class="keyword">return</span> publicAPI</span><br><span class="line"></span><br><span class="line">  <span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">'Kyle'</span>)</span><br><span class="line"></span><br><span class="line">workshop.ask(<span class="string">"It's a Module, right?"</span>) <span class="comment">// Kyle It's a Module, right?</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在上述代码中，我们把需要的变量变为了函数的参数传入，并且返回了引用了参数的方法，在外部是无法访问方法所引用的数据的。通过闭包，我们可以保存私有变量及方法，所以没有闭包就没有模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WorkshopModule</span>(<span class="params">teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> publicAPI = &#123; ask, &#125;</span><br><span class="line">  <span class="keyword">return</span> publicAPI</span><br><span class="line"></span><br><span class="line">  <span class="comment">//***************</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(teacher,question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workshop = WorkshopModule(<span class="string">'Kyle'</span>)</span><br><span class="line"></span><br><span class="line">workshop.ask(<span class="string">"It's a Module, right?"</span>) <span class="comment">// Kyle It's a Module, right?</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们没有使用IIFE(立即执行函数)，而是定义了一个普通函数作为模块，在需要时创建一个实例，通过实例的方法可以访问实例的私有属性。这样只用定义一次，每创建一个实例就有了一个新的模块。我们把<code>WorkshopModule</code>称为工厂函数。</p>
<h3 id="ES6-Modules-amp-Node-js"><a href="#ES6-Modules-amp-Node-js" class="headerlink" title="ES6 Modules &amp; Node.js"></a>ES6 Modules &amp; Node.js</h3><p>ES6的模块基于文件，所以一个文件只能有一个模块。</p>
<h3 id="ES6-Module-Syntax"><a href="#ES6-Module-Syntax" class="headerlink" title="ES6 Module Syntax"></a>ES6 Module Syntax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Kyle'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(teacher, question)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ask <span class="keyword">from</span> <span class="string">'workshop.mjs'</span></span><br><span class="line"></span><br><span class="line">ask(<span class="string">"It's a default import, right?"</span>)</span><br><span class="line"><span class="comment">// Kyle It's a default import, right?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> workshop <span class="keyword">from</span> <span class="string">'workshop.mjs'</span></span><br><span class="line"></span><br><span class="line">workshop.ask(<span class="string">"It's a namespace import, right?"</span>)</span><br><span class="line"><span class="comment">// Kyle It's a namespace import, right?</span></span><br></pre></td></tr></table></figure>
<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><h3 id="Objects-Overview"><a href="#Objects-Overview" class="headerlink" title="Objects Overview"></a>Objects Overview</h3><p>Objects (Oriented)</p>
<ul>
<li>this</li>
<li>class { }</li>
<li>Prototypes</li>
<li>“Inheritance” vs. “Behavior Delegation” (OO vs. OLOO)</li>
</ul>
<h3 id="The-this-Keyword"><a href="#The-this-Keyword" class="headerlink" title="The this Keyword"></a>The this Keyword</h3><p>函数的<code>this</code>引用调用该函数的执行上下文，完全由函数的调用方式决定（函数定义时的执行上下文与<code>this</code>无关）。</p>
<blockquote>
<p>A function’s this references the execution context for that call, determined entirely by how the function was called.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">otherClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myContext = &#123;</span><br><span class="line">    teacher: <span class="string">'Suzy'</span></span><br><span class="line">  &#125;</span><br><span class="line">  ask.call(myContext, <span class="string">'Why?'</span>) <span class="comment">// Suzy Why?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">otherClass()</span><br></pre></td></tr></table></figure>
<p>因此，每次调用此感知函数时，它可以具有不同的上下文，这使得它更加灵活和可重用。</p>
<blockquote>
<p>A this-aware function can thus have a different context each time it’s called, which makes it more flexible &amp; reusable.</p>
</blockquote>
<p>在之前我们了解到，js使用词法作用域，也就是函数的作用域完全取决于函数定义时的作用域，但是如果我们想要获得一些动态作用域的特性呢？既当前作用域不取决于定义时的作用域，而是函数调用时的作用域，所以设计出了this关键字。</p>
<p>为了区分使用时<code>this</code>的指向，js设计出了四种调用函数的方式：</p>
<ol>
<li>this: implicit binding(隐式绑定)</li>
<li>this: explicit binding(显示绑定)</li>
<li>this: hard binding(硬绑定，创建了一个新的函数，并不算函数调用)</li>
<li>this: new binding(new关键字绑定)</li>
<li>default binding</li>
</ol>
<h3 id="Implicit-amp-Explicit-Binding"><a href="#Implicit-amp-Explicit-Binding" class="headerlink" title="Implicit &amp; Explicit Binding"></a>Implicit &amp; Explicit Binding</h3><h4 id="implicit-binding-隐式绑定"><a href="#implicit-binding-隐式绑定" class="headerlink" title="implicit binding(隐式绑定)"></a>implicit binding(隐式绑定)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workshop = &#123;</span><br><span class="line">  teacher: <span class="string">'Kyle'</span>,</span><br><span class="line">  ask(question) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workshop.ask(<span class="string">'What is implicit binding?'</span>) <span class="comment">// Kyle What is implicit binding?</span></span><br></pre></td></tr></table></figure>
<p>隐式绑定时this指向调用函数的对象的执行上下文(如果直接调用函数，指向widows对象的执行上下文，既全局作用域)。</p>
<p>通过隐式绑定，我们可以模拟出动态作用域的效果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workshop1 = &#123;</span><br><span class="line">  teacher: <span class="string">'Kyle'</span>,</span><br><span class="line">  ask: ask</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workshop2 = &#123;</span><br><span class="line">  teacher: <span class="string">'Suzy'</span>,</span><br><span class="line">  ask: ask</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workshop1.ask(<span class="string">'How do I share a method?'</span>) <span class="comment">// Kyle How do I share a method?</span></span><br><span class="line">workshop2.ask(<span class="string">'How do I share a method?'</span>) <span class="comment">// Suzy How do I share a method?</span></span><br></pre></td></tr></table></figure>
<h4 id="explicit-binding-显示绑定，使用call或apply方法"><a href="#explicit-binding-显示绑定，使用call或apply方法" class="headerlink" title="explicit binding(显示绑定，使用call或apply方法)"></a>explicit binding(显示绑定，使用call或apply方法)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workshop1 = &#123;</span><br><span class="line">  teacher: <span class="string">'Kyle'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workshop2 = &#123;</span><br><span class="line">  teacher: <span class="string">'Suzy'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ask.call(workshop1, <span class="string">'Can I explicitly set context?'</span>) <span class="comment">// Kyle Can I explicitly set context?</span></span><br><span class="line">ask.call(workshop2, <span class="string">'Can I explicitly set context?'</span>) <span class="comment">// Suzy Can I explicitly set context?</span></span><br></pre></td></tr></table></figure>
<p>上述代码可以看到，我们直接调用了函数，但是使用了<code>Function.prototype.call()</code>方法调用，手动的将<code>ask</code>内的<code>this</code>指向了<code>workshop1</code>和<code>workshop2</code>，而不是<code>windows</code>对象，输出了预期的结果</p>
<h4 id="hard-binding"><a href="#hard-binding" class="headerlink" title="hard binding"></a>hard binding</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Suzy'</span></span><br><span class="line"><span class="keyword">var</span> workshop = &#123;</span><br><span class="line">  teacher: <span class="string">'Kyle'</span>,</span><br><span class="line">  ask(question) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(workshop.ask, <span class="number">1000</span>, <span class="string">'Lost this?'</span>) <span class="comment">// Suzy Lost this?</span></span><br><span class="line"></span><br><span class="line">setTimeout(workshop.ask.bind(workshop), <span class="number">1000</span>, <span class="string">'Hard bound this?'</span>) <span class="comment">// Kyle Hard bound this?</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在上述代码中将<code>work.ask</code>作为回调函数传入其他函数作为参数时，<code>this</code>的指向进行了改变，指向了<code>windows</code>对象的执行上下文，这是因为传递的只是函数的指针，在调用时函数指向了windows。此时我们要使用<code>bind</code>方法将<code>workshop</code>的执行上下文绑定在方法内的<code>this</code>上，这样只要调用，<code>this</code>就指向了<code>workshop</code>的执行上下文，而不是当前调用的作用域。所以<code>bind()</code>方法不是调用函数，而是创建一个新的函数，在调用时设置this关键字为提供的值。</p>
<h3 id="The-new-Keyword"><a href="#The-new-Keyword" class="headerlink" title="The new Keyword"></a>The new Keyword</h3><p>使用<code>new</code>关键字，是我们第三种可以调用函数的方式（<code>bind</code>是创建了新函数，并不算调用函数）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newEmptyObject = <span class="keyword">new</span> ask(<span class="string">"What is 'new' doing here?"</span>)</span><br><span class="line"><span class="comment">// undefined "What is 'new' doing here?"</span></span><br></pre></td></tr></table></figure>
<p>当我们使用new关键字调用函数时，会有如下的过程</p>
<blockquote>
<p>js高级程序设计</p>
</blockquote>
<ol>
<li>创建一个新对象，</li>
<li>将构造函数的作用域赋给新对象（此时构造函数的this指向了新对象，新对象的原型也指向了构造函数的原型对象）</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<blockquote>
<p>此教程</p>
</blockquote>
<ol>
<li>Create a brand new empty object</li>
<li>Link that object to another object</li>
<li>Call function with this set to the new object</li>
<li>If function does not return an object, assume return of this</li>
</ol>
<p>在JavaScript: The Hard Part中，我们是通过以下代码实现<code>new</code>关键字的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userCreator</span>(<span class="params">name, score</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newUser = <span class="built_in">Object</span>.create(userFunctionStore)</span><br><span class="line">  newUser.name = name</span><br><span class="line">  newUser.score = score</span><br><span class="line">  <span class="keyword">return</span> newUser</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="keyword">let</span> userFunctionStore = &#123;</span><br><span class="line">  increment() &#123; <span class="keyword">this</span>.score++ &#125;,</span><br><span class="line">  login() &#123; <span class="built_in">console</span>.log(<span class="string">"you are loggedin"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化构造器</span></span><br><span class="line"><span class="keyword">let</span> user1 = userCreator(<span class="string">"Will"</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> user2 = userCreator(<span class="string">"Tim"</span>, <span class="number">5</span>)</span><br><span class="line">user1.increment()</span><br></pre></td></tr></table></figure>
<h3 id="default-binding"><a href="#default-binding" class="headerlink" title="default binding"></a>default binding</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="string">'Kyle'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">askAgain</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ask(<span class="string">"What's the none-strict-mode default?"</span>) <span class="comment">// Kyle What's the none-strict-mode default?</span></span><br><span class="line">askAgain(<span class="string">"What's the strict-mode default"</span>) <span class="comment">//  TypeError</span></span><br></pre></td></tr></table></figure>
<h3 id="Binding-Precedence"><a href="#Binding-Precedence" class="headerlink" title="Binding Precedence"></a>Binding Precedence</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workshop = &#123;</span><br><span class="line">  teacher: <span class="string">'Kyle'</span>,</span><br><span class="line">  ask: <span class="function"><span class="keyword">function</span> <span class="title">ask</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> (workshop.ask.bind(workshop))(<span class="string">'What does this do'</span>) <span class="comment">// undefined "What does this do"</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们首先为在<code>workshop</code>对象中调用<code>ask</code>，同时也将<code>ask</code>中的<code>this</code>手动绑定到了<code>workshop</code>上，最后使用<code>new</code>调用函数并传入参数，最后<code>this.teacher</code>输出为<code>undefined</code>。</p>
<p>以下是判断this指向的顺序：</p>
<ol>
<li>Is the function called by new?</li>
<li>Is the function called by call() or apply()? Note: bind() effectively uses apply()</li>
<li>Is the function called on a context object?</li>
<li>DEFAULT: global object (except strict mode)</li>
</ol>
<h3 id="Arrow-Functions-amp-Lexical-this"><a href="#Arrow-Functions-amp-Lexical-this" class="headerlink" title="Arrow Functions &amp; Lexical this"></a>Arrow Functions &amp; Lexical this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workshop = &#123;</span><br><span class="line">  teacher: <span class="string">'Kyle'</span>,</span><br><span class="line">  ask(question) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workshop.ask(<span class="string">"Is this lexical 'this'?"</span>) <span class="comment">// Kyle Is this lexical 'this'?</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在上述代码中回调函数使用了箭头函数，此时没有手动绑定<code>this</code>，但是仍输出了<code>workshop</code>的执行上下文内的变量。在这里我们把箭头函数中的<code>this</code>称为<code>lexical this</code>。在箭头函数中，并不存在<code>this</code>，在箭头函数中使用<code>this</code>就跟其他变量一样在定义时已经确定作用域，而不是执行时，并且绑定的是箭头函数的上一级作用域。</p>
<p>箭头函数是<code>this</code>-绑定(即<code>.bind()</code>)到它的父级函数。</p>
<blockquote>
<p>An arrow function is this-bound (aka .bind()) to its parent function.</p>
</blockquote>
<p>上述是绝大部分人对于箭头函数中<code>this</code>的认知，实际上，根据规范，箭头函数中并不存在<code>this</code>关键字。所以在箭头函数中使用<code>this</code>，就会像使用其他变量一样，根据作用域链指向其父级作用域的<code>this</code>。</p>
<blockquote>
<p>箭头函数并没有定义this，所以箭头函数中的this像其他普通变量一样，是按词法解析的(也就是“词法this”)。<br>An arrow function doesn’t define a this, so it’s like any normal variable, and resolves lexically (aka “lexical this”).</p>
</blockquote>
<p>以下是规范中关于箭头函数中this的说明：</p>
<blockquote>
<p>ArrowFunction不为arguments、super、this或new.target定义本地绑定。ArrowFunction中任何对arguments、super、this或new.target的引用必须解析为词法封闭环境中的绑定。通常，这将是立即封闭函数的函数环境。尽管ArrowFunction可能包含对super的引用，但是在步骤4中创建的函数对象并不是通过执行MakeMethod而变成方法的。引用super的ArrowFunction总是包含在非ArrowFunction中，并且可以通过ArrowFunction的函数对象捕获的范围访问实现super所需的状态。<br>An ArrowFunction does not define local bindings for arguments, super, this, or  new.target. Any reference to arguments, super, this, or new.target within an ArrowFunction must resolve to a binding in a lexically enclosing environment. Typically this will be the Function Environment of an immediately enclosing function. Even though an ArrowFunction may contain references to super, the function object created in step 4 is not made into a method by performing MakeMethod. An ArrowFunction that references super is always contained within a non-ArrowFunction and the necessary state to implement super is accessible via the scope that is captured by the function object of the ArrowFunction.</p>
</blockquote>
<h3 id="Resolving-this-in-Arrow-Functions"><a href="#Resolving-this-in-Arrow-Functions" class="headerlink" title="Resolving this in Arrow Functions"></a>Resolving this in Arrow Functions</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workshop = &#123;</span><br><span class="line">  teacher: <span class="string">'Kyle'</span>,</span><br><span class="line">  ask: <span class="function">(<span class="params">question</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workshop.ask(<span class="string">"What happend to 'this'?"</span>) <span class="comment">// undefined "What happend to 'this'?"</span></span><br><span class="line">workshop.ask.call(workshop,<span class="string">"Still no 'this'?"</span>) <span class="comment">// undefined "Still no 'this'?"</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中可以看到，即使显示的调用<code>call()</code>方法将箭头函数的<code>this</code>绑定在<code>workshop</code>上，仍然输出<code>undefined</code>，因为箭头函数中并没有定义<code>this</code>。</p>
<h3 id="ES6-class-Keyword"><a href="#ES6-class-Keyword" class="headerlink" title="ES6 class Keyword"></a>ES6 class Keyword</h3><p><code>class</code>关键字是一个基于js原型系统的语法糖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Workshop</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(teacher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.teacher = teacher</span><br><span class="line">  &#125;</span><br><span class="line">  ask(question) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deepJS = <span class="keyword">new</span> Workshop(<span class="string">'Kyle'</span>)</span><br><span class="line"><span class="keyword">var</span> reactJS = <span class="keyword">new</span> Workshop(<span class="string">'Suzy'</span>)</span><br><span class="line"></span><br><span class="line">deepJS.ask(<span class="string">"Is 'class' a class?"</span>) <span class="comment">// Kyle Is 'class' a class?</span></span><br><span class="line">reactJS.ask(<span class="string">"Is this class ok?"</span>)  <span class="comment">// Suzy Is this class ok?</span></span><br></pre></td></tr></table></figure>
<p>以上是<code>class</code>的基本用法，如果想继承一个已经定义好的类，可以像如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Workshop</span> </span>&#123; <span class="comment">// 定义一个基类</span></span><br><span class="line">  <span class="keyword">constructor</span>(teacher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.teacher = teacher</span><br><span class="line">  &#125;</span><br><span class="line">  ask(question) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherWorkshop</span> <span class="keyword">extends</span> <span class="title">Workshop</span> </span>&#123; <span class="comment">// 继承基类</span></span><br><span class="line">  speakUp(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ask(msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> JSRecentParts = <span class="keyword">new</span> AnotherWorkshop(<span class="string">'Kyle'</span>)</span><br><span class="line"></span><br><span class="line">JSRecentParts.speakUp(<span class="string">'Are classes getting better?'</span>) <span class="comment">// Kyle Are classes getting better?</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们使用<code>extends</code>关键字使<code>AnotherWorkshop</code>继承了<code>Workshop</code>的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Workshop</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(teacher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.teacher = teacher</span><br><span class="line">  &#125;</span><br><span class="line">  ask(question) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherWorkshop</span> <span class="keyword">extends</span> <span class="title">Workshop</span> </span>&#123;</span><br><span class="line">  ask(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.ask(msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> JSRecentParts = <span class="keyword">new</span> AnotherWorkshop(<span class="string">'Kyle'</span>)</span><br><span class="line">JSRecentParts.ask(<span class="string">'Are classes super?'</span>) <span class="comment">// Kyle ARE CLASSES SUPER?</span></span><br></pre></td></tr></table></figure>
<p>在ES6中，我们使用了<code>class</code>解决面相对象中的封装问题，使用<code>extends</code>解决继承问题，那么如何解决多态问题呢？</p>
<p>所以设计出了<code>super</code>关键字，在上述代码中，我们在<code>AnotherWorkshop</code>中使用了<code>super</code>重新定义了继承与<code>Workshop</code>的<code>ask</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Workshop</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(teacher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.teacher = teacher</span><br><span class="line">  &#125;</span><br><span class="line">  ask(question) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deepJS = <span class="keyword">new</span> Workshop(<span class="string">'Kyle'</span>)</span><br><span class="line">setTimeout(deepJS.ask, <span class="number">100</span>, <span class="string">"Still losing 'this'?"</span>) <span class="comment">// undefined "Still losing 'this'?"</span></span><br></pre></td></tr></table></figure>
<p>可以看到，使用<code>class</code>定义的方法与普通函数一样，并不会绑定<code>this</code>。</p>
<h3 id="Fixing-this-in-Classes"><a href="#Fixing-this-in-Classes" class="headerlink" title="Fixing this in Classes"></a>Fixing this in Classes</h3><p><a href="https://gist.github.com/getify/86bed0bb78ccb517c84a6e61ec16adca" target="_blank" rel="noopener">作者的解决方案</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> method = (<span class="function"><span class="keyword">function</span> <span class="title">defineMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> instances = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">obj,methodName,fn</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(obj,methodName,&#123;</span><br><span class="line">         <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (!instances.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">               instances.set(<span class="keyword">this</span>,&#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> methods = instances.get(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!(methodName <span class="keyword">in</span> methods)) &#123;</span><br><span class="line">               methods[methodName] = fn.bind(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> methods[methodName];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindMethods</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> ownProp <span class="keyword">of</span> <span class="built_in">Object</span>.getOwnPropertyNames(obj)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[ownProp] == <span class="string">"function"</span>) &#123;</span><br><span class="line">         method(obj,ownProp,obj[ownProp]);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h2><h3 id="Prototypes-原型"><a href="#Prototypes-原型" class="headerlink" title="Prototypes(原型)"></a>Prototypes(原型)</h3><p>对象是通过“调用构造函数”创建的（使用new关键字）。</p>
<blockquote>
<p>Objects are built by “constructor calls” (via new)</p>
</blockquote>
<p>“调用构造函数”会创建一个“<strong>链接上</strong>”构造函数<strong>原型</strong>的对象。</p>
<blockquote>
<p>A “constructor call” makes an object “<strong>linked to</strong>” its own <strong>prototype</strong></p>
</blockquote>
<p>我们都知道js是一门基于对象的语言。在一些面相对象的语言中，我们会创建一个类，在使用时创造一个类的实例来进行使用。类就类似图纸，实例就类似根据图纸造出来的建筑。我们没法直接使用图纸，但是可以使用建筑，同时，我们的建筑时根据图纸制造的，可以造的不同，但是一些图纸上的特性，建筑上也存在。</p>
<p>js原型系统的关键在于<strong>实例并没有复制构造函数的原型对象，而是将实例的原型与构造函数的原型对象链接到了一起</strong>。</p>
<h3 id="Prototypal-Class"><a href="#Prototypal-Class" class="headerlink" title="Prototypal Class"></a>Prototypal Class</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Workshop</span>(<span class="params">teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.teacher = teacher</span><br><span class="line">&#125;</span><br><span class="line">Workshop.prototype.ask = <span class="function"><span class="keyword">function</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deepJS = <span class="keyword">new</span> Workshop(<span class="string">'Kyle'</span>)</span><br><span class="line"><span class="keyword">var</span> reactJS = <span class="keyword">new</span> Workshop(<span class="string">'Suzy'</span>)</span><br><span class="line"></span><br><span class="line">deepJS.ask(<span class="string">"Is 'prototype' a class?"</span>) <span class="comment">// Kyle Is 'prototype' a class?</span></span><br><span class="line">reactJS.ask(<span class="string">"Isn't 'prototype' ugly?"</span>) <span class="comment">// Suzy Isn't 'prototype' ugly?</span></span><br></pre></td></tr></table></figure>
<h3 id="The-Prototype-Chain"><a href="#The-Prototype-Chain" class="headerlink" title="The Prototype Chain"></a>The Prototype Chain</h3><blockquote>
<p>几乎所有的 JavaScript 对象都是 Object 的实例；一个典型的对象继承了Object.prototype的属性（包括方法），尽管这些属性可能被遮蔽（亦称为覆盖）。但是有时候可能故意创建不具有典型原型链继承的对象，比如通过Object.create(null)创建的对象，或者通过Object.setPrototypeOf方法改变原型链。<br>改变Object原型，会通过原型链改变所有对象；除非在原型链中进一步覆盖受这些变化影响的属性和方法。这提供了一个非常强大的、但有潜在危险的机制来覆盖或扩展对象行为。</p>
</blockquote>
<h3 id="Dunder-Prototypes-proto"><a href="#Dunder-Prototypes-proto" class="headerlink" title="Dunder Prototypes(proto)"></a>Dunder Prototypes(<strong>proto</strong>)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Workshop</span>(<span class="params">teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.teacher = teacher</span><br><span class="line">&#125;</span><br><span class="line">Workshop.prototype.ask = <span class="function"><span class="keyword">function</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deepJS = <span class="keyword">new</span> Workshop(<span class="string">'Kyle'</span>)</span><br><span class="line"></span><br><span class="line">deepJS.constructor === Workshop <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">deepJS.__proto__ === Workshop.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(deepJS) === Workshop.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Object.prototype 的 <code>__proto__</code>  属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部[[Prototype]] (一个对象或 <code>null</code>)。<br>使用<strong>proto</strong>是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。<strong>proto</strong>属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 现在更推荐使用<code>Object.getPrototypeOf</code>/<code>Reflect.getPrototypeOf</code> 和<code>Object.setPrototypeOf</code>/<code>Reflect.setPrototypeOf</code>（尽管如此，设置对象的<code>[[Prototype]]</code>是一个缓慢的操作，如果性能是一个问题，应该避免）。<br><code>__proto__</code>属性也可以在对象文字定义中使用对象<code>[[Prototype]]</code>来创建，作为<code>Object.create()</code>的一个替代。 请参阅： object initializer / literal syntax.</p>
</blockquote>
<p>通过上述mdn对于<code>__proto__</code>的说明，其实所有对象的<code>__proto__</code>指向了<code>Object.prototype.__proto__</code>，这是一个访问器属性（函数），函数通过实例对象调用，就指向了实例对象的执行上下文，也就是操作了实例对象的prototype属性。</p>
<p>注意，箭头函数没有prototype属性。</p>
<h3 id="Shadowing-Prototype"><a href="#Shadowing-Prototype" class="headerlink" title="Shadowing Prototype"></a>Shadowing Prototype</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Workshop</span>(<span class="params">teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.teacher = teacher</span><br><span class="line">&#125;</span><br><span class="line">Workshop.prototype.ask = <span class="function"><span class="keyword">function</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deepJS = <span class="keyword">new</span> Workshop(<span class="string">'Kyle'</span>)</span><br><span class="line">deepJS.ask = <span class="function"><span class="keyword">function</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.ask(question.toUpperCase())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deepJS.ask(<span class="string">'Oops,is this infinite recursion?'</span>) <span class="comment">// Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>
<h3 id="Prototypal-Inheritance"><a href="#Prototypal-Inheritance" class="headerlink" title="Prototypal Inheritance"></a>Prototypal Inheritance</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Workshop</span>(<span class="params">teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.teacher = teacher</span><br><span class="line">&#125;</span><br><span class="line">Workshop.prototype.ask = <span class="function"><span class="keyword">function</span>(<span class="params">question</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherWorkshop</span>(<span class="params">teacher</span>) </span>&#123;</span><br><span class="line">  Workshop.call(<span class="keyword">this</span>, teacher) <span class="comment">// 使用call绑定this指向AnotherWorkshop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AnotherWorkshop.prototype = <span class="built_in">Object</span>.create(Workshop.prototype) <span class="comment">// 使用Object.create继承Workshop.prototype</span></span><br><span class="line">AnotherWorkshop.prototype.speakUp = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.ask(msg.toUpperCase())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> JSRecentParts = <span class="keyword">new</span> AnotherWorkshop(<span class="string">'Kyle'</span>)</span><br><span class="line"></span><br><span class="line">JSRecentParts.speakUp(<span class="string">'Is this actually inheritance?'</span>) <span class="comment">// Kyle IS THIS ACTUALLY INHERITANCE?</span></span><br></pre></td></tr></table></figure>
<h3 id="Classical-vs-Prototypal-Inheritance"><a href="#Classical-vs-Prototypal-Inheritance" class="headerlink" title="Classical vs Prototypal Inheritance"></a>Classical vs Prototypal Inheritance</h3><p>在传统的面向对象语言中，实例复制了公共的属性方法。在js中，实例连接到了存储着公共属性及方法的对象。所以js的设计模式与传统的面相对象语言的设计模式并不相同。</p>
<h3 id="Inheritance-is-Delegation"><a href="#Inheritance-is-Delegation" class="headerlink" title="Inheritance is Delegation"></a>Inheritance is Delegation</h3><p>在js的设计模式并不是“继承”，更像是“委托”。js使用原型系统或者说委托系统，而不是类系统或者说继承系统。</p>
<h3 id="OLOO-Objects-Linked-to-Other-Objects-Pattern"><a href="#OLOO-Objects-Linked-to-Other-Objects-Pattern" class="headerlink" title="OLOO(Objects Linked to Other Objects) Pattern"></a>OLOO(Objects Linked to Other Objects) Pattern</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Workshop = &#123;</span><br><span class="line">  setTeacher(teacher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.teacher = teacher</span><br><span class="line">  &#125;,</span><br><span class="line">  ask(question) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.teacher, question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AnotherWorkshop = <span class="built_in">Object</span>.assign(</span><br><span class="line">  <span class="built_in">Object</span>.create(Workshop),</span><br><span class="line">  &#123;</span><br><span class="line">    speakUp(msg) &#123;</span><br><span class="line">      <span class="keyword">this</span>.ask(msg.toUpperCase())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deepJS = <span class="built_in">Object</span>.create(AnotherWorkshop)</span><br><span class="line">deepJS.setTeacher(<span class="string">'Kyle'</span>)</span><br><span class="line">deepJS.speakUp(<span class="string">'But is not this cleaner'</span>) <span class="comment">// Kyle BUT IS NOT THIS CLEANER</span></span><br></pre></td></tr></table></figure>
<p><code>Object.create()</code>的polyfill:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = object</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Delegation-Orienten-Design"><a href="#Delegation-Orienten-Design" class="headerlink" title="Delegation-Orienten Design"></a>Delegation-Orienten Design</h3><p>设计模式并不仅仅影响我们组织代码的方式，也指导着我们编写代码的思维模式。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/JavaScript-the-Hard-Part学习笔记/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/22/JavaScript-the-Hard-Part学习笔记/" class="post-title-link" itemprop="url">JavaScript The Hard Part</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-22 23:20:13" itemprop="dateCreated datePublished" datetime="2019-04-22T23:20:13+08:00">2019-04-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-29 11:43:36" itemprop="dateModified" datetime="2019-04-29T11:43:36+08:00">2019-04-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文为学习笔记，来源FrontEndMasters的同名课程，中间加入了个人理解，以备将来复习。</p>
<h2 id="成为世界级工程师的五个原则"><a href="#成为世界级工程师的五个原则" class="headerlink" title="成为世界级工程师的五个原则"></a>成为世界级工程师的五个原则</h2><ol>
<li>Analytical problem solving with code<blockquote>
<p>分析问题并用代码解决的能力</p>
</blockquote>
</li>
<li>Technical communication （can I implement your approach just from your explanation）<blockquote>
<p>技术表达交流的能力（我能只通过看你的文档就能实现相应的功能吗）</p>
</blockquote>
</li>
<li>Engineering best practices and approach （Debugging，code structure,patience and reference to documentation)<blockquote>
<p>工程最佳实践和方法(调试、代码结构、耐心和参考文档)</p>
</blockquote>
</li>
<li>Non-technical communication(empathetic and thoughtful communication)<blockquote>
<p>非技术交流(有同理心、有思想的交流)</p>
</blockquote>
</li>
<li>Language and computer science experience<blockquote>
<p>语言和计算机科学经验<br>其重要性依次排列</p>
</blockquote>
</li>
</ol>
<h2 id="JavaScript的基本原则-Principles-of-JavaScript"><a href="#JavaScript的基本原则-Principles-of-JavaScript" class="headerlink" title="JavaScript的基本原则(Principles of JavaScript)"></a>JavaScript的基本原则(Principles of JavaScript)</h2><p>传统的编译型语言逐行执行代码，现在js使用所谓的<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">及时汇编(Just In Time Compilation)</a>，至少是在Chrome编译执行时是这样（v8引擎的特性），但基本上也是逐行解析的。</p>
<p>如果我们自己解析存储数据，转换数据，并且逐行运行代码，那么就可以理解所有的js代码。</p>
<p>js不会初始化函数体内的代码，直到函数被调用。直到函数被调用之前，函数体内的代码没有意义。所以在函数执行前不要进入函数体，永远！线程或进程永远不会再函数调用之前执行函数体内的代码。只有在函数被调用时，线程或进程才会进入函数体内执行函数体内的代码。（所以其实函数是个锦囊？在满足条件前你也不知道锦囊里写了啥，因为锦囊有可能永远用不到，当满足条件，我们就打开锦囊，按照锦囊里的办法处理当前情况，所以是不是闭包也可以跟锦囊联系起来？我们打开一个锦囊，用完就扔了。但是如果锦囊里面有个锦囊，说我有可能用到（被外部引用），而且你得照着外面锦囊里说的啥啥啥来办，那么这两个锦囊都扔不了）。</p>
<h3 id="全局执行上下文-global-execution-context"><a href="#全局执行上下文-global-execution-context" class="headerlink" title="全局执行上下文(global execution context)"></a>全局执行上下文(global execution context)</h3><p>我们开始运行代码时，开始创建全局执行上下文。执行上下文是一个比较唬人的名词，但是表示了两个简单的事。</p>
<ul>
<li>执行线程（一行行的转化并执行代码）</li>
<li>创建内存空间存储变量及数据</li>
</ul>
<p>这是全局执行上下文，在文件刚刚开始运行时创建，是一个全局环境。</p>
<h3 id="js中的线程-Thread"><a href="#js中的线程-Thread" class="headerlink" title="js中的线程(Thread)"></a>js中的线程(Thread)</h3><ul>
<li>Single thread(one thing at a time)</li>
<li>Synchronous ececution(for now)</li>
</ul>
<p>众所周知，js是单线程的，既只有一个线程，也就是只能同时做一件事。那么执行顺序呢？同步进行，既一步一步，顺序执行，不会跳过当前的代码。</p>
<h3 id="本地执行上下文-local-execution-context"><a href="#本地执行上下文-local-execution-context" class="headerlink" title="本地执行上下文(local execution context)"></a>本地执行上下文(local execution context)</h3><p>调用函数(running/calling/invoking a functiong)与定义一个函数不同</p>
<p>当我们定义函数时，加上function关键字即可，当我们调用函数时，要在函数体后加上括号。（为了避免每次调用就重新写一遍函数，我们给函数命名一遍重复调用。并且因为不知道何时调用，我们暂时把函数体的代码放在内存中，当调用时直接访问内存，调用内存中的代码即可，所以如果我们想立即执行函数，可以直接把函数包起来，直接加括号调用，就是立即执行函数，应为垃圾回收机制，我们只想执行一次函数，用完就销毁，就可以不给函数命名，这样函数在内存中就没有其他引用，再直接加括号，那么函数执行完之后就会因为没有其他引用被垃圾回收机制销毁，这应该就是匿名立即执行函数）</p>
<p>当我们调用一个函数时，就创建了由以下两点组成的一个新的执行上下文(creat a new execution context comprising)：</p>
<ol>
<li>执行线程(thread of execution)，在函数内逐行解析代码。</li>
<li>一个本地存储空间(local memory){变量环境(Variable environment)}，其中存储函数中定义的任何内容。</li>
</ol>
<p>函数在执行结束前，返回的值就是undefined，函数内只定义了操作数据的方法，在执行结束后，才知道经过函数操作的数据内容也就是函数的返回值。函数并不关心输入与输出，函数本身只定义了方法。分析一个函数式，可以通过画图，左侧是线程区，右侧是内存区，代码沿着线程区顺序执行，在内存区存储相应的变量。</p>
<p>函数体内没有函数时，一切都很简单。但是，如果函数内调用了另一个函数，如果递归的调用函数呢？我们怎么追踪他们呢？</p>
<p>通过调用堆栈。</p>
<h3 id="调用堆栈-Call-Stack"><a href="#调用堆栈-Call-Stack" class="headerlink" title="调用堆栈(Call Stack)"></a>调用堆栈(Call Stack)</h3><p>调用堆栈是一种特殊的数据结构，是一种存储数据信息的存储方式。一种能够使我们追踪到我们现在进行到哪，js现在解析到哪，线程现在执行到哪的特殊数据结构。</p>
<p>调用堆栈遵循先进后出的原则（可以看做一个桶，最先放入的最后拿出），全局执行上下文首先进入调用堆栈 <strong>（在调用堆栈的最上方就是js线程当前执行的环境）</strong> 。通过这个调用堆栈先进后出的这个机制，js解析器不用关心具体执行代码的所在位置，只关心调用堆栈最上方的执行上下文即可。当函数执行完毕时，执行上下文销毁，此时调用堆栈就回到了全局执行上下文。那么，把一个执行上下文添加到调用堆栈怎么说呢，<strong>pushing</strong>。怎么知道函数执行完毕呢（没有return的情况下），当线程执行完函数体内代码({}号内的代码)，会默认return一个undefined（这也是Chrome console中会不显式返回的情况下输出undefined的原因，既隐式返回了undefined）。把一个执行上下文从堆栈中删除怎么说呢，<strong>poping</strong>。</p>
<p>总结一下，当执行一个函数时，你创建了一个新的执行上下文，这个执行上下文包含一个线程，他逐行执行函数体内的代码，此时也开辟了一个局部存储空间(local memory)，用来存储任何不在全局存储空间(global memory)的变量及数据。此时，将这个执行上下文推到调用堆栈的顶部，js就会执行这个函数，执行完毕后，会将这个执行上下文推出调用堆栈，js继续执行调用堆栈顶部的执行上下文（既当前执行上下文的前一个执行上下文）。</p>
<p>这个本地存储空间(local memory)有一个学术化的名称–<strong>可变环境(environment of available variants)</strong>。</p>
<p>当我们定义一个函数时，我们只是在内存中开辟了一段空间存储定义函数的代码，所以如果console.log(函数名)，就会输出定义函数的代码(试验了一下，发现箭头函数和普通函数的输出内容并不一样，说明两者并不同)。</p>
<h3 id="三个基本元素"><a href="#三个基本元素" class="headerlink" title="三个基本元素"></a>三个基本元素</h3><p>执行上下文(execution context)，线程(thread)，调用堆栈(call stack)</p>
<p>深入了解js执行机制，不是出于理论目的，不是为了求知欲，我们了解这些是因为这些可以帮助我们debug，写一些干净的代码，使我们的想法实现的可能性更高。我们只需要了解其特性，并不需要我们了解具体如何实现，应为这对我们编程并没有影响。</p>
<h2 id="函数式编程-Funcitional-Programming"><a href="#函数式编程-Funcitional-Programming" class="headerlink" title="函数式编程(Funcitional Programming)"></a>函数式编程(Funcitional Programming)</h2><h3 id="纯粹的函数-Pure-Functions"><a href="#纯粹的函数-Pure-Functions" class="headerlink" title="纯粹的函数(Pure Functions)"></a>纯粹的函数(Pure Functions)</h3><p>函数式编程是一种编程范式，关于我们构建和思考如何大规模编写代码的方式。一般我们认为代码质量的评判标准是效率和性能，实际上评判代码的好坏更多的是其他开发人员是否能够快速读懂并添加功能。<br>在过去，最流行的编程范式是面相对象编程(OOP)，函数式编程是另一种构建代码的方式。<br>函数式编程有两个核心原则：</p>
<ul>
<li>纯粹的函数（没有副作用）<blockquote>
<p>Pure functions(no side effects)</p>
</blockquote>
</li>
<li>高阶函数<blockquote>
<p>Higher order functions - highly valuable tool &amp; often part of the Codesmith interview</p>
</blockquote>
</li>
</ul>
<p>纯粹函数追求的是除了函数的return值之外不改变其他任何值，函数中只存在用完即销毁的局部变量，函数内部没有改变(mutating)任何全局变量或不是函数内的变量。当我们改变了任何不属于函数内部的变量，会使得我们测试我们代码更加困难，增加了需要测试的范围。但是当函数除了返回值之外不做任何其他事，那么就可以在测试时只关心返回值得内容。</p>
<p>作为一个软件工程师，我们有函数，所以，Don’t repeat yourself.函数出现的原因就是我们想要重复使用相同的功能，我们把他封装起来，通过一个标志来在需要的时候找到并引用它，这样，我们就可以只写一次，可以重复使用多次。这不仅仅是因为我们懒惰，更是为了写出更多可读的代码，可以重用的代码。我们不想要在需要修改同一个功能时修改多处，有了函数，我们只要修改一次。</p>
<p>函数有定义阶段和调用阶段，定义阶段，我们把函数的参数叫为形参(parameter)，就像二元一次方程中的x，是一个未知数。在调用阶段，我们会给函数一个实参(argument)，此时就是二元一次方程中明确告诉了x的值，只需要代入算式即可。所以其实形参只是一个占位符(placeholder)，代表了可能会传入函数的值，我们定义函数如何对占位符进行操作，在传入具体的参数时，我们只需要将具体值带入占位符即可。既然形参是一个站位符，那么我们是不是可以留一个占位符，代表了一些特定的功能，这个功能的返回值目前还不知道，只有调用这个功能时才能确认这个返回值呢？功能的英文就是function，翻译一下，就是我们的返回值是不是可以是一个函数？所以这个占位符代表的不是具体的数据，而是一个功能，这个函数目前没有返回值，因为只是定义没有调用，只有调用时，才能知道返回值。这应该就是高阶函数的本质。</p>
<h2 id="回调函数和高阶函数-callbacks-and-high-order-functions"><a href="#回调函数和高阶函数-callbacks-and-high-order-functions" class="headerlink" title="回调函数和高阶函数(callbacks and high order functions)"></a>回调函数和高阶函数(callbacks and high order functions)</h2><p>下面我们要进入一个精彩的编程世界。</p>
<p>下面是一个列表</p>
<ul>
<li>I know what a variable is<blockquote>
<p>我知道什么是变量</p>
</blockquote>
</li>
<li>I’ve creat a function before<blockquote>
<p>我之前写过一个函数</p>
</blockquote>
</li>
<li>I’ve add a CSS style before<blockquote>
<p>我之前写过一个CSS样式</p>
</blockquote>
</li>
<li>I’ve implement a sort algorithm(bubble,merge,etc)<blockquote>
<p>我之前完成过一个排序算法（冒泡、并归排序等）</p>
</blockquote>
</li>
<li>I can add a method to an object’s prototype<blockquote>
<p>我能在一个对象的原型上添加方法</p>
</blockquote>
</li>
<li>I understand the event loop in JavaScript<blockquote>
<p>我理解JavaScript的事件循环</p>
</blockquote>
</li>
<li>I understand callback functions<blockquote>
<p>我理解回调函数</p>
</blockquote>
</li>
<li>I’ve built a project in React or Angular<blockquote>
<p>我写过一个React或Angular项目</p>
</blockquote>
</li>
<li>I can handle collisions in hash tables<blockquote>
<p>我可以处理哈希表中的冲突</p>
</blockquote>
</li>
</ul>
<p>通过判断列表中所掌握的项目数量，我们可以给自己打一个分数（共九项，一至九分）。</p>
<p>这里提出了一个概念，成为一个初级开发人员相对容易，但是想要成为一个能够自主解决中级或高级问题的开发人员很难，这中间有一个陡峭的学习难度趋势图。</p>
<blockquote>
<p>我认为既是遵循了帕累托的二八原则，既想要获得百分之八十的成果需要百分之二十的努力，但想要获得剩余百分之二十的成果需要付出百分之八十的努力。</p>
</blockquote>
<h3 id="学习困难的事"><a href="#学习困难的事" class="headerlink" title="学习困难的事"></a>学习困难的事</h3><p>在刚开始，我们只需要学习一些简单的事情即可成为一个”初级“开发者，但是要成为一个”高级开发者“，我们要学习一些难度很大的知识。就像完成一个edX课程并做完所有测试，或者Coursera的课程。当我们遇到了一个难题，我们的大脑会尝试让我们转移我们的注意力，去喝杯咖啡或者什么，但这就是我们成长的过程，必不可少。在我们学习困难的事(hard learning)时我们很容易想到放弃，但学习困难的事让我们成长。</p>
<p>即使我们没有放弃学习困难的事(刚开始我理解为努力学习，但我觉得并不准确，暂时就用学习困难的事理解)，我们仍面临两种选择。</p>
<p>在我们学习困难的事的过程中，例如LeetCode刷题或者看一个复杂项目的官方文档，你会发现你练单词都看不懂，例如LeetCode题意是啥都不明白，webpack的插件(plugin)和loading等概念。我们会做什么，我们可能会花一天时间去研究相关概念，在一天的结束时甚至没有敲一行代码，这就落入了一个<strong>研究者陷阱</strong>。</p>
<p>另一种，Stack Overflow型，我们遇见问题，去社区提问，有人之前遇到过，解决代码是这样，好，复制粘贴。什么？还是有问题？再找一个帖子，帖子里有另一段代码，复制粘贴，看看能不能解决问题。什么？还是不行。好吧，把问题和这两段代码一起发到社区上问问别人。这算是一种<strong>Stack Overflow方法</strong>。此时我们只是努力让程序正常跑起来，但是并不知道具体怎么跑起来的。</p>
<p>这里提出了结对编程的解决方案。在之前的两种情况中（一种我必须了解一切，一种我只是想让他发挥作用）折中的方案。结对编程的核心原则就是自己不写代码，而是由你像与你水平相当的小伙伴解释你的伪代码，让你的小伙伴来负责具体的代码实现。那么，如果想要解释清楚，就必须理解你的伪代码，但是也不需要理解的特别深入，因为你的小伙伴在等待你的解释。你也不能直接开始写代码，你的目的是通过代码逐行说话，把他变成实际的代码。所以你只能在这两种情况的中间（必须了解一切，但永远不会make hands dirty；什么都不懂，但是一直在敲自己不懂的代码来实现功能）。就像飞驰人生里的拉力赛，有一个领航员，一个车手，领航员负责指路，车手负责开车。实际也就是把分析写出伪代码和代码实现交给两个人，这样就可以使得每个人只专注与自己的部分，就像画画先画出轮廓，再填充细节，画轮廓时应该只关心轮廓，画细节时只关心当前部分的细节。而不是注意力来回跳转（话说有人似乎这么画画，但这不是我们选择的方式）。</p>
<h3 id="回调和高阶函数练习"><a href="#回调和高阶函数练习" class="headerlink" title="回调和高阶函数练习"></a>回调和高阶函数练习</h3><blockquote>
<p><a href="http://csbin.io/callbacks" target="_blank" rel="noopener">callbacks</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type JavaScript here and click "Run Code" or press Ctrl + s</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello, world!'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 1</span></span><br><span class="line"><span class="comment">// Create a function addTwo that accepts one input and adds 2 to it.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To check if you've completed it, uncomment these console.logs!</span></span><br><span class="line"><span class="comment">// console.log(addTwo(3));</span></span><br><span class="line"><span class="comment">// console.log(addTwo(10));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 2</span></span><br><span class="line"><span class="comment">// Create a function addS that accepts one input and adds an "s" to it.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addS</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> word += <span class="string">'s'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uncomment these to check your work</span></span><br><span class="line"><span class="built_in">console</span>.log(addS(<span class="string">'pizza'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(addS(<span class="string">'bagel'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Create a function called map that takes two inputs:</span></span><br><span class="line"><span class="comment">1.an array of numbers (a list of numbers)</span></span><br><span class="line"><span class="comment">2.a 'callback' function - a function that is applied to each element of the array (inside of the function 'map')</span></span><br><span class="line"><span class="comment">Have map return a new array filled with numbers that are the result of using the 'callback' function on each element of the input array.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">array, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []<span class="comment">// 创建一个新数组，最后返回这个数组</span></span><br><span class="line">  <span class="comment">// 遍历传入的数组，并将每一项经callback处理后添加到新数组中</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    arr.push(callback(array[i]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr<span class="comment">// 返回处理过的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], addTwo));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 4</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The function forEach takes an array and a callback, and runs the callback on each element of the array. forEach does not return anything.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; array.length; i++)&#123;</span><br><span class="line">    array[i] = callback(array[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// see for yourself if your forEach works!</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">forEach(arr3,addTwo)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`forEach <span class="subst">$&#123;arr3&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------</span></span><br><span class="line"><span class="comment">// Extension</span></span><br><span class="line"><span class="comment">//--------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Extension 1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  In the first part of the extension, you're going to rebuild map as mapWith. This time you're going to use forEach inside of mapWith instead of using a for loop.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapWith</span>(<span class="params">array, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [] <span class="comment">// 创建一个新数组</span></span><br><span class="line">  forEach(array, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="comment">// 使用forEach遍历数组</span></span><br><span class="line">    arr.push(callback(item)) <span class="comment">// 遍历时把数组的每一项都经callback处理后添加到新数组中</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr <span class="comment">// 返回新数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`mapWith <span class="subst">$&#123;mapWith([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], addTwo)&#125;</span>`</span>)</span><br><span class="line"><span class="comment">//Extension 2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The function reduce takes an array and reduces the elements to a single value. For example it can sum all the numbers, multiply them, or any operation that you can put into a function.</span></span><br><span class="line"><span class="comment">    var nums = [4, 1, 3];</span></span><br><span class="line"><span class="comment">    var add = function(a, b) &#123; return a + b; &#125;</span></span><br><span class="line"><span class="comment">    reduce(nums, add, 0);   //-&gt; 8</span></span><br><span class="line"><span class="comment">    0 + 4 = 4 =&gt; 4 + 1 = 5 =&gt; 5 + 3 = 8</span></span><br><span class="line"><span class="comment">  Here's how it works. The function has an "accumulator value" which starts as the initialValue and accumulates the output of each loop. The array is iterated over, passing the accumulator and the next array element as arguments to the callback. The callback's return value becomes the new accumulator value. The next loop executes with this new accumulator value. In the example above, the accumulator begins at 0. add(0,4) is called. The accumulator's value is now 4. Then add(4, 1) to make it 5. Finally add(5, 3) brings it to 8, which is returned.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">array, callback, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> total = initialValue <span class="comment">// 创建一个变量，记录最后的结果</span></span><br><span class="line">  forEach(array,item =&gt; &#123; <span class="comment">// 遍历输入的数组</span></span><br><span class="line">    total = callback(item, total) <span class="comment">// 计算经callback处理后的当前项和前一项的值，保存在total中</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> total <span class="comment">// 返回最终结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(reduce(nums, add, <span class="number">0</span>))</span><br><span class="line"><span class="comment">//Extension 3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Construct a function intersection that compares input arrays and returns a new array with elements found in all of the inputs. BONUS: Use reduce!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">arrays</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrs = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>) <span class="comment">// 先把实参转化为数组</span></span><br><span class="line">  <span class="keyword">return</span> reduce(arrs, (previous, next) =&gt; &#123; <span class="comment">// 遍历实参的每一项，对上次操作的结果和当前项进行操作，得出结果，供下一次循环与下一项一同传入函数进行操作</span></span><br><span class="line">    <span class="keyword">const</span> arr = [] <span class="comment">// 定义一个变量，存储交集数组</span></span><br><span class="line">    <span class="keyword">if</span> (previous.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="comment">// 因为初始化值是空的，直接跳到下一项，此时previous代表第一项，next是参数第二项</span></span><br><span class="line">    forEach(next, item =&gt; &#123; <span class="comment">// 对第二项进行遍历</span></span><br><span class="line">      <span class="keyword">if</span>(previous.includes(item))&#123; <span class="comment">// 如果第二项的值包含在第一项中</span></span><br><span class="line">        arr.push(item) <span class="comment">// 把值添加到交集数组</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr<span class="comment">// 返回交集数组供下一次操作使用，下次执行时，previous为第二项，next为第三项</span></span><br><span class="line">  &#125;,[]) <span class="comment">// 返回最终的交集数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(intersection([<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>], [<span class="number">15</span>, <span class="number">88</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">20</span>]));</span><br><span class="line"><span class="comment">// should log: [5, 15]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Extension 4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">arrays</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrs = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>) <span class="comment">// 把实参转化为数组</span></span><br><span class="line">  <span class="comment">// 使用reduce函数，输入这个数组，传入一个callback处理这个数组，返回一个新数组</span></span><br><span class="line">  <span class="keyword">return</span> reduce(arrs, (previous, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 传入两个数组，进行去重</span></span><br><span class="line">    forEach(next, item =&gt; &#123;  <span class="comment">// 遍历第二个数组，此时previous为空数组，next为实参的第一个数组</span></span><br><span class="line">      <span class="keyword">if</span>(!previous.includes(item)) &#123; <span class="comment">// 如果在第一个数组中不包含第二个数组的这一项</span></span><br><span class="line">        previous.push(item) <span class="comment">// 就添加到第一个数组中</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> previous<span class="comment">// 最终返回一个数组，数组中没有重复的项，下次调用时previous为此数组，next为实参的第二个数组</span></span><br><span class="line">  &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(union([5, 10, 15], [15, 88, 1, 5, 7], [100, 15, 10, 1, 5]));</span></span><br><span class="line"><span class="comment">// should log: [5, 10, 15, 88, 1, 7, 100]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Extension 5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objOfMatches</span>(<span class="params">array1, array2, callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(objOfMatches(['hi', 'howdy', 'bye', 'later', 'hello'], ['HI', 'Howdy', 'BYE', 'LATER', 'hello'], function(str) &#123; return str.toUpperCase(); &#125;));</span></span><br><span class="line"><span class="comment">// should log: &#123; hi: 'HI', bye: 'BYE', later: 'LATER' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Extension 6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiMap</span>(<span class="params">arrVals, arrCallbacks</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(multiMap(['catfood', 'glue', 'beer'], [function(str) &#123; return str.toUpperCase(); &#125;, function(str) &#123; return str[0].toUpperCase() + str.slice(1).toLowerCase(); &#125;, function(str) &#123; return str + str; &#125;]));</span></span><br><span class="line"><span class="comment">// should log: &#123; catfood: ['CATFOOD', 'Catfood', 'catfoodcatfood'], glue: ['GLUE', 'Glue', 'glueglue'], beer: ['BEER', 'Beer', 'beerbeer'] &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="关于const和let"><a href="#关于const和let" class="headerlink" title="关于const和let"></a>关于const和let</h3><p>我们应该尽量使用const定义变量，除非我们知道我们想要改变这个变量的值（重新给这个变量分配新的数据）。</p>
<h3 id="广义函数-generalizing-functiongs"><a href="#广义函数-generalizing-functiongs" class="headerlink" title="广义函数(generalizing functiongs)"></a>广义函数(generalizing functiongs)</h3><p>这里举了个例子，我们写了一个function，给输入的数组每一项乘以2，返回一个处理后的数组；又写了一个function，给输入数组每一项加上2，返回一个处理后的数组；再写一个，给每一项除以2，返回一个处理后的数组。可以看出，function其他部分都一样，你要新建一个数组，给每一项加上/乘以/除以二，返回一个新数组。</p>
<p>那么，我们就违反了一个编程原则：Don’t repeat your self!</p>
<h3 id="解构广义函数-deconstructing-generalize-function"><a href="#解构广义函数-deconstructing-generalize-function" class="headerlink" title="解构广义函数(deconstructing generalize function)"></a>解构广义函数(deconstructing generalize function)</h3><p>我们可以把对每一项的处理变成一个函数，但是这个函数是不确定的，需要我们作为参数传入传入，只有在函数执行时，才知道传入的函数是什么，这就是callback。</p>
<p>在上面的例子中，我们把对每一项的处理的部分用一个占位符代替（callback），并在占位符后加括号代表这是一个function（函数），把需要处理的项作为实参传递到函数中。但是在执行这段代码前，这只是一个占位符。</p>
<p>在函数外部，我们定义一个函数，有一个形参，函数体内写入我们想要如何操作这个形参的代码，在这个阶段，函数体内的代码也没有执行，只是进行了定义。</p>
<p>最后，我们调用第一个函数，传入数据和第二个函数。在执行到处理数据的每一项时，每次处理js就执行第二个函数，把每一项作为实参传入第二个参数，返回一个新的值，添加到新数组中。</p>
<p>通过这种方法，我们降低了代码的耦合性，是的代码的复用度更高。</p>
<p>在问答环节，强调了函数的变量名只是一个占位符，并没有具体的值，只有在执行时才会发挥作用。</p>
<h3 id="第一等对象-first-class-object"><a href="#第一等对象-first-class-object" class="headerlink" title="第一等对象(first-class object)"></a>第一等对象(first-class object)</h3><p>在js中，functions是第一等对象(frist-class objects)，这意味着函数像对象一样，我们可以传递一个对象作为函数的参数，那么，我们当然也可以传递一个函数作为参数。在js中，只有七种数据类型，其中六种是基本数据类型（Number、String、Null、Undefined、Boolean、Symbol）,一种复杂数据类型（Object），Array、Date、RegExp、Function都是Object的一种，是引用类型。传递基本类型是，我们直接传递基本类型的值，传递复杂数据类型或叫引用数据类型时，我们传递的是引用（指针）。</p>
<p>函数作为引用类型，可以直接把指针分配给变量，称作函数表达式，也可以作为其他对象的属性，此时我们一般把这个函数叫做这个对象的方法，函数还可以作为其他函数的参数，这些都是因为函数是一种对象，是一个引用类型，可以把指针进行传递，在需要的时候进行调用。</p>
<p>这就是函数在js中最为美妙的部分。</p>
<p>函数与相对于普通对象，有个一美妙的特性，你可以使用()调用。</p>
<h3 id="回调与高阶函数-callbacks-and-high-order-functions"><a href="#回调与高阶函数-callbacks-and-high-order-functions" class="headerlink" title="回调与高阶函数(callbacks and high order functions)"></a>回调与高阶函数(callbacks and high order functions)</h3><p>我们传递给外部函数作为参数的函数叫做回调函数，接收这个函数作为参数的外部函数叫做高阶函数（他接受了一个函数，可以在函数内部实现其他函数的功能，所以级别比一个普通函数更高）。</p>
<p>接受一个函数作为参数或者返回一个函数作为输出结果的函数叫做高阶函数。</p>
<p>这只是描述这些函数的一个术语 - 我们把有这些行为（函数作为参数或返回一个函数）的函数叫做高阶函数 - 但是它们与普通函数本质上没有什么不同。</p>
<p>那么，既然高阶函数跟普通函数没有什么不同，为什么要提出这么一个概念呢？</p>
<p>高阶函数简化了我们的代码，使他们更加易读。(So callbacks and high order functions simplify our code and keep it DRY)</p>
<p>通过上面的例子我们可以清晰地看到这一点。</p>
<p>并且，高阶函数有更为强大的应用。(and they do something even powerful)</p>
<p>通过高阶函数，我们可以异步执行代码。(they allow us to run asynchronous code)</p>
<h2 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h2><p>当我们使用括号调用一个函数时，我们创建了一个变量环境(variable environment)，一般称作本地存储空间(local memory)，用于存储函数内定义的变量（本地变量，arguments等）。当函数执行完毕时，函数创建的执行上下文被调用栈推出，变量环境被销毁，<strong>除了函数的返回值</strong>。除了函数的返回值，函数的所创建的其他数据被垃圾回收机制回收删除，释放所占用的内存。那么，有没有一种办法能够在函数调用之前就保存一些数据呢？在一些情况下，我们希望函数能够保存一些数据，而不是每次都创建新的数据并在结束时全部回收（复杂计算的结果，之前运行的次数等情况）。这就是闭包存在的价值，他改变了我们编写代码的方式。这一切都从在一个函数内返回另一个函数开始。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a function createFunction that creates and returns a function. When that created function is called, it should print "hello".</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNCOMMENT THESE TO TEST YOUR WORK!</span></span><br><span class="line"><span class="keyword">var</span> function1 = createFunction();</span><br><span class="line">function1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a function createFunctionPrinter that accepts one input and returns a function. When that created function is called, it should print out the input that was used when the function was created.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionPrinter</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(input)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNCOMMENT THESE TO TEST YOUR WORK!</span></span><br><span class="line"><span class="keyword">var</span> printSample = createFunctionPrinter(<span class="string">'sample'</span>);</span><br><span class="line">printSample();</span><br><span class="line"><span class="keyword">var</span> printHello = createFunctionPrinter(<span class="string">'hello'</span>);</span><br><span class="line">printHello();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Examine the code for the outer function. Notice that we are returning a function and that function is using variables that are outside of its scope.</span></span><br><span class="line"><span class="comment">  Uncomment those lines of code. Try to deduce the output before executing.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>; <span class="comment">// this variable is outside incrementCounter's scope</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">incrementCounter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter ++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'counter'</span>, counter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> incrementCounter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> willCounter = outer();</span><br><span class="line"><span class="keyword">var</span> jasCounter = outer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncomment each of these lines one by one.</span></span><br><span class="line"><span class="comment">// Before your do, guess what will be logged from each function call.</span></span><br><span class="line"></span><br><span class="line">willCounter();<span class="comment">//1</span></span><br><span class="line">willCounter();<span class="comment">//2</span></span><br><span class="line">willCounter();<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">jasCounter();<span class="comment">//1</span></span><br><span class="line">willCounter();<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Now we are going to create a function addByX that returns a function that will add an input by x.</span></span><br><span class="line"><span class="comment">    var addByTwo = addByX(2);</span></span><br><span class="line"><span class="comment">    addByTwo(1); //should return 3</span></span><br><span class="line"><span class="comment">    addByTwo(2); //should return 4</span></span><br><span class="line"><span class="comment">    addByTwo(3); //should return 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    var addByThree = addByX(3);</span></span><br><span class="line"><span class="comment">    addByThree(1); //should return 4</span></span><br><span class="line"><span class="comment">    addByThree(2); //should return 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    var addByFour = addByX(4);</span></span><br><span class="line"><span class="comment">    addByFour(4); //should return 8</span></span><br><span class="line"><span class="comment">    addByFour(10); //should return 14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addByX</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addByTwo = addByX(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now call addByTwo with an input of 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'addByTwo with 1'</span>,addByTwo(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// now call addByTwo with an input of 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'addByTwo with 2'</span>,addByTwo(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------</span></span><br><span class="line"><span class="comment">// Extension</span></span><br><span class="line"><span class="comment">//--------------------------------------------------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write a function once that accepts a callback as input and returns a function. When the returned function is called the first time, it should call the callback and return that output. If it is called any additional times, instead of calling the callback again it will simply return the output value from the first time it was called.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>,</span><br><span class="line">      result = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">      result = func(...arg)</span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onceFunc = once(addByTwo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNCOMMENT THESE TO TEST YOUR WORK!</span></span><br><span class="line"><span class="built_in">console</span>.log(onceFunc(<span class="number">4</span>));  <span class="comment">//should log 6</span></span><br><span class="line"><span class="built_in">console</span>.log(onceFunc(<span class="number">10</span>));  <span class="comment">//should log 6</span></span><br><span class="line"><span class="built_in">console</span>.log(onceFunc(<span class="number">9001</span>));  <span class="comment">//should log 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write a function after that takes the number of times the callback needs to be called before being executed as the first parameter and the callback as the second parameter.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">count, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> innerCount = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(innerCount &lt; count)&#123;</span><br><span class="line">      innerCount += <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      func()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> called = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'hello'</span>) &#125;;</span><br><span class="line"><span class="keyword">var</span> afterCalled = after(<span class="number">3</span>, called);</span><br><span class="line"></span><br><span class="line">afterCalled(); <span class="comment">// -&gt; nothing is printed</span></span><br><span class="line">afterCalled(); <span class="comment">// -&gt; nothing is printed</span></span><br><span class="line">afterCalled(); <span class="comment">// -&gt; 'hello' is printed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write a function delay that accepts a callback as the first parameter and the wait in milliseconds before allowing the callback to be invoked as the second parameter. Any additional arguments after wait are provided to func when it is invoked. HINT: research setTimeout();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  clearTimeout(timeout)</span><br><span class="line">  timeout = setTimeout(func, wait)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<p>当我们调用一个函数，函数创建一个新的执行上下文，并将其推入调用栈的最顶端，使js优先执行。在执行完毕后，会返回一个返回值，然后函数的执行上下文被推出调用栈，执行上下文被垃圾回收机制回收，这是一个函数的生命周期。</p>
<p>但是，当函数返回一个在函数内部定义的函数时，情况变得稍微复杂起来。</p>
<p>当我们定义一个函数时，为了确保该函数能够访问其外部作用域的变量，js保留内部函数对外部函数变量的引用，此时，我们返回的不仅仅是一个函数体的代码，还有对齐定义时所在执行上下文的引用。所以即使外部执行函数已经执行完毕，但返回了内部函数，及内部函数与外部函数局部变量之间的联系。为了保持这种联系，也因为垃圾回收机制的原理，外部函数的变量数据并不会消失，仍保持着与内部函数的联系。但应为外部函数已经执行完毕，所以除了与内部函数之间的联系，通过其他方式无法找到这些数据。所以闭包的特殊之处在于它不仅仅是一个普通函数，还携带了定义时所在执行上下文（外部函数执行上下文）的数据，而且这个数据是存储在全局执行上下文中，但是除了内部函数外没有其他访问方式的。</p>
<p>这是js中最为美妙，最为深刻的概念！</p>
<p>在闭包中，js会保留内部函数引用的数据，回收其他未被引用的数据。复述一遍，我们得到了不止一个函数，还得到了一些因为被引用而保留下来的数据。</p>
<p>我想，这与引用类型传递的是指针而不是值本身有关系。（垃圾回收机制查看内存中那些数据没有被外部引用并进行回收，当我们执行外部函数时，数据被创建在内存中，外部函数执行完毕后，执行上下文被销毁。但是部分数据因为被内部函数引用，内部函数又因为被外部所引用，而保存下来。但是因为数据在外部函数的引用已经被销毁，只保留了内部函数对其的引用，所以只能通过内部函数来进行访问。）</p>
<h3 id="词法作用域-lexical-scope"><a href="#词法作用域-lexical-scope" class="headerlink" title="词法作用域(lexical scope)"></a>词法作用域(lexical scope)</h3><p>定义函数时，它会获得一个[[scope]]属性，该属性引用已定义它的本地内存/变量环境</p>
<blockquote>
<p>When a function is defined, it gets a [[scope]] property that references the Local Memory/Variable<br>Environment in which it has been defined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">incrementCounter</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    counter ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> incrementCounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myNewFunction = outer(); <span class="comment">// myNewFunction = incrementCounter</span></span><br><span class="line">myNewFunction();</span><br><span class="line">myNewFunction();</span><br></pre></td></tr></table></figure>
<p>当我们调用incrementCounter函数时，会首先查找他自己的本地存储空间（变量环境），然后在[[scope]]的next的属性中查找</p>
<blockquote>
<p>Wherever we call that incrementCounter function - it will always look first in its immediate local<br>memory (variable environment), and then in the [[scope]] property next before it looks any further up</p>
</blockquote>
<p>所以是否是因为函数也是一个对象，对象就有属性和方法，每一个函数都是Function的实例，在实例创建时，会有一个[[scope]]属性，这个属性应该也是一个对象，然后在[[scope]]中有一个next属性，指向了其定义时函数的[[scope]]属性。这样就可以沿着这个原型链来访问其中的数据。</p>
<h3 id="JavaScript的静态-词法范围-JavaScript-static-lexical-scoping"><a href="#JavaScript的静态-词法范围-JavaScript-static-lexical-scoping" class="headerlink" title="JavaScript的静态/词法范围(JavaScript static/lexical scoping)"></a>JavaScript的静态/词法范围(JavaScript static/lexical scoping)</h3><p>这就是当我们说JavaScript是词法或静态范围时，所表达的意思<br>我们的词法作用域（函数定义时可以使用的实时数据）决定了函数执行时可以访问的变量以及访问变量的优先顺序，而不是在函数调用时决定可以访问的数据及访问优先级。</p>
<blockquote>
<p>This is what it means when we say JavaScript is lexically or statically scoped<br>Our lexical scope (the available live data when our function was defined) is what determines our available variables and prioritization at function execution, not where our function is called</p>
</blockquote>
<p>当我们定义一个函数时，函数所能访问的数据就会被函数的[[scope]]属性所引用，这样就不会被垃圾回收机制回收，就会被一直保存下来，直到函数被销毁。</p>
<p>所以闭包是一个名词，代表着函数携带的数据，或者叫lexical scope reference。</p>
<p>当我们想访问闭包中的数据时，我们可以通过在内部函数中return来获取数据的指针。</p>
<p>当我们重新执行外部函数时，创建了一个新的执行上下文，返回了一个新的内部函数，如果新的内部函数引用了了新的外部函数执行上下文中的数据，那么显然，是一个新的数据。</p>
<p>在我们定义或者说声明一个函数时，我们给函数创建了一个新的词法作用域，引用了函数可以访问的数据。函数内部如果定义一个函数，同样会创建一个新的词法作用域，当然这个内部函数的词法作用域可以指向外部函数。当我们返回内部函数时，外部函数已经执行完毕，其执行上下文销毁，但是因为内部函数的词法作用域存在着对外部函数局部数据的引用，所以返回内部函数时也会返回一个词法作用域引用，也就是闭包。</p>
<h3 id="闭包的力量-The-power-of-Closure"><a href="#闭包的力量-The-power-of-Closure" class="headerlink" title="闭包的力量(The power of Closure)"></a>闭包的力量(The power of Closure)</h3><p>闭包可以使我们的函数有”记忆“，既可以操作闭包中的数据（私有变量）的内部函数来实现一个计时器或者”自动销毁“（执行一定次数后就不在执行回调函数）的函数。</p>
<p>我们也可应在js中通过闭包实现模块模式。（我们不想污染全局作用域）</p>
<blockquote>
<p>Now: Our functions get ‘memories’ - once, memoize<br>Advanced: We can implement the module pattern in JavaScript</p>
</blockquote>
<h2 id="异步的JavaScript-Asynchrous-JavaScript"><a href="#异步的JavaScript-Asynchrous-JavaScript" class="headerlink" title="异步的JavaScript(Asynchrous JavaScript)"></a>异步的JavaScript(Asynchrous JavaScript)</h2><p>异步是现代JavaScript网络开发的基石</p>
<blockquote>
<p>Asynchronicity is the backbone of modern web development in JavaScript</p>
</blockquote>
<p>JavaScript是单线程的（一次执行一个命令），并具有同步执行模型(按照每行代码的顺序执行)</p>
<blockquote>
<p>JavaScript is single threaded (one command executing at a time) and has a synchronous execution model (each line is executed in order the code appears)</p>
</blockquote>
<p>通过上面的学习，我们知道，JavaScript是单线程的(single thread)。这就意味着在js执行代码时一般是一行行解析执行。但这就引申出来一个问题，或者说一个需求：如果我们需要等待一段时间在执行一个功能(function)怎么办？</p>
<p>在实际的开发情况中，这是一个常见的需求。例如我们需要等待服务器返回一段数据之后再进行相应的操作，又或者设置一个定时器等。此时，我们就有了一个新的需求，既如何在不阻碍js继续解析执行的前提下，定义一个在一段时间后执行的函数（例如先获取用户数据，再根据用户的数据信息显示对应评论，同时不影响页面加载）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(“Hello”);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(printHello,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(“Me first!”);</span><br></pre></td></tr></table></figure>
<p>如果了解setTimeout函数的作用，我们知道，上面的代码首先会在控制台打印出Me first!，然后才是Hello。但是这与我们前面所学习的知识并不一致。那么，setTimeout函数的原理是什么，它为什么可以做出不符合我们之前所学习知识的行为？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(“Hello”);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(printHello,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(“Me first!”);</span><br></pre></td></tr></table></figure>
<p>分析上面代码，根据我们对setTimeout的函数作用的了解，我们可以知道控制台会首先打印出Me first!，然后是Hello。</p>
<p>以上两种结果的出现，并不是因为我们之前所学是错误的，是因为我们所学习的JavaScript执行模型是不完整的。</p>
<blockquote>
<p>Our previous model of JavaScript execution is insufficient</p>
</blockquote>
<p>既然有了新的需求，那么我们就要在JavaScript这个平台上添加新的功能。</p>
<p>在之前的学习中，我们在函数执行时，我们有如下三个组件</p>
<ul>
<li>Thread of execution（执行线程）</li>
<li>Memory/variable environment（变量环境）</li>
<li>Call stack（调用栈）</li>
</ul>
<p>现在因为新的需求，我们添加了一下三个组件</p>
<ul>
<li>Web Browser APIs/Node background threads（浏览器内置功能 /节点后台线程）</li>
<li>Callback/Message queue（回调函数/消息队列）</li>
<li>Event loop（事件循环）</li>
</ul>
<h3 id="浏览器内置功能-Web-Browser-API"><a href="#浏览器内置功能-Web-Browser-API" class="headerlink" title="浏览器内置功能(Web Browser API)"></a>浏览器内置功能(Web Browser API)</h3><p>这里，我们首先学习浏览器的API(Application Program Interface)，通过上面代码的执行结果，我们知道，只有之前的三种模型（线程、执行上下文，调用栈）是无法解释这个执行结果的。</p>
<p>让我们逐步分析下面代码的执行过程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(“Hello”);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(printHello,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(“Me first!”);</span><br></pre></td></tr></table></figure>
<p>在代码执行最开始，我们首先创建了一个全局执行上下文，并将全局执行上下文推动到调用栈，然后线程执行到函数第一行。</p>
<p>在函数第一行，我们声明了一个函数，将这个函数的指针赋值给printHello这个变量。在声明函数时，同时也给函数创建了一个引用了当前全局作用域的词法作用域引用。</p>
<p>然后代码执行到第二行，我们调用了setTimeout函数，并将printHello变量的值，既我们声明的printHello函数的指针和一个基本类型值0作为两个参数传入。</p>
<p>按照我们之前所学，此时应该创建setTimeout的执行上下文，执行函数内的代码，又因为setTimeout是一个延时执行的函数，所以我们在等待一段时间后返回结果，将执行上下文推出调用栈，线程回到全局执行上下文，执行console.log()。</p>
<p>如果我们按照这个步骤执行，那么显然，代码的执行进程会卡在setTimeout上，等待setTimeout执行完毕后才会进行下一步。</p>
<p>但明显，这段代码并不是如此运行的，如果因为延时函数阻塞了js的进程也与我们的常见需求不符。那么，是因为什么代码才会如此执行呢？</p>
<p>在我们执行js时，js的执行环境中并不只有js，我们还有其他的外部环境，最常见的就是网络浏览器。</p>
<p>所以在js执行时，我们不仅有js，还有Web Browser APIs。这些API不止在js执行时发挥作用，这些功能(feature)还有许多其他功能供浏览器使用。其中一个很重要的工具就是一个计时器(timer)。</p>
<p>因为js是单线程的，为了不阻塞后面代码的执行，js会调用浏览器的API，通过浏览器来创建一个新的线程。此时，浏览器会创建一个后台计时器(background timer)。此时，我们使用的并不是js本身，而是一个浏览器的API。</p>
<p>所以当我们执行setTimeout函数时，并不是像js函数一样的执行过程。此时，setTimeout并不会在js的执行环境中创建执行上下文，而是会调用浏览器API，在浏览器的执行环境内创建一个执行环境，并开始计时。此时js代码调用浏览器api后并不会等待返回结果，而是为了不阻塞代码的执行而直接执行下一行console.log()，在控制台输出”me first“。在浏览器的计时器计时结束后，浏览器会将传入的函数返回到全局执行上下文，并调用函数，创建执行上下文，推入调用栈，执行函数，返回结果后将执行上下文从调用栈中推出。此时执行结果是在控制台打印”hello“。</p>
<h3 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">// CHALLENGE 1 //</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write code that will log to the console, 'I am at the beginning of the code'.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Beneath that console log, set a timer (see setTimeout) that will log to the console 'I am in the setTimeout callback function' after 3 seconds (3000 ms)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Next, add code to the end of the challenge to log 'I am at the end of the code'. Now re-run the code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Make sure the 'console' and 'output' panes are showing (click the tabs above if not) and then run your code with the 'Run with JS' button.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Clear the console. Change the delay time in the time from 3000 ms to 0. Think hard about how the order should change and then run the code again.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Start of Challenge 1'</span>);</span><br><span class="line"><span class="comment">// ...your code below</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'I am at the beginning of the code'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log('I am in the setTimeout callback function')</span></span><br><span class="line"><span class="comment">// &#125;, 3000) // 会在所有控制台打印完毕后打印。</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am in the setTimeout callback function'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>) <span class="comment">// 还是会在所有控制台打印完毕后打印。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'I am at the end of the code'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'End of Challenge 1'</span>);</span><br><span class="line"><span class="comment">// */// (do not alter this line)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">// CHALLENGE 2 //</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write code that will log to the console "Interval Hello!" every 2 seconds (see setInterval). Use the given clearAllIntervals function to clear all the messages when you have this functionality working.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Next, modify your code so that the "Interval Hello!" messages will automatically stop after 10 seconds.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Then, modify your code again so that the "Interval Hello!" messages will automatically stop after 10 seconds without use of the clearAllIntervals function, and using clearInterval only once. Perform research if you are unsure how to do this.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Start of Challenge 2'</span>);</span><br><span class="line"><span class="comment">// ...your code below</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Interval Hello!'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>) <span class="comment">// 会在控制台最后打印</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  clearInterval(timeId)</span><br><span class="line">&#125;, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...your code above</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearAllIntervals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    clearInterval(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'End of Challenge 2'</span>);</span><br><span class="line"><span class="comment">// */// (do not alter this line)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">// CHALLENGE 3 //</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write a function everyXsecsForYsecs that will accept three arguments: a function, an interval time in seconds, and a total time in seconds. everyXsecsForYsecs should invoke the given function every X times 1000 milliseconds, but then stop invoking the function after Y times 1000 milliseconds.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Write function sayHowdy that will log "Howdy" to the console. Then test your everyXsecsForYsecs function by using it to invoke sayHowdy every 1 second for 5 seconds.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Now, modify your everyXsecsForYsecs function so it does not use setInterval, but still keeps the same functionality.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Start of Challenge 3'</span>);</span><br><span class="line"><span class="comment">// ...your code below</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">everyXsecsForYsecs</span>(<span class="params">func, intervalTime, totalTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timeId = setInterval(func, intervalTime * <span class="number">500</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(timeId)</span><br><span class="line">  &#125;, totalTime * <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHowdy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Howdy'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">everyXsecsForYsecs(sayHowdy, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">everyXsecsForYsecs2</span>(<span class="params">func, intervalTime, totalTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalTime / intervalTime; i++)&#123;</span><br><span class="line">    setTimeout(func, intervalTime * <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">everyXsecsForYsecs2(sayHowdy, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'End of Challenge 3'</span>);</span><br><span class="line"><span class="comment">// */// (do not alter this line)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">// CHALLENGE 4 //</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Recreate the built in array method, forEach: Write a function that takes as parameters an array, arr, and a callback function, cb. The forEach function will iterate through arr passing each element and its index as arguments to cb.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Create a variable named delays and assign to it an array with the numbers 2000, 5000, 0, and 3500 (in that order).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Write a function, delayLog, that takes as input a delayTime and an index, i. When invoked, the function should wait delayTime milliseconds before logging to the console, "printing element i" (with "i" replaced with the actual index passed in).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Putting it all together, run the delayLog function on each item of the delays array using the forEach function you created.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Start of Challenge 4'</span>);</span><br><span class="line"><span class="comment">// ...your code below</span></span><br><span class="line"><span class="comment">// part 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">arr, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    callback(arr[i], i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// part 2</span></span><br><span class="line">delay = [<span class="number">2000</span>, <span class="number">5000</span>, <span class="number">0</span>, <span class="number">3500</span>]</span><br><span class="line"><span class="comment">// part 3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayLog</span>(<span class="params">delayTime, index</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`print element <span class="subst">$&#123;index&#125;</span>`</span>)</span><br><span class="line">  &#125;, delayTime)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// part 4</span></span><br><span class="line">forEach(delay, delayLog)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'End of Challenge 4'</span>);</span><br><span class="line"><span class="comment">// */// (do not alter this line)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">// CHALLENGE 5 //</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write a function changeColor that when invoked will first check if the current page background color is "rgb(221, 238, 255)". If it is, it changes the color to "rgb(255, 238, 221)". If it isn't, it sets the color to "rgb(221, 238, 255)".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Add a click event listener to button #1 above (it has an id of "activate"). On click, the button should log to the console "clicked #1". It should also set up a click event listener on button #2 (id of "color"). That listener should log to console "clicked #2" and then call the changeColor function you just created.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Clear the console and hit the 'Run with JS' button. Look at what code has run by analyzing the console. Then try to change the background color by clicking button #2. What needs to happen for the button to work?</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Start of Challenge 5'</span>);</span><br><span class="line"><span class="comment">// ...your code below</span></span><br><span class="line"><span class="comment">// part 1</span></span><br><span class="line"><span class="keyword">let</span> background = <span class="built_in">document</span>.body.style.background</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(background === <span class="string">"rgb(221, 238, 255)"</span>)&#123;</span><br><span class="line">    background = <span class="string">"rgb(255, 238, 221)"</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     background = <span class="string">"rgb(221, 238, 255)"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(background)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// part 2</span></span><br><span class="line"><span class="keyword">const</span> activateBtn = <span class="built_in">document</span>.getElementById(<span class="string">"activate"</span>)</span><br><span class="line"><span class="keyword">const</span> colorBtn = <span class="built_in">document</span>.getElementById(<span class="string">"color"</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleColorBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"clicked #2"</span>)</span><br><span class="line">  changeColor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleActivateBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"clicked #1"</span>)</span><br><span class="line">  colorBtn.addEventListener(<span class="string">'click'</span>, handleColorBtn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">activateBtn.addEventListener(<span class="string">'click'</span>, handleActivateBtn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...your code above</span></span><br><span class="line"><span class="built_in">document</span>.body.style.background = <span class="string">'#def'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'End of Challenge 3'</span>);</span><br><span class="line"><span class="comment">// */// (do not alter this line)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">// CHALLENGE 6 //</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  In this challenge we are going to simulate an AJAX call to get information from a server. This is not a real AJAX call, but the asynchonicity is similar.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Modify the function ajaxSimulate to take an id and a callback function as input. After the database array, set a timer that will pass the element of database whose index matches id to the callback function after 0 ms.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Create a second function storeData (outside of ajaxSimulate) that takes data as input and assigns it to the dataReceived variable already defined.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Invoke the ajaxSimulate function with an id of 1 and the storeData function as the callback. Immediately after, log to the console the value of dataReceived. What do you expect it to be?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Without changing anything else, copy-paste the console.log statement somewhere where it will log with the info we need.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Start of Challenge 6'</span>);</span><br><span class="line"><span class="keyword">var</span> dataReceived;</span><br><span class="line"><span class="comment">// part 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxSimulate</span>(<span class="params">id, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> database = [<span class="string">'Aaron'</span>, <span class="string">'Barbara'</span>, <span class="string">'Chris'</span>];</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(database[id])</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...your code below</span></span><br><span class="line"><span class="comment">// part 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">storeData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  dataReceived = data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// part 3</span></span><br><span class="line">ajaxSimulate(<span class="number">1</span>, (data) =&gt; &#123;</span><br><span class="line">  storeData(data)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`part 4 <span class="subst">$&#123;dataReceived&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`part 3 <span class="subst">$&#123;dataReceived&#125;</span>`</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'End of Challenge 6'</span>);</span><br><span class="line"><span class="comment">// */// (do not alter this line)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">// CHALLENGE 7 //</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Perform a GET request to the Bandsintown API (hosted by swaggerhub) (follow this link and then make sure 'UI' is sellected at the upper left, to read how to use their API) to search for your favorite band. For the 'app_id', use the string 'jshp'.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Then in the returned JSON, find the URL for the image associated with the band and display it in the DOM.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Make sure to use 'https' for JSBIN to allow the request. There is a div with the ID 'ch2' for you to target. If you want, you can view this div by opening the HTML pane, by clicking the HTML button at the top.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Start of Challenge 7'</span>);</span><br><span class="line"><span class="comment">// ...your code below</span></span><br><span class="line"><span class="keyword">const</span> Http = <span class="keyword">new</span> XMLHttpRequest() <span class="comment">//新建一个异步请求对象</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'https://rest.bandsintown.com/artists/sleepingwithsirens?app_id=jshp'</span> <span class="comment">// 把请求地址及请求id保存在url中</span></span><br><span class="line">Http.open(<span class="string">'get'</span>, url) <span class="comment">// 新建一个get请求</span></span><br><span class="line">Http.send() <span class="comment">// 发起一个请求</span></span><br><span class="line"></span><br><span class="line">Http.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.readyState == <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.status == <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> response = Http.responseText</span><br><span class="line">    dataHandler(<span class="built_in">JSON</span>.parse(response))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataHandler</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">"#ch2"</span>).append(<span class="string">`&lt;img src="<span class="subst">$&#123;data.image_url&#125;</span>"/&gt;`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'End of Challenge 7'</span>);</span><br><span class="line"><span class="comment">// */// (do not alter this line)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">// CHALLENGE 8 //</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Start of Challenge 8'</span>);</span><br><span class="line"><span class="comment">// ...your code below</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'End of Challenge 8'</span>);</span><br><span class="line"><span class="comment">// */// (do not alter this line)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">// CHALLENGE 9 //</span></span><br><span class="line"><span class="comment">//             //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /* &lt;&lt;&lt;=== Remove the first two slashes (//) to comment out this challenge when finished</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Start of Challenge 9'</span>);</span><br><span class="line"><span class="comment">// ...your code below</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'End of Challenge 9'</span>);</span><br><span class="line"><span class="comment">// */// (do not alter this line)</span></span><br></pre></td></tr></table></figure>
<h3 id="回调队列-callback-queue"><a href="#回调队列-callback-queue" class="headerlink" title="回调队列(callback queue)"></a>回调队列(callback queue)</h3><p>既然我们调用的是浏览器的api，并且此api与js的执行模型并不一样，那么我们就需要了解此api的执行模型，以便我们预测api执行的行为结果。</p>
<p>当我们执行一个setTimeout或者setInterval时，我们把参数传递给函数后，不会等待方法执行，阻碍线程，而是直接进行下一步。那么，setTimeout或setInterval计时完毕后，什么时候通知js执行对应的函数呢？直接将函数推入调用栈？那这样是不是会影响到当前调用栈的执行？此时我们需要一个工具来解决js执行函数的顺序。</p>
<p>这个工具有两个部分：</p>
<ol>
<li>回调函数/消息/任务队列(callback/message/task queue)</li>
<li>事件循环(event loop)</li>
</ol>
<h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>如果计时器计时结束，我们并不会把回调函数立即推入调用栈，以免扰乱调用栈内函数的执行顺序，所以我们新建一个队列（先进先出），计时结束后，我们就将回调函数推入队列，该任务队列会在js的主线程执行完毕后（调用栈内全部线程执行完成，所有执行上下文被推出，调用栈为空）将队列内的首个函数推入js的调用栈，此时队列内第二个函数成为首个函数，调用栈主线程执行完毕后，再将首个函数推入调用栈，依次循环。</p>
<p>举例：就像一个非常忙的领导(JavaScript)交给属下(Web Browser API)一件事，属下可能立马就办完了，但是领导非常忙，属下不能立马汇报给领导，只能等领导忙完了在汇报。那么，如果有多件事交给属下，属下一件件办好，然后把结果按照办完的顺序记录下来，等领导忙完了，按照记录的顺序一件件汇报给领导。</p>
<h3 id="回调队列和事件循环-callback-queue-amp-event-loop"><a href="#回调队列和事件循环-callback-queue-amp-event-loop" class="headerlink" title="回调队列和事件循环(callback queue &amp; event loop)"></a>回调队列和事件循环(callback queue &amp; event loop)</h3><p>对于异步延迟代码的执行，我们有两条规则</p>
<blockquote>
<p>We have two rules for the execution of our asynchronously delayed code</p>
</blockquote>
<ol>
<li>当API“完成”时，在队列(回调队列)中保存每个延迟函数<blockquote>
<p>Hold each deferred function in a queue (the Callback Queue) when the API ‘completes’</p>
</blockquote>
</li>
<li>只有当调用堆栈完全为空时才将函数添加到调用堆栈(即执行函数)(让事件循环检查此条件)<blockquote>
<p>Add the function to the Call stack (i.e. execute the function) ONLY when the call stack is totally empty (Have the Event Loop check this condition)</p>
</blockquote>
</li>
</ol>
<p>这个异步的线程不是发生在js中的，js是单线程的，js只有依靠网络浏览器提供的api来模拟出异步执行。</p>
<p>事件循环就是一个不断检查js调用栈是否为空，然后检查任务队列是否为空的过程。</p>
<p>所以即使把延时设置为0，传入的回调函数也只能在js主线程全部执行完之后，才会在任务队列中推出回调函数到调用栈中执行。除了setTimeout，我们还有其他方法是按照此模型来进行的。</p>
<h3 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h3><p>是否有办法绕过事件循环？并没有，要按照此模型严格执行，否则无法预测函数的执行顺序。</p>
<h3 id="其他浏览器API-introduce-more-Browser-APIs"><a href="#其他浏览器API-introduce-more-Browser-APIs" class="headerlink" title="其他浏览器API(introduce more Browser APIs)"></a>其他浏览器API(introduce more Browser APIs)</h3><p>在很多情况下，等待会阻塞线程，我们使用浏览器api来代替</p>
<blockquote>
<p>There are many things where waiting would block our thread and we use Browser APIs for instead</p>
</blockquote>
<ul>
<li>A timer to finish running(一个计时器)</li>
<li>New information from a server (Ajax)（一个服务器请求Ajax）</li>
<li>Indication that a portion of the page has loaded（指示页面的一部分已加载）</li>
<li>User interaction (clicks, mouseovers, drags)（用户交互(单击、鼠标移动、拖动)）</li>
<li>Writing/Reading to File system (Node)（写入/读取文件系统(node.js)）</li>
<li>Writing/reading database (Node)（写入/读取数据库(node.js)）</li>
</ul>
<p>在返回数据时。我们使用的浏览器的API的设计决定了我们如何接受这些数据。</p>
<blockquote>
<p>Some come back with data. The design of the Browser API we are using determines how we access the returned data</p>
</blockquote>
<p>在强调一遍，浏览器API并不属于js，是一个native code，使用c++等语言编写的内置于浏览器的功能。Js本身无法进行网络请求，Js通过XMLHttpRequest这个浏览器内置功能来进行网络请求。</p>
<p>所以setTimeout是js与本地浏览器之间的交互功能，XMLHttpRequest是js与其他网络服务器见交换数据的功能（feature）</p>
<h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>就像setTimeout一样，我们传入的回调函数并不会在XMLHTTPRequest()中执行，而是在XMLHttpRequest方法中，获取到数据后，将回调函数推送到任务队列，在主线程执行完毕后，将回调函数推送到调用栈的最顶端，并将XMLHttpRequest内获取到的数据作为一个实参传递给回调函数。</p>
<p>因为XMLHttpRequest也是一个函数，只不过用其他语言编写，所以传递给回调函数的参数的顺序要查询文档，根据作者文档中的定义顺序来决定我们编写回调函数时形参的顺序。</p>
<p>与setTimeout一样，XMLHttpRequest执行完毕后会将回调函数及获取的数据推入任务队列中，此时事件循环会不断检查js的调用栈是否清空，如果清空将任务队列的第一个回调函数及其参数推送到调用栈最顶端执行。</p>
<p>异步回调函数、Web API、回调队列和事件循环允许我们延迟操作，直到“工作”(API请求、计时器等)完成并同时逐行运行代码</p>
<blockquote>
<p>Asynchronous callbacks, Web APIs, the Callback Queue and Event loop allow us to defer our actions until the ‘work’ (an API request, timer etc) is completed and continue running our code line by line in the meantime</p>
</blockquote>
<h4 id="异步JavaScript是现代web的支柱——让我们可以构建快速的“没有阻塞的”应用程序"><a href="#异步JavaScript是现代web的支柱——让我们可以构建快速的“没有阻塞的”应用程序" class="headerlink" title="异步JavaScript是现代web的支柱——让我们可以构建快速的“没有阻塞的”应用程序"></a>异步JavaScript是现代web的支柱——让我们可以构建快速的“没有阻塞的”应用程序</h4><blockquote>
<p>Asynchronous JavaScript is the backbone of the modern web - letting us build fast ‘nonblocking’ applications</p>
</blockquote>
<h2 id="面向对象的JavaScript-理解面向对象编程-Object-oriented-JavaScript-–-Approaches-to-OOP"><a href="#面向对象的JavaScript-理解面向对象编程-Object-oriented-JavaScript-–-Approaches-to-OOP" class="headerlink" title="面向对象的JavaScript - 理解面向对象编程(Object-oriented JavaScript – Approaches to OOP)"></a>面向对象的JavaScript - 理解面向对象编程(Object-oriented JavaScript – Approaches to OOP)</h2><h3 id="介绍JS中的面向对象-introducing-Object-Oriented-JavaScript"><a href="#介绍JS中的面向对象-introducing-Object-Oriented-JavaScript" class="headerlink" title="介绍JS中的面向对象(introducing Object-Oriented JavaScript)"></a>介绍JS中的面向对象(introducing Object-Oriented JavaScript)</h3><p> 面相对象编程(Object-Oriented Programming)——一种非常流行的用于构造复杂代码的范例</p>
<blockquote>
<p>OOP - an enormously popular paradigm for structuring ourcomplex code</p>
</blockquote>
<ul>
<li>easy to add features and functionality(轻松地添加功能并且功能化代码)</li>
<li>performant(efficient in terms of memory)(性能更好(在内存方面的效率))</li>
<li>easy for us and other developers to reason about(a clear structure)(代码的可读化，语义化更好（结构清晰）)</li>
</ul>
<p>当我们的代码越来越复杂，规模越来越庞大时，我们需要一种结构化的方式来将代码组织起来。面相对象编程范式可以让我们轻松的添加功能。<br>可以互相引用方法，因为方法存储在内存中，传递的只是一个指针，所以互相引用，而不是在开辟一块内存空间，可以提高内存的使用效率。<br>而且是其他人更容易推测出代码代表的功能。</p>
<p>我们想要实现一个功能，就要有相应的输入和方法，这样我们把数据和方法提供给计算机，计算机才能根据我们提供的数据和方法计算出结果返回给我们。面相对象编程就是利用这个原理，把计算所需的数据及方法都封装到一起，使用一个对象来组织所需的数据与方法，在需要时调用，提供给计算机进行计算。</p>
<p>此时举了一个例子，我们有一场比赛，希望统计每个人的分数。显而易见，每个人都有名字和分数，然后我们有一些公用的方法，适用于比赛的所有选手（增加得分，减少得分，删除选手，增加选手，增加角色，获取某选手得分。。。）。</p>
<p>对象——可以存储功能和与其相关的数据！</p>
<blockquote>
<p>Objects - store functions with their associated data!</p>
</blockquote>
<h4 id="这种将我们所需要的数据和操作这些数据的方法绑定在一起想法，就叫封装。"><a href="#这种将我们所需要的数据和操作这些数据的方法绑定在一起想法，就叫封装。" class="headerlink" title="这种将我们所需要的数据和操作这些数据的方法绑定在一起想法，就叫封装。"></a>这种将我们所需要的数据和操作这些数据的方法绑定在一起想法，就叫封装。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = &#123;</span><br><span class="line"> name: <span class="string">"Will"</span>,</span><br><span class="line"> score: <span class="number">3</span>,</span><br><span class="line"> increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> user1.score++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">user1.increment(); <span class="comment">//user1.score =&gt; 4</span></span><br></pre></td></tr></table></figure>
<p>在上述代码开始执行时，我们首先声明了一个变量user，并创建了一个新的对象，将对象的引用赋值给user。然后就进行到了全局执行上下文的下一步，及代码最后一行。首先我们使用了点方法调用了user的increment方法。我们首先找到user，然后查找里面的方法，此时处于全局执行上下文，然后执行方法，首先新建一个执行上下文，然后逐行执行函数体内代码，函数体内，我们使用了点方法访问了user1对象的score属性并自增1。为了执行这段代码，我们会在次执行上下文内寻找user1对象，发现并不存在，然后在调用栈的下一层执行上下文及全局执行上下文中寻找，找到了user1，并在user1内找到了score属性，此时我们给属性值自增1。函数执行完毕，执行上下文推出调用栈，线程回到全局执行上下文，发现并没有进程执行完毕，任务队列也没有需要执行的函数。代码执行完毕。</p>
<p>通过分析，我们把我们需要的数组和方法都组织到了一起，这样我们就可以更加容易的移动代码，而不用在移动时把他们拼凑在一起。我们只需要了解对象的组成结构就可以实现我们想要的功能。</p>
<p>我们有什么其他的技术来创建对象?</p>
<blockquote>
<p>What alternative techniques do we have for creating objects?</p>
</blockquote>
<p>使用点方法创建user2</p>
<blockquote>
<p>Creating user2 user ‘dot notation’</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = &#123;&#125;; <span class="comment">//create an empty object</span></span><br><span class="line">user2.name = <span class="string">"Tim"</span>; <span class="comment">//assign properties to that object</span></span><br><span class="line">user2.score = <span class="number">6</span>;</span><br><span class="line">user2.increment = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> user2.score++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用Object.create()方法创建user3</p>
<blockquote>
<p>Creating user3 using Object.create</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user3 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">user3.name = <span class="string">"Eva"</span>;</span><br><span class="line">user3.score = <span class="number">9</span>;</span><br><span class="line">user3.increment = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> user3.score++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里再重复我们的目标，我们想构建一个应用程序，我想要把我需要的数据和方法组织在其内部。我已经决定了把每个用户封装成一个对象来进行实现。</p>
<p>在上诉代码开始执行时，我们创建了一个空对象(实参null的传入并不影响空对象的创建)，然后我们通过点方法给对象增加属性和方法，并将一些基本类型值赋值给属性，将函数的引用赋值给方法。</p>
<p>在创建了三个对象后可见我们的代码越来越重复，我们打破了枯燥的原则<br>假设我们有数百万user需要创建!<br>我们要怎么做?</p>
<blockquote>
<p>Our code is getting repetitive, we’re breaking our DRY principle<br>And suppose we have millions of users!<br>What could we do?</p>
</blockquote>
<p>此时我们发现了重复的代码，及代表了一段重复的执行过程，那么，我们可以把这段执行过程封装成函数。</p>
<h4 id="解决方案1：使用函数创建对象"><a href="#解决方案1：使用函数创建对象" class="headerlink" title="解决方案1：使用函数创建对象"></a>解决方案1：使用函数创建对象</h4><blockquote>
<p>Solution 1. Generate objects using a function</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userCreator</span>(<span class="params">name, score</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newUser = &#123;&#125;</span><br><span class="line">  newUser.name = name</span><br><span class="line">  newUser.score = score</span><br><span class="line">  newUser.increment = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    newUser.score++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newUser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//later</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user1 = userCreator(<span class="string">'Will'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> user2 = userCreator(<span class="string">'Tim'</span>, <span class="number">5</span>)</span><br><span class="line">user1.increment()</span><br><span class="line">user2.increment()</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们先是声明了一个函数，将函数保存到内存中并将指针赋值给函数名，然后进程跳转到倒数第四行，<br>我们声明了user1，并调用了userCreator函数，将”Will“和3作为两个参数传递给userCreator，将执行结果赋值给user1，在执行完毕前，我们会先将undefined赋值给user1。此时执行userCreator。首先创建一个新的执行上下文，并将其推入调用栈顶端，然后执行函数内代码。首先我们在执行上下文中声明了一个newUser变量，并在局部缓存区中创建了一个新的空对象，并将此空对象的指针赋值给newUser变量。然后我们通过点方法给空对象添加了对应的属性及方法，在赋值方法时，在userCreator的缓存区中新开辟了一块空间保存方法的代码。最后，函数执行完毕，返回变量，注意，此时返回的时新建对象的指针。此时将此执行上下文从调用栈中推出，回到全局执行上下文，将函数执行结果也就是返回的对象的引用赋值给user1，此时user1指向了函数执行时创建的对象，因为外部保持了对对象的引用，所以此对象并不会被垃圾回收机制回收。后面的过程与此及上面函数的执行过程类似，并不具体展开。</p>
<p>缺点：</p>
<blockquote>
<p>Problems:</p>
</blockquote>
<p>每次创建一个新的user，我们都会在计算机的内存中为所有数据和函数开辟空间。但是我们的函数功能明显是一样的。<br>有没有更好的方法？</p>
<blockquote>
<p>Each time we create a new user we make space in our computer’s memory for all our data and functions. But our functions are just copies<br>Is there a better way?</p>
</blockquote>
<p>优点：</p>
<blockquote>
<p>Benefits:</p>
</blockquote>
<p>简单！<br>It’s simple!</p>
<p>此时谈到了高级开发者面试时会提问什么问题，其中一个经典的问题就是如何设计new关键词，怎么实现类。</p>
<h4 id="代码练习"><a href="#代码练习" class="headerlink" title="代码练习"></a>代码练习</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">                  WORKING WITH OBJECT LITERALS</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="comment">/*** CHALLENGE 1 of 1 ***/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a function that accepts two inputs (name and age) and returns an object. Let's call this function makePerson. This function will:</span></span><br><span class="line"><span class="comment">  create an empty object</span></span><br><span class="line"><span class="comment">  add a name property to the newly created object with its value being the 'name' argument passed into the function</span></span><br><span class="line"><span class="comment">  add an age property to the newly created object with its value being the 'age' argument passed into the function</span></span><br><span class="line"><span class="comment">  return the object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"><span class="comment">// add code here</span></span><br><span class="line">  <span class="keyword">const</span> newPerson = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  newPerson.name = name</span><br><span class="line">  newPerson.age = age</span><br><span class="line">  <span class="keyword">return</span> newPerson</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vicky = makePerson(<span class="string">'Vicky'</span>, <span class="number">24</span>);</span><br><span class="line"><span class="comment">// /********* Uncomment these lines to test your work! *********/</span></span><br><span class="line"><span class="built_in">console</span>.log(vicky.name); <span class="comment">// -&gt; Logs 'Vicky'</span></span><br><span class="line"><span class="built_in">console</span>.log(vicky.age); <span class="comment">// -&gt; Logs 24</span></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">                       USING OBJECT.CREATE</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Challenge 3/3</span></span><br><span class="line"><span class="comment">Without editing the code you've already written, add an introduce method to the personStore object that logs "Hi, my name is [name]".</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*** CHALLENGE 1 of 3 ***/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Inside personStore object, create a property greet where the value is a function that logs "hello".</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> personStore = &#123;</span><br><span class="line"><span class="comment">// add code here</span></span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// /********* Uncomment this line to test your work! *********/</span></span><br><span class="line">personStore.greet(); <span class="comment">// -&gt; Logs 'hello'</span></span><br><span class="line"><span class="comment">/*** CHALLENGE 2 of 3 ***/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a function personFromPersonStore that takes as input a name and an age. When called, the function will create person objects using the Object.create method on the personStore object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personFromPersonStore</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"><span class="comment">// add code here</span></span><br><span class="line">  <span class="keyword">const</span> newPerson = <span class="built_in">Object</span>.create(personStore)</span><br><span class="line">  newPerson.name = name</span><br><span class="line">  newPerson.age = age</span><br><span class="line">  <span class="keyword">return</span> newPerson</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sandra = personFromPersonStore(<span class="string">'Sandra'</span>, <span class="number">26</span>);</span><br><span class="line"><span class="comment">// /********* Uncomment these lines to test your work! *********/</span></span><br><span class="line"><span class="built_in">console</span>.log(sandra.name); <span class="comment">// -&gt; Logs 'Sandra'</span></span><br><span class="line"><span class="built_in">console</span>.log(sandra.age); <span class="comment">//-&gt; Logs 26</span></span><br><span class="line">sandra.greet(); <span class="comment">//-&gt; Logs 'hello'</span></span><br><span class="line"><span class="comment">/*** CHALLENGE 3 of 3 ***/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Without editing the code you've already written, add an introduce method to the personStore object that logs "Hi, my name is [name]".</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// add code here</span></span><br><span class="line">personStore.introduce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">sandra.introduce(); <span class="comment">// -&gt; Logs 'Hi, my name is Sandra'</span></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">                    USING THE 'NEW' KEYWORD</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="comment">/*** CHALLENGE 1 of 3 ***/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a function PersonConstructor that uses the this keyword to save a single property onto its scope called greet. greet should be a function that logs the string 'hello'.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonConstructor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// add code here</span></span><br><span class="line">  <span class="keyword">this</span>.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// /********* Uncomment this line to test your work! *********/</span></span><br><span class="line"><span class="keyword">var</span> simon = <span class="keyword">new</span> PersonConstructor;</span><br><span class="line">simon.greet(); <span class="comment">// -&gt; Logs 'hello'</span></span><br><span class="line"><span class="comment">/*** CHALLENGE 2 of 3 ***/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a function personFromConstructor that takes as input a name and an age. When called, the function will create person objects using the new keyword instead of the Object.create method.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personFromConstructor</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// add code here</span></span><br><span class="line">  <span class="keyword">const</span> newPerson = <span class="keyword">new</span> PersonConstructor</span><br><span class="line">  newPerson.name = name</span><br><span class="line">  newPerson.age = age</span><br><span class="line">  <span class="keyword">return</span> newPerson</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mike = personFromConstructor(<span class="string">'Mike'</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">// /********* Uncomment these lines to test your work! *********/</span></span><br><span class="line"><span class="built_in">console</span>.log(mike.name); <span class="comment">// -&gt; Logs 'Mike'</span></span><br><span class="line"><span class="built_in">console</span>.log(mike.age); <span class="comment">//-&gt; Logs 30</span></span><br><span class="line">mike.greet(); <span class="comment">//-&gt; Logs 'hello'</span></span><br><span class="line"><span class="comment">/*** CHALLENGE 3 of 3 ***/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Without editing the code you've already written, add an introduce method to the PersonConstructor function that logs "Hi, my name is [name]".</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// add code here</span></span><br><span class="line">PersonConstructor.prototype.introduce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mike.introduce(); // -&gt; Logs 'Hi, my name is Mike'</span></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">                        USING ES6 CLASSES</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="comment">/*** CHALLENGE 1 of 3 ***/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a class PersonClass. PersonClass should have a constructor that is passed an input of name and saves it to a property by the same name. PersonClass should also have a method called greet that logs the string 'hello'.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// add code here</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// add code here</span></span><br><span class="line">  greet()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// /********* Uncomment this line to test your work! *********/</span></span><br><span class="line"><span class="keyword">var</span> george = <span class="keyword">new</span> PersonClass;</span><br><span class="line">george.greet(); <span class="comment">// -&gt; Logs 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** CHALLENGE 2 of 3 ***/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a class DeveloperClass that creates objects by extending the PersonClass class. In addition to having a name property and greet method, DeveloperClass should have an introduce method. When called, introduce should log the string 'Hello World, my name is [name]'.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// add code here</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">extends</span> <span class="title">PersonClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  introduce()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello World, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// /********* Uncomment these lines to test your work! *********/</span></span><br><span class="line"><span class="comment">// var thai = new DeveloperClass('Thai', 32);</span></span><br><span class="line"><span class="comment">// console.log(thai.name); // -&gt; Logs 'Thai'</span></span><br><span class="line"><span class="comment">// thai.introduce(); //-&gt; Logs 'Hello World, my name is Thai'</span></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">                      EXTENSION: SUBCLASSING</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="keyword">var</span> userFunctionStore = &#123;</span><br><span class="line">  sayType: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I am a "</span> + <span class="keyword">this</span>.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userFactory</span>(<span class="params">name, score</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="built_in">Object</span>.create(userFunctionStore);</span><br><span class="line">  user.type = <span class="string">"User"</span>;</span><br><span class="line">  user.name = name;</span><br><span class="line">  user.score = score;</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adminFunctionStore <span class="comment">/* Put code here */</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adminFactory</span>(<span class="params">name, score</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Put code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Put code here for a method called sharePublicMessage*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adminFromFactory = adminFactory(<span class="string">"Eva"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// /********* Uncomment these lines to test your work! *********/</span></span><br><span class="line"><span class="comment">// adminFromFactory.sayType() // -&gt; Logs "I am a Admin"</span></span><br><span class="line"><span class="comment">// adminFromFactory.sharePublicMessage() // -&gt; Logs "Welcome users!"</span></span><br></pre></td></tr></table></figure>
<h4 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h4><blockquote>
<p>Solution 2:</p>
</blockquote>
<p>我们可以把increment这个方法保存在一个对象中并给使user与其进行引用，如果我们没有在user上找到这个方法，就到这个对象中寻找这个方法。<br>那么怎么才能实现这个引用？</p>
<blockquote>
<p>Store the increment function in just one object and have the interpreter, if it doesn’t find the function on user1, look up to that object to check if it’s there<br>How to make this link?</p>
</blockquote>
<h4 id="充分利用JavaScript的原型特性-解决方案2"><a href="#充分利用JavaScript的原型特性-解决方案2" class="headerlink" title="充分利用JavaScript的原型特性-解决方案2"></a>充分利用JavaScript的原型特性-解决方案2</h4><blockquote>
<p>Using the prototypal nature of JavaScript - Solution 2 in full</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userCreator</span> (<span class="params">name, score</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> newUser = <span class="built_in">Object</span>.create(userFunctionStore);</span><br><span class="line"> newUser.name = name;</span><br><span class="line"> newUser.score = score;</span><br><span class="line"> <span class="keyword">return</span> newUser;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> userFunctionStore = &#123;</span><br><span class="line"> increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.score++;&#125;,</span><br><span class="line"> login: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"You're loggedin"</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> user1 = userCreator(<span class="string">"Will"</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> user2 = userCreator(<span class="string">"Tim"</span>, <span class="number">5</span>);</span><br><span class="line">user1.increment();</span><br></pre></td></tr></table></figure>
<p>js中的原型模式并不是实例”继承“了父级构造函数的原型，而是与父级构造函数指向了同一个对象，这个对象就是原型对象。</p>
<p>原型机制的问题是什么？</p>
<blockquote>
<p>Problem<br>没有问题！漂亮的答案！<br>No problems! It’s beautiful<br>就是代码有点长<br>Maybe a little long-winded<br><code>let newUser = Object.create(functionStore);</code><br><code>...</code><br><code>return newUser</code></p>
</blockquote>
<p>每次要写六个单词！</p>
<blockquote>
<p>Write this every single time - but it’s 6 words!<br>超级复杂也不标准<br>Super sophisticated but not standard</p>
</blockquote>
<h4 id="解决方案3："><a href="#解决方案3：" class="headerlink" title="解决方案3："></a>解决方案3：</h4><blockquote>
<p>Solution 3</p>
</blockquote>
<p>介绍一个神奇的关键字new</p>
<blockquote>
<p>Introduce magic keyword new</p>
</blockquote>
<p><code>let user1 = new userCreator(&quot;Will&quot;, 3)</code></p>
<p>当我们调用userCreator(“Will”，3)而没有new关键字时会发生什么?</p>
<blockquote>
<p>What happens when we invoke userCreator(“Will”, 3) without the new keyword?</p>
</blockquote>
<p>就是解决方案2。</p>
<p>当我们使用new关键字调用构造函数时，我们自动完成了两件事</p>
<blockquote>
<p>When we call the constructor function with new in front we automate 2 things</p>
</blockquote>
<ol>
<li>创建了一个新的user对象（Create a new user object）</li>
<li>返回了这个对象（return the new user object）</li>
</ol>
<p>new关键字自动帮我们完成了许多程序化工作</p>
<blockquote>
<p>The new keyword automates a lot of our manual work</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userCreator</span>(<span class="params">name, score</span>) </span>&#123;</span><br><span class="line"><span class="comment">/*let newUser = Object.create(functionStore);*/</span></span><br><span class="line"><span class="comment">/*newUser*/</span> <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="comment">/*newUser*/</span> <span class="keyword">this</span>.score = score;</span><br><span class="line"><span class="comment">/*return newUser;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*functionStore*/</span> userCreator.prototype <span class="comment">// &#123;&#125;;</span></span><br><span class="line"><span class="comment">/*functionStore*/</span> userCreator.prototype.increment = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.score++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> userCreator(<span class="string">"Will"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="解决方案3的完整答案："><a href="#解决方案3的完整答案：" class="headerlink" title="解决方案3的完整答案："></a>解决方案3的完整答案：</h4><blockquote>
<p>Complete Solution 3</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, score</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.increment = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.score++;</span><br><span class="line">&#125;;</span><br><span class="line">User.prototype.login = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"login"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> User(“Eva”, <span class="number">9</span>)</span><br><span class="line">user1.increment();</span><br></pre></td></tr></table></figure>
<p>优点</p>
<blockquote>
<p>Benefits</p>
</blockquote>
<ul>
<li>写起来更快(Faster to write)</li>
<li>仍然是专业代码中的典型实践(Still typical practice in professional code)</li>
</ul>
<h5 id="99-的开发人员不知道它是如何工作的，因此无法通过面试"><a href="#99-的开发人员不知道它是如何工作的，因此无法通过面试" class="headerlink" title="99%的开发人员不知道它是如何工作的，因此无法通过面试"></a>99%的开发人员不知道它是如何工作的，因此无法通过面试</h5><blockquote>
<p>99% of developers have no idea how it works and therefore fail interviews</p>
</blockquote>
<h4 id="对于构造函数、原型对象的理解"><a href="#对于构造函数、原型对象的理解" class="headerlink" title="对于构造函数、原型对象的理解"></a>对于构造函数、原型对象的理解</h4><p>在js高级程序设计中说，当我们使用new关键字时，会自动实行以下4个步骤</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（this就指向了这个新对象）</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<p>但是构造函数也是函数，在我们创建一个函数时，会自动给函数添加一个prototype属性，这个属性存储了一个指针，指向了一个对象。</p>
<p>在方案一中，我们发现如果要创建多个对象，但是对象的一部分属性和方法是一样的，那么我们就没有必要为每个对象都开辟一块内存空间保存这些公共的属性和方法。所以在解决方案二中，我们创建了一个对象，来存储我们公共的属性和防范，应为对象是引用类型，在赋值时传递的是指针而不是全部数据，所以我们把存储公共方法的对象的指针赋值给模板函数，这样，每个通过模板函数所创建的新对象，都添加了公共对象的指针，解决了这个问题。但是，这又引申出了一个新的问题，及流程的重复。为了减少重复性的工作，我们设计了一个新的关键字new，通过使用new操作符，我们很大幅度的简化了代码的数量。</p>
<p>这里我们要理解一下prototype原型对象。</p>
<p>出于跟上述解决方案同样的思路，我们没有必要把一些公共的方法在每个实例上都开辟一块内存空间进行存储，这样会极大地浪费我们的资源，那么解决的办法就是新建一个公共的对象，把公共对象的指针传递给实例，这样实例上想调用公共的方法就可以通过这个对象。</p>
<p>我们知道，函数也是一个对象，我们创建的每个函数都是Function对象的一个实例，所以基于以上的解决方案，我们每创建一个新的函数，就给函数添加一个属性，这个属性就指向一个对象，可以用来存储公共的属性和方法，这个属性名就是prototype，我们把这个与每个函数实例联系起来的对象叫做原型对象。</p>
<p>在解决方案二中，我们首先做的就是手动创建一个存储公共方法的新对象，然后把公共方法的对象手动的与函数中创建的对象进行绑定。那么，既然有了原型对象，就可以省略这一步骤。</p>
<p>就像之前所说，在我们使用new关键字后，会自动将函数的作用域赋给新对象。那么，函数的作用域应该包含了prototype属性，存储了指向原型对象的指针。所以在使用new关键字调用函数后，通过函数创建的新对象包含了函数的prototype属性存储的指针，但是在创建的新对象中这个属性名并不叫prototype。ECMA规定中管这个指针叫[[Prototype]]。</p>
<p>众所周知，ECMA只是规范的制定者，具体实现要看各家浏览器厂商。各大厂商在具体的实现中把这个指针命名为<strong>proto</strong>。通过双下划线的命名方式可以看出，这个属性是不期望被我们直接修改的，他只是一个指针，指向了构造函数的prototype属性，通过阅读mdn的文档也支出直接修改<strong>proto</strong>会产生许多问题，首先他只是浏览器厂商约定俗成的一个命名，并不规范所以肯能会被修改，其次还会产生性能为题，还有可能有命名冲突而导致新定义的属性或方法覆盖默认属性或方法的种种问题。</p>
<p>那么，现在我们知道，每通过使用new关键字创建一个新对象，新对象就会有一个属性，指向创建这个函数的prototype属性所指向的对象，也就是通过在函数与实例中各创建一个新属性，指向同一个对象的方法来实现方法及属性的公用。这个对象就是原型对象。函数的prototype属性指向这个对象，函数创建的对象，有一个属性（<strong>proto</strong>）也指向这个对象。</p>
<p>如上所述，不推荐直接在对象上更改<strong>proto</strong>来给这个公共对象添加属性及方法。所以我们一般通过函数的prototype来访问这个原型对象。同时，因为属性保存的只是一个指针，那么我们就不能修改这个指针，不然指向的就是其他对象了。</p>
<p>那么，我们有怎么知道这个原型对象是那个函数创建的呢？为了解决这个问题，回到函数创建时，我们在内存中开辟一块空间创建一个对象，同时给对象一个新属性，这个属性名规定为constructor，保存的时创建这个对象的函数的指针，然后再把这个对象的指针赋值给函数的prototype属性。</p>
<p>这样，因为函数创建的实例中保存着原型对象的指针，所以我们可以在函数创建的实例对象上访问constructor属性，在访问时，js会在实例对象的属性中查找，当查找不到时就会查找<strong>proto</strong>（这个属性名是被隐藏起来不希望我们修改的，但是我们可以访问，来实现方法属性的共享），这个属性保存的是一个指针，指向了与创建实例对象的函数的prototype属性所指向的同一个对象。在函数创建时，这个对象就自动创建了一个constructor，保存了只想这个函数的指针。所以访问实例对象的constructor属性时，经过这样一级级查找，就指向了创建对象的函数。</p>
<p>以上为了明确流程，减少思维负担，我把创建对象的函数就叫做函数，实际上，我们把这种用来创建对象的函数叫做构造函数。在js高级程序设计中强调，使用new关键字调用的函数才是构造函数，为了区分构造函数与普通函数，我们将构造函数的首字母名称大写。所以实际上，首字母大写是为了区分函数作用而约定俗成的，并不会改变函数的作用。在js高级程序设计中也强调，构造函数（用来创建实例对象）的函数直接使用括号调用，就与普通函数没有任何区别。通过解决方案2和解决方案3我们也可以看出：new关键字是为了简化我们创建对象流程而设计出的，如果不使用new关键字就直接调用简化后的函数，当然会导致许多问题。</p>
<p>顺便说一下，this指向当前作用域，我们使用new关键字调用构造函数时，会自动创建一个新对象，并将新对象的作用域绑定在this上，所以此时this可以理解为函数内创建的新对象，函数执行完之后，返回新对象的指针，将指针赋值为变量，此时变量就指向了通过构造函数创建的新对象，既新的实例对象。</p>
<p>理解原型对象，首先要理解函数也是对象，是Function的实例对象。所以函数可以也有属性和方法。每个函数创建时就会创建一个prototype属性，并且指向一个新创建的对象，这个新创建的对象有一个属性constructor，保存着这个函数的指针。所以我们可以手动的在函数内部把函数内新建的对象的一个属性赋值为函数prototype所保存的指针，也可以通过new关键字调用函数简化书写的流程，但是只是简化了书写的流程，过程还是一样的。</p>
<p>使用new关键字的代码大概等同如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserCreator</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span> = <span class="built_in">Object</span>.create(UserCreator.prototype) <span class="comment">// 创建一个新对象，并将this指向这个新对象，同时将新对象的__proto__指向函数的原型对象</span></span><br><span class="line">  <span class="keyword">this</span>.name = name <span class="comment">// 执行构造函数中的代码</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// 返回这个新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在js中，我们定义一个‘类‘，需要定义一个构造函数来创建实例对象，在构造函数内部我们实现创建实例对象的私有属性方法，在通过构造函数的原型对象来给所有的实例对象添加公共的属性和方法。</p>
<p>显而易见，为了定义一个’类‘，我们需要最少两段代码，但是其他语言中只需要一段。那么有没有什么办法解决这个问题呢？</p>
<h4 id="解决方案4："><a href="#解决方案4：" class="headerlink" title="解决方案4："></a>解决方案4：</h4><blockquote>
<p>Solution 4</p>
</blockquote>
<p>我们直接在构造函数本身编写公共的属性和方法（而不是在构造函数的原型对象上）</p>
<blockquote>
<p>We’re writing our shared methods separately from our object ‘constructor’ itself (off in the User.prototype object)</p>
</blockquote>
<p>其他语言可以让我们把所有内容都写在一起，ES2015的新功能可以使我们也这样写</p>
<blockquote>
<p>Other languages let us do this all in one place. ES2015 lets us do so too</p>
</blockquote>
<h5 id="class语法糖"><a href="#class语法糖" class="headerlink" title="class语法糖"></a>class语法糖</h5><blockquote>
<p>The class ‘syntactic sugar’</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span> (name, score)&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.score = score;</span><br><span class="line"> &#125;</span><br><span class="line"> increment ()&#123;</span><br><span class="line"> <span class="keyword">this</span>.score++;</span><br><span class="line"> &#125;</span><br><span class="line"> login ()&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"login"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> User(<span class="string">"Eva"</span>, <span class="number">9</span>);</span><br><span class="line">user1.increment();</span><br></pre></td></tr></table></figure>
<p>在前面也提到，构造函数也是普通函数，即使不适用new关键字也可以调用，但显然构造函数的作用与普通函数并不相同，如果不适用new关键字，很可能会产生一些意想不到的效果，也就是bug。为了区分构造函数与普通函数，我们约定了将所有构造函数的首字母大写，但这只是一个人为约定，即使不这样做也能正常使用构造函数。</p>
<p>为了解决代码分离及上述问题，es2015中提出了class解决方案。</p>
<p>通过上面的代码可以看出，我们使用class关键字定义一个类，在后面书写类名，然后使用{}把代码段包裹起来形成一个局部作用域。然后constructor(){}函数就是以前我们书写的构造函数，在这之后我们直接在这个类的作用域中添加公共的属性和方法，也就是之前prototype上添加的属性及方法。</p>
<p>可以看到，使用class与使用构造函数一样需要时会用new调用，使用new调用并传入参数时，会调用class内的constructor方法，并将参数传递给该方法，此时与之前调用构造函数的运行机制一样。</p>
<p>使用class类，我们并不需要深入理解js底层实现机制（对目前来说），就像课程刚开始所讲，我们没必要做一个彻底的researcher，这并不能帮我们写出条理清晰，容易调试，容错率高的代码，或者说帮助不大，但是我们一定到搞清楚它的作用。</p>
<p>js的类实现机制是建立在原型及原型链上的，与其他语言可能并不一致，这是js语言的特性。</p>
<p>优点：</p>
<blockquote>
<p>Benefits:</p>
</blockquote>
<ul>
<li>成为一种新的标准<blockquote>
<p>Emerging as a new standard</p>
</blockquote>
</li>
<li>与其他语言的风格感觉上更一致(例如Python)<blockquote>
<p>Feels more like style of other languages (e.g. Python)</p>
</blockquote>
</li>
</ul>
<p>缺点：</p>
<blockquote>
<p>Problems</p>
</blockquote>
<ul>
<li>99%的开发人员不知道它是如何工作的，因此无法通过面试<blockquote>
<p>99% of developers have no idea how it works and therefore fail interviews</p>
</blockquote>
</li>
</ul>
<p>class关键字定义类已经成为新的标准。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上，就是JavaScript: The Hard Part的学习笔记。在强调一遍，以上笔记是我用来总结思考所学内容的，来源于FrontEndMaster的付费课程。内容写的又乱又啰嗦，来源我也不是很确定是否可以转载。笔记只发表在我的个人博客，一般也不会有人来看。如果有人看到学到了，那么我很荣幸。如果看到觉得写得不好，有疏漏，不严谨，逻辑错误或根本性概念错误，那么真的欢迎批评指正。如果想转载，那么请先与我进行沟通，我不想要什么稿费，写得这么乱也不值几个钱，就像知道我的文章到底被谁用了，用在哪了。而且也会与FrontEndMaster那边沟通，看看是否可以转载。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/18/评判事情的标准/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/18/评判事情的标准/" class="post-title-link" itemprop="url">评判事情的标准</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-18 15:45:04 / 修改时间：15:51:21" itemprop="dateCreated datePublished" datetime="2019-04-18T15:45:04+08:00">2019-04-18</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随想/" itemprop="url" rel="index"><span itemprop="name">随想</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上个周末，观看了一个演讲，非常的有趣，恰好今天又想到了一些东西，就回忆总结一下，也算是一种刻意练习，希望能够真切的把这些道理记到脑子里，指导今后的思想。</p>
<p>视频的主题就是《工业党与情怀党》，也许有一天我会把视频再看一遍，希望到时候能把真切的标题补充上。</p>
<p>那么，什么是工业党？就是以事实为依据，以具体的数据来分析事实，不相信现有的结论，仔细分析推导结论的过程，这类人可以称作工业党。</p>
<p>情怀党呢？就是喜欢引用现有的结论，拿人家现有的结论来说事，典型例子就是公知大V引用了某某权威机构的报告，说中国经济形势如何如何。</p>
<p>事实也证明，屁股决定脑袋，权威机构也有立场，人是社会动物，有立场是人的天然属性。有立场就会导致结果可能就不客观，不可全信。联想到最近关注的996之类的话题，我认为确实如此。</p>
<p>总理也说过，看一个人，不但要听其言，更要观其行。行动体现了一个人面临当前情况所做的选择，体现了一个人面临一些情况的判断标准。所以有些人的语言会前后矛盾，但是行为一般不会。</p>
<p>再联想到今天所学习的计算机科学基础，当我们编程时会有静态的语法错误，一些编译器就可以直接检查出来的错误，这些错误其实相对好解决。那么，怕的是什么，就是一些编译器没有报错，但是结果不符合我们预期。那么，在计算的过程中，一定是计算步骤出现了结果，但是结果不是我们想要的，一步错，步步错。</p>
<p>计算机是绝对客观的，人是主观的，输入一个数据，给出一个计算过程，计算机就会返回一个计算好的结果。所以，出现了问题，就可能是用我们主观的思想想当然的给出了一个符合自己直觉的结果，而不是一个经过客观计算的结果，我想，这也就是静态类型语言和单元测试等手段的必要性。人终究是主观的，是按照直觉做事的，但有时直觉如果没有得到全面的验证，就不能说这个直觉很严谨。所以，当我们分析问题时，还是要严谨。</p>
<p>还有，当我们预期得到一个结果时，可以通过结果倒推过程，只要过程中产生的结果是符合预期的，那么最终的结果应该也是符合预期的，这也是函数式编程所拥有的优点之一吧。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/18/成为世界级工程师的五个原则/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/18/成为世界级工程师的五个原则/" class="post-title-link" itemprop="url">成为世界级工程师的五个原则</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-18 15:35:15 / 修改时间：17:12:30" itemprop="dateCreated datePublished" datetime="2019-04-18T15:35:15+08:00">2019-04-18</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/重要的事/" itemprop="url" rel="index"><span itemprop="name">重要的事</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="成为世界级工程师的五个原则"><a href="#成为世界级工程师的五个原则" class="headerlink" title="成为世界级工程师的五个原则"></a>成为世界级工程师的五个原则</h2><ol>
<li>Analytical problem solving with code<blockquote>
<p>分析问题并用代码解决的能力</p>
</blockquote>
</li>
<li>Technical communication （can I implement your approach just from your explanation）<blockquote>
<p>技术说明的能力（我能仅仅通过你的描述就能完成你所实现的功能吗）</p>
</blockquote>
</li>
<li>Engineering best practices and approach （Debugging，code structure,patience and reference to documentation)<blockquote>
<p>工程最佳实践和方法(调试、代码结构、耐心和参考文档)</p>
</blockquote>
</li>
<li>Non-technical communication(empathetic and thoughtful communication)<blockquote>
<p>非技术交流(有同理心、有思想的交流)</p>
</blockquote>
</li>
<li>Language and computer science experience<blockquote>
<p>语言和计算机科学经验</p>
</blockquote>
</li>
</ol>
<p>其重要性依次排列</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/16/闭包/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/16/闭包/" class="post-title-link" itemprop="url">闭包</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-16 14:24:10" itemprop="dateCreated datePublished" datetime="2019-04-16T14:24:10+08:00">2019-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 15:50:56" itemprop="dateModified" datetime="2019-04-18T15:50:56+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于闭包的理解"><a href="#关于闭包的理解" class="headerlink" title="关于闭包的理解"></a>关于闭包的理解</h2><p>理解闭包，首先要清楚垃圾回收</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>JavaScript高级程序设计中，对垃圾回收描述如下：</p>
<p>原理是找出那些不在使用的变量，然后释放其占用的内存。为此，垃圾收集器会在固定的时间间隔，周期性的进行垃圾回收。</p>
<p>那么，理解一个函数（函数作用域）中所定义的局部变量的声明周期就很重要。</p>
<p>函数在定义时，函数并没有被执行，函数体内的代码就没有效果。</p>
<p>函数调用时，函数体内的代码才开始执行，此时代码跳转到函数定义时。此时，就会新建一个作用域（注意，是函数定义时的作用域而不是函数调用时）。</p>
<p>在函数作用域内，我们把函数内的arguments及定义的变量（局部变量），打包成活动对象，此时垃圾回收器将会对其进行标记（进入环境），当函数执行完毕后，会被标记（离开环境）。注意，因为垃圾回收器时定时回收，此时只是标记并没有被回收。</p>
<p>当垃圾回收器的周期到达回收时，他会对所有的变量进行表示（我要回收你），然后对当前作用域中的变量以及被当前作用域中的变量引用的变量去除标记（我不回收你了）。然后回收。</p>
<p>所以，垃圾回收器的工作机制就是定期打标签，把被引用的就都去掉标签，然后回收掉有标签的。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在es5中，js只有全局作用域和函数作用域（es6中使用let关键词会把let外{}包裹的部分变为一个块级作用域）。</p>
<p>作用域内可以访问作用域外的变量，反之则不行。</p>
<h2 id="闭包时到底发生了什么"><a href="#闭包时到底发生了什么" class="headerlink" title="闭包时到底发生了什么"></a>闭包时到底发生了什么</h2><p>当一个函数定义时，函数体内的代码可以暂时忽略。</p>
<p>函数调用时，会跳转到函数定义时所在的作用域，并把作用域内的arguments伪数组及内部定义的变量打包成一个活动对象（如果内部定义了函数，那么这个活动函数也会被打包到对象内）。</p>
<p>因为js的垃圾回收机制是标记清除，如果最终这个对象没有引用了，就被清除。</p>
<p>但是，如果函数内部定义了一个函数，并且这个函数在外部被引用了，那么垃圾回收机制就不能把外部函数的活动对象标记清除，外部函数的活动对象就保存下来了。</p>
<p>那么在函数外部调用这个内部函数，因为也会在内部上执行创建活动对象，标记活动对象，清除活动对象这个过程。</p>
<p>因为内部函数的活动对象是内部函数作用域的变量，正好外部函数的活动对象还清除不了，所以就可以访问外部函数的活动对象。把这个对象保存的东西拿过来用。</p>
<p>这就应该是闭包了。</p>
<p>总结一下，只要内部函数指向了外部函数的外部，外部函数执行完之后的活动对象就不会被回收。</p>
<p>所以，缺点显而易见，影响自动垃圾回收，占用内存。</p>
<p>但是也可以使用这个特性来定义私有变量，因为只能通过内部函数访问到外部函数的活动对象。</p>
<p>最后，解决占用内存的办法也很简单，就是不在让外部函数的外面引用内部函数，这样垃圾回收机制就会进行标记，清空内存。</p>
<p>所以，看一个变量在不在可以分析它的生命周期及所处的作用域。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/关于debug的一些思考/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/15/关于debug的一些思考/" class="post-title-link" itemprop="url">关于debug的一些思考</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-15 10:00:07" itemprop="dateCreated datePublished" datetime="2019-04-15T10:00:07+08:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 15:45:45" itemprop="dateModified" datetime="2019-04-18T15:45:45+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/重要的事/" itemprop="url" rel="index"><span itemprop="name">重要的事</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于bug与debug"><a href="#关于bug与debug" class="headerlink" title="关于bug与debug"></a>关于bug与debug</h2><p>记得知乎上有人提问，为什么程序员不能做到bug free。上面的回答大概已经忘了，下面先写一下我目前的想法。</p>
<p>学编程如同学外语，我们要能够与计算机沟通，让他理解我们的想法，并且按照我们的想法做事。这就像管理一个team，个人的力量终究有限，我们要是一个team心往一处想，劲往一处使，才能完成许多一个人根本完不成的事。</p>
<p>那么，如果想要跟一个人沟通，我认为，要么让他学习怎样理解你的想法，要么让你去理解他的想法，所以我们有了语言。</p>
<p>通过生活常识我们也知道，不同地区有着不同的语言，那么我觉得计算机也可以看作为不同地区的人，只不过他很固执，只理解一些他理解的指令；但是计算机也很靠谱，只要给他相应的指令，他只返回唯一的结果。</p>
<p>那么，为什么有时计算机并没有按我们的预期返回相应的结果，我认为，是在与计算机沟通时出现了问题。</p>
<p>今天在学习时得到了一个建议，当你发现bug时不要仅仅是不断地尝试更改变量，更改顺序等并不断地运行看看结果是否符合预期，千万不要这样做。我非常赞同这一点，一个程序员，或者软件工程师，要有基本的科学素养。如果像刚才那样做了，那么最后会把你的编程变成一个经验主义：我之前这样做过，我不知道为什么，他成功了。</p>
<p>实际上，这也让我关联起了之前学到的两种知识类型，一种是声明式知识(可以类比为变量)，一种是程序性知识(可以类比为函数)。</p>
<p>我觉得，这也让我们的编程变成了一种声明式知识的累积。好好地一个函数，变成了一个变量。</p>
<p>一个函数，传入变量可以得到不同的，符合预期的结果；</p>
<p>一个变量，只是一个变量。</p>
<p>所以，当发生bug时我应该做什么？</p>
<p>刚才得到结论，计算机没有理解我的想法，他按照他的理解返回了一个结果。那么，中间哪一步出现了误解？<br>我的想法是什么，我的想法表述出来是什么意思，计算机又是怎么解读我的话，解读之后他又是怎么理解的？</p>
<p>bug出现在这中间的过程中，程序员不停地在于bug做斗争，实际上，也正是在尝试不断地让计算机不要曲解我们的意图，完成我们预期的想法。</p>
<p>程序员就像一个作家，想让读者读懂我们的文章，理解我们文章中表达的思想，那么，这有引申出来几个问题。</p>
<p>首先，在我们写文章时，我们的想法可能还不成熟，或者说很简单。</p>
<p>想法多了，写的字就多了，就要重新回顾，想办法精简，车轱辘话来回说很烦，虽然计算机不嫌烦，但是其他作者会说你文笔差，你将来自己看着也不好意思。</p>
<p>也有可能想法变了，人会进行思考，思考之后有可能就改变了之前的想法，就会出现自相矛盾，此时，计算机不理解了，说你之前不是这个意思啊，我按照那个想法来做呢，bug出现了，那么我们就要给他明确的指令。</p>
<p>所以，不要把debug当成一种负担，我的目标是利用计算思维，让计算机为我们工作，bug出现了，说明我们有机会修正我们的想法，使其更加符合计算思维。这样，就可以把debug看做一个学习的过程，你解决了这个问题，就掌握到了一项知识，这是多么的有趣！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/console控制台的一些用法/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/15/console控制台的一些用法/" class="post-title-link" itemprop="url">console控制台的一些用法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-15 06:53:06" itemprop="dateCreated datePublished" datetime="2019-04-15T06:53:06+08:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 15:37:55" itemprop="dateModified" datetime="2019-04-18T15:37:55+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于console控制台的一些用法"><a href="#关于console控制台的一些用法" class="headerlink" title="关于console控制台的一些用法"></a>关于console控制台的一些用法</h2><p>来自Wes Bos的<a href="https://courses.wesbos.com/account/access/5be7ff21c413951cd2b18ede/view/194129876" target="_blank" rel="noopener">JavaScript30</a>这个视频。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p onClick=<span class="string">"makeGreen()"</span>&gt;×BREAK×DOWN×&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    const dogs = [&#123; name: 'Snickers', age: 2 &#125;, &#123; name: 'hugo', age: 8 &#125;];</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    function makeGreen() &#123;</span></span><br><span class="line"><span class="regexp">      const p = document.querySelector('p');</span></span><br><span class="line"><span class="regexp">      p.style.color = '#BADA55';</span></span><br><span class="line"><span class="regexp">      p.style.fontSize = '50px';</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 当我们想知道哪段代码改变了页面上的DOM元素时，可以在页面上右键检查元素，然后在控制台右击控制台elements中的HTML代码部分</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 在右击后选择Break on中的Attibute modification，然后刷新浏览器，进行改变该DOM元素的操作，就可以调到对应的js代码块了</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 暂时可以联想为比较快捷的添加了断点，方便调试。</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Regular</span></span><br><span class="line"><span class="regexp">    console.log('hello')</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Interpolated</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 可以插入字符串</span></span><br><span class="line"><span class="regexp">    console.log('Hello I am a %s string!','✋')</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 也可是使用es6中的模板字符串</span></span><br><span class="line"><span class="regexp">    console.log(`Hello I am a 👌`)</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Styled</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 可以插入样式</span></span><br><span class="line"><span class="regexp">    console.log('%c I am a text','font-size:30px')</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ warning!</span></span><br><span class="line"><span class="regexp">    console.log('I am a warning')</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Error :|</span></span><br><span class="line"><span class="regexp">    console.log('I am a Error')</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Info</span></span><br><span class="line"><span class="regexp">    console.info('I am some info')</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Testing</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ console.assert类似if语句，传入两个参数，前一个是判断条件，下一个是执行语句</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 通过console.assert，如下可以方便判断是否有一个元素或者一些其他用法。</span></span><br><span class="line"><span class="regexp">    const p = document.querySelector('p')</span></span><br><span class="line"><span class="regexp">    console.assert(p.classList.contains('active'),'That is wrong!')</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ clearing</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 清空控制台</span></span><br><span class="line"><span class="regexp">    console.clear()</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 或者可以在控制台直接输如clear()，因为直接输入时作用域为当前对象，可以直接调用</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Viewing DOM Elements</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 当我们直接console.log(aDomElement)时，会输出一个HTML标签，无法查看他的属性和方法</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 使用console.dir(aDomElement)，就可以像查询对象一样出现他的属性和方法了。</span></span><br><span class="line"><span class="regexp">    console.log(p)</span></span><br><span class="line"><span class="regexp">    console.dir(p)</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Grouping together</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 可以把多个console.log包裹起来，是控制台更加易读。</span></span><br><span class="line"><span class="regexp">    dogs.forEach(dog =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      console.groupCollapsed(`$&#123;dog.name&#125;`)</span></span><br><span class="line"><span class="regexp">      console.log(`This is $&#123;dog.name&#125;`)</span></span><br><span class="line"><span class="regexp">      console.log(`$&#123;dog.name&#125; is $&#123;dog.age&#125; years old`)</span></span><br><span class="line"><span class="regexp">      console.log(`$&#123;dog.name&#125; is $&#123;dog.age * 7&#125; dog years old`)</span></span><br><span class="line"><span class="regexp">      console.groupEnd(`$&#123;dog.name&#125;`)</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ counting</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 顾名思义，计数器</span></span><br><span class="line"><span class="regexp">    console.count('num1')</span></span><br><span class="line"><span class="regexp">    console.count('num1')</span></span><br><span class="line"><span class="regexp">    console.count('num1')</span></span><br><span class="line"><span class="regexp">    console.count('num2')</span></span><br><span class="line"><span class="regexp">    console.count('num2')</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ timing</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 顾名思义，计时器</span></span><br><span class="line"><span class="regexp">    console.time('fetching data');</span></span><br><span class="line"><span class="regexp">    fetch('https:/</span><span class="regexp">/api.github.com/u</span>sers/wesbos<span class="string">')</span></span><br><span class="line"><span class="string">      .then(data =&gt; data.json())</span></span><br><span class="line"><span class="string">      .then(data =&gt; &#123;</span></span><br><span class="line"><span class="string">        console.timeEnd('</span>fetching data<span class="string">');</span></span><br><span class="line"><span class="string">        console.log(data);</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/培养学习时的习惯/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/培养学习时的习惯/" class="post-title-link" itemprop="url">培养学习时的习惯</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-14 10:27:56" itemprop="dateCreated datePublished" datetime="2019-04-14T10:27:56+08:00">2019-04-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 15:38:18" itemprop="dateModified" datetime="2019-04-18T15:38:18+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/重要的事/" itemprop="url" rel="index"><span itemprop="name">重要的事</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="培养学习时的习惯"><a href="#培养学习时的习惯" class="headerlink" title="培养学习时的习惯"></a>培养学习时的习惯</h2><p>为了达成成为一个出色的程序员的目标，我认为我应该不断的学习，学习一些声明式知识与程序性知识，并不断地用声明式知识与程序性知识来解决各种问题，完成我想要的功能。</p>
<p>所以，是不是可以这么总结 学习 =&gt; 解决问题 =&gt; 成为出色的程序员。或者说 学习新的知识 =&gt; 解决新的问题 =&gt; 成为更好的程序员。</p>
<p>那么，现在看来，学习是必不可少的过程。</p>
<p>现在拆分问题，如何更加好的学习。</p>
<p>可以养成几种习惯：</p>
<ul>
<li>记笔记</li>
<li>总结</li>
<li>复习</li>
<li>应用</li>
</ul>
<p>暂时写到这里，花了太长时间总结，这也不是一朝一夕的事情。复述一遍，Slow is fast,fast is slow.或者用中文，欲速则不达，我要把这句话与我之前半年时间总结的经验教训，联系起来，好记住它。</p>
<p>最后，还是重复一遍Practice Make Perfect！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg"
                alt="刘勇"/>
            
              <p class="site-author-name" itemprop="name">刘勇</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/blingblingredstar" title="GitHub &rarr; https://github.com/blingblingredstar" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:564447023@qq.com" title="E-Mail &rarr; mailto:564447023@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘勇</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  

  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
