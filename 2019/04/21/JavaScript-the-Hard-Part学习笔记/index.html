<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="此文为学习笔记，来源FrontEndMasters的同名课程，中间加入了一些个人理解，仅供将来复习使用。  因为内容来源于付费课程，但以下笔记基本为本人个人整理，目的是供个人理解复习所学内容，发布在个人博客中以便备份记录，所以如需转载请与本人联系确认，以免发生不必要的纠纷。  JavaScript的基本组成要素(Principles of JavaScript)传统的编译型语言逐行执行代码，现在j">
<meta name="keywords" content="FrontEndMasters,JavaScript基础,闭包,异步,执行上下文,回调函数">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript the Hard Part学习笔记">
<meta property="og:url" content="http://yoursite.com/2019/04/21/JavaScript-the-Hard-Part学习笔记/index.html">
<meta property="og:site_name" content="刘勇的博客">
<meta property="og:description" content="此文为学习笔记，来源FrontEndMasters的同名课程，中间加入了一些个人理解，仅供将来复习使用。  因为内容来源于付费课程，但以下笔记基本为本人个人整理，目的是供个人理解复习所学内容，发布在个人博客中以便备份记录，所以如需转载请与本人联系确认，以免发生不必要的纠纷。  JavaScript的基本组成要素(Principles of JavaScript)传统的编译型语言逐行执行代码，现在j">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-20T23:45:19.910Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript the Hard Part学习笔记">
<meta name="twitter:description" content="此文为学习笔记，来源FrontEndMasters的同名课程，中间加入了一些个人理解，仅供将来复习使用。  因为内容来源于付费课程，但以下笔记基本为本人个人整理，目的是供个人理解复习所学内容，发布在个人博客中以便备份记录，所以如需转载请与本人联系确认，以免发生不必要的纠纷。  JavaScript的基本组成要素(Principles of JavaScript)传统的编译型语言逐行执行代码，现在j">






  <link rel="canonical" href="http://yoursite.com/2019/04/21/JavaScript-the-Hard-Part学习笔记/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JavaScript the Hard Part学习笔记 | 刘勇的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">刘勇的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/JavaScript-the-Hard-Part学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘勇的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript the Hard Part学习笔记

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-21 07:34:14 / 修改时间：07:45:19" itemprop="dateCreated datePublished" datetime="2019-04-21T07:34:14+08:00">2019-04-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>此文为学习笔记，来源FrontEndMasters的同名课程，中间加入了一些个人理解，仅供将来复习使用。</p>
<blockquote>
<p>因为内容来源于付费课程，但以下笔记基本为本人个人整理，目的是供个人理解复习所学内容，发布在个人博客中以便备份记录，所以如需转载请与本人联系确认，以免发生不必要的纠纷。</p>
</blockquote>
<h2 id="JavaScript的基本组成要素-Principles-of-JavaScript"><a href="#JavaScript的基本组成要素-Principles-of-JavaScript" class="headerlink" title="JavaScript的基本组成要素(Principles of JavaScript)"></a>JavaScript的基本组成要素(Principles of JavaScript)</h2><p>传统的编译型语言逐行执行代码，现在js使用所谓的<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">及时汇编(Just In Time Compilation)</a>，至少是在Chrome编译执行时是这样（v8引擎的特性），但基本上也是逐行解析的。</p>
<p>如果我们自己解析存储数据，转换数据，并且逐行运行代码，那么就可以理解所有的js代码。</p>
<p>js不会初始化函数体内的代码，直到函数被调用。直到函数被调用之前，函数体内的代码没有意义。所以在函数执行前不要进入函数体，永远！线程或进程永远不会再函数调用之前执行函数体内的代码。只有在函数被调用时，线程或进程才会进入函数体内执行函数体内的代码。（所以其实函数是个锦囊？在满足条件前你也不知道锦囊里写了啥，因为锦囊有可能永远用不到，当满足条件，我们就打开锦囊，按照锦囊里的办法处理当前情况，所以是不是闭包也可以跟锦囊联系起来？我们打开一个锦囊，用完就扔了。但是如果锦囊里面有个锦囊，说我有可能用到（被外部引用），而且你得照着外面锦囊里说的啥啥啥来办，那么这两个锦囊都扔不了）。</p>
<h3 id="全局执行上下文-global-execution-context"><a href="#全局执行上下文-global-execution-context" class="headerlink" title="全局执行上下文(global execution context)"></a>全局执行上下文(global execution context)</h3><p>我们开始运行代码时，开始创建全局执行上下文。执行上下文是一个比较唬人的名词，但是表示了两个简单的事。</p>
<ul>
<li>执行线程（一行行的转化并执行代码）</li>
<li>创建内存空间存储变量及数据</li>
</ul>
<p>这是全局执行上下文，在文件刚刚开始运行时创建，是一个全局环境。</p>
<h3 id="js中的线程-Thread"><a href="#js中的线程-Thread" class="headerlink" title="js中的线程(Thread)"></a>js中的线程(Thread)</h3><ul>
<li>Single thread(one thing at a time)</li>
<li>Synchronous ececution(for now)</li>
</ul>
<p>众所周知，js是单线程的，既只有一个线程，也就是只能同时做一件事。那么执行顺序呢？同步进行，既一步一步，顺序执行，不会跳过当前的代码。</p>
<h3 id="本地执行上下文-local-execution-context"><a href="#本地执行上下文-local-execution-context" class="headerlink" title="本地执行上下文(local execution context)"></a>本地执行上下文(local execution context)</h3><p>调用函数(running/calling/invoking a functiong)与定义一个函数不同</p>
<p>当我们定义函数时，加上function关键字即可，当我们调用函数时，要在函数体后加上括号。（为了避免每次调用就重新写一遍函数，我们给函数命名一遍重复调用。并且因为不知道何时调用，我们暂时把函数体的代码放在内存中，当调用时直接访问内存，调用内存中的代码即可，所以如果我们想立即执行函数，可以直接把函数包起来，直接加括号调用，就是立即执行函数，应为垃圾回收机制，我们只想执行一次函数，用完就销毁，就可以不给函数命名，这样函数在内存中就没有其他引用，再直接加括号，那么函数执行完之后就会因为没有其他引用被垃圾回收机制销毁，这应该就是匿名立即执行函数）</p>
<p>当我们调用一个函数时，就创建了由以下两点组成的一个新的执行上下文(creat a new execution context comprising)：</p>
<ol>
<li>执行线程(thread of execution)，在函数内逐行解析代码。</li>
<li>一个本地存储空间(local memory){变量环境(Variable environment)}，其中存储函数中定义的任何内容。</li>
</ol>
<p>函数在执行结束前，返回的值就是undefined，函数内只定义了操作数据的方法，在执行结束后，才知道经过函数操作的数据内容也就是函数的返回值。函数并不关心输入与输出，函数本身只定义了方法。分析一个函数式，可以通过画图，左侧是线程区，右侧是内存区，代码沿着线程区顺序执行，在内存区存储相应的变量。</p>
<p>函数体内没有函数时，一切都很简单。但是，如果函数内调用了另一个函数，如果递归的调用函数呢？我们怎么追踪他们呢？</p>
<p>通过调用堆栈。</p>
<h3 id="调用堆栈-Call-Stack"><a href="#调用堆栈-Call-Stack" class="headerlink" title="调用堆栈(Call Stack)"></a>调用堆栈(Call Stack)</h3><p>调用堆栈是一种特殊的数据结构，是一种存储数据信息的存储方式。一种能够使我们追踪到我们现在进行到哪，js现在解析到哪，线程现在执行到哪的特殊数据结构。</p>
<p>调用堆栈遵循先进后出的原则（可以看做一个桶，最先放入的最后拿出），全局执行上下文首先进入调用堆栈 <strong>（在调用堆栈的最上方就是js线程当前执行的环境）</strong> 。通过这个调用堆栈先进后出的这个机制，js解析器不用关心具体执行代码的所在位置，只关心调用堆栈最上方的执行上下文即可。当函数执行完毕时，执行上下文销毁，此时调用堆栈就回到了全局执行上下文。那么，把一个执行上下文添加到调用堆栈怎么说呢，<strong>pushing</strong>。怎么知道函数执行完毕呢（没有return的情况下），当线程执行完函数体内代码({}号内的代码)，会默认return一个undefined（这也是Chrome console中会不显式返回的情况下输出undefined的原因，既隐式返回了undefined）。把一个执行上下文从堆栈中删除怎么说呢，<strong>poping</strong>。</p>
<p>总结一下，当执行一个函数时，你创建了一个新的执行上下文，这个执行上下文包含一个线程，他逐行执行函数体内的代码，此时也开辟了一个局部存储空间(local memory)，用来存储任何不在全局存储空间(global memory)的变量及数据。此时，将这个执行上下文推到调用堆栈的顶部，js就会执行这个函数，执行完毕后，会将这个执行上下文推出调用堆栈，js继续执行调用堆栈顶部的执行上下文（既当前执行上下文的前一个执行上下文）。</p>
<p>这个本地存储空间(local memory)有一个学术化的名称–<strong>可变环境(environment of available variants)</strong>。</p>
<p>当我们定义一个函数时，我们只是在内存中开辟了一段空间存储定义函数的代码，所以如果console.log(函数名)，就会输出定义函数的代码(试验了一下，发现箭头函数和普通函数的输出内容并不一样，说明两者并不同)。</p>
<h3 id="三个基本元素"><a href="#三个基本元素" class="headerlink" title="三个基本元素"></a>三个基本元素</h3><p>执行上下文(execution context)，线程(thread)，调用堆栈(call stack)</p>
<p>深入了解js执行机制，不是出于理论目的，不是为了求知欲，我们了解这些是因为这些可以帮助我们debug，写一些干净的代码，使我们的想法实现的可能性更高。我们只需要了解其特性，并不需要我们了解具体如何实现，应为这对我们编程并没有影响。</p>
<h2 id="函数式编程-Funcitional-Programming"><a href="#函数式编程-Funcitional-Programming" class="headerlink" title="函数式编程(Funcitional Programming)"></a>函数式编程(Funcitional Programming)</h2><h3 id="纯粹的函数-Pure-Functions"><a href="#纯粹的函数-Pure-Functions" class="headerlink" title="纯粹的函数(Pure Functions)"></a>纯粹的函数(Pure Functions)</h3><p>函数式编程是一种编程范式，关于我们构建和思考如何大规模编写代码的方式。一般我们认为代码质量的评判标准是效率和性能，实际上评判代码的好坏更多的是其他开发人员是否能够快速读懂并添加功能。<br>在过去，最流行的编程范式是面相对象编程(OOP)，函数式编程是另一种构建代码的方式。<br>函数式编程有两个核心原则：</p>
<ul>
<li>纯粹的函数（没有副作用）<blockquote>
<p>Pure functions(no side effects)</p>
</blockquote>
</li>
<li>高阶函数<blockquote>
<p>Higher order functions - highly valuable tool &amp; often part of the Codesmith interview</p>
</blockquote>
</li>
</ul>
<p>纯粹函数追求的是除了函数的return值之外不改变其他任何值，函数中只存在用完即销毁的局部变量，函数内部没有改变(mutating)任何全局变量或不是函数内的变量。当我们改变了任何不属于函数内部的变量，会使得我们测试我们代码更加困难，增加了需要测试的范围。但是当函数除了返回值之外不做任何其他事，那么就可以在测试时只关心返回值得内容。</p>
<p>作为一个软件工程师，我们有函数，所以，Don’t repeat yourself.函数出现的原因就是我们想要重复使用相同的功能，我们把他封装起来，通过一个标志来在需要的时候找到并引用它，这样，我们就可以只写一次，可以重复使用多次。这不仅仅是因为我们懒惰，更是为了写出更多可读的代码，可以重用的代码。我们不想要在需要修改同一个功能时修改多处，有了函数，我们只要修改一次。</p>
<p>函数有定义阶段和调用阶段，定义阶段，我们把函数的参数叫为形参(parameter)，就像二元一次方程中的x，是一个未知数。在调用阶段，我们会给函数一个实参(argument)，此时就是二元一次方程中明确告诉了x的值，只需要代入算式即可。所以其实形参只是一个占位符(placeholder)，代表了可能会传入函数的值，我们定义函数如何对占位符进行操作，在传入具体的参数时，我们只需要将具体值带入占位符即可。既然形参是一个站位符，那么我们是不是可以留一个占位符，代表了一些特定的功能，这个功能的返回值目前还不知道，只有调用这个功能时才能确认这个返回值呢？功能的英文就是function，翻译一下，就是我们的返回值是不是可以是一个函数？所以这个占位符代表的不是具体的数据，而是一个功能，这个函数目前没有返回值，因为只是定义没有调用，只有调用时，才能知道返回值。这应该就是高阶函数的本质。</p>
<h2 id="回调函数和高阶函数-callbacks-and-high-order-functions"><a href="#回调函数和高阶函数-callbacks-and-high-order-functions" class="headerlink" title="回调函数和高阶函数(callbacks and high order functions)"></a>回调函数和高阶函数(callbacks and high order functions)</h2><p>下面我们要进入一个精彩的编程世界。</p>
<p>下面是一个列表</p>
<ul>
<li>I know what a variable is<blockquote>
<p>我知道什么是变量</p>
</blockquote>
</li>
<li>I’ve creat a function before<blockquote>
<p>我之前写过一个函数</p>
</blockquote>
</li>
<li>I’ve add a CSS style before<blockquote>
<p>我之前写过一个CSS样式</p>
</blockquote>
</li>
<li>I’ve implement a sort algorithm(bubble,merge,etc)<blockquote>
<p>我之前完成过一个排序算法（冒泡、并归排序等）</p>
</blockquote>
</li>
<li>I can add a method to an object’s prototype<blockquote>
<p>我能在一个对象的原型上添加方法</p>
</blockquote>
</li>
<li>I understand the event loop in JavaScript<blockquote>
<p>我理解JavaScript的事件循环</p>
</blockquote>
</li>
<li>I understand callback functions<blockquote>
<p>我理解回调函数</p>
</blockquote>
</li>
<li>I’ve built a project in React or Angular<blockquote>
<p>我写过一个React或Angular项目</p>
</blockquote>
</li>
<li>I can handle collisions in hash tables<blockquote>
<p>我可以处理哈希表中的冲突</p>
</blockquote>
</li>
</ul>
<p>通过判断列表中所掌握的项目数量，我们可以给自己打一个分数（共九项，一至九分）。</p>
<p>这里提出了一个概念，成为一个初级开发人员相对容易，但是想要成为一个能够自主解决中级或高级问题的开发人员很难，这中间有一个陡峭的学习难度趋势图。</p>
<blockquote>
<p>我认为既是遵循了帕累托的二八原则，既想要获得百分之八十的成果需要百分之二十的努力，但想要获得剩余百分之二十的成果需要付出百分之八十的努力。</p>
</blockquote>
<h3 id="学习困难的事"><a href="#学习困难的事" class="headerlink" title="学习困难的事"></a>学习困难的事</h3><p>在刚开始，我们只需要学习一些简单的事情即可成为一个”初级“开发者，但是要成为一个”高级开发者“，我们要学习一些难度很大的知识。就像完成一个edX课程并做完所有测试，或者Coursera的课程。当我们遇到了一个难题，我们的大脑会尝试让我们转移我们的注意力，去喝杯咖啡或者什么，但这就是我们成长的过程，必不可少。在我们学习困难的事(hard learning)时我们很容易想到放弃，但学习困难的事让我们成长。</p>
<p>即使我们没有放弃学习困难的事(刚开始我理解为努力学习，但我觉得并不准确，暂时就用学习困难的事理解)，我们仍面临两种选择。</p>
<p>在我们学习困难的事的过程中，例如LeetCode刷题或者看一个复杂项目的官方文档，你会发现你练单词都看不懂，例如LeetCode题意是啥都不明白，webpack的插件(plugin)和loading等概念。我们会做什么，我们可能会花一天时间去研究相关概念，在一天的结束时甚至没有敲一行代码，这就落入了一个<strong>研究者陷阱</strong>。</p>
<p>另一种，Stack Overflow型，我们遇见问题，去社区提问，有人之前遇到过，解决代码是这样，好，复制粘贴。什么？还是有问题？再找一个帖子，帖子里有另一段代码，复制粘贴，看看能不能解决问题。什么？还是不行。好吧，把问题和这两段代码一起发到社区上问问别人。这算是一种<strong>Stack Overflow方法</strong>。此时我们只是努力让程序正常跑起来，但是并不知道具体怎么跑起来的。</p>
<p>这里提出了结对编程的解决方案。在之前的两种情况中（一种我必须了解一切，一种我只是想让他发挥作用）折中的方案。结对编程的核心原则就是自己不写代码，而是由你像与你水平相当的小伙伴解释你的伪代码，让你的小伙伴来负责具体的代码实现。那么，如果想要解释清楚，就必须理解你的伪代码，但是也不需要理解的特别深入，因为你的小伙伴在等待你的解释。你也不能直接开始写代码，你的目的是通过代码逐行说话，把他变成实际的代码。所以你只能在这两种情况的中间（必须了解一切，但永远不会make hands dirty；什么都不懂，但是一直在敲自己不懂的代码来实现功能）。就像飞驰人生里的拉力赛，有一个领航员，一个车手，领航员负责指路，车手负责开车。实际也就是把分析写出伪代码和代码实现交给两个人，这样就可以使得每个人只专注与自己的部分，就像画画先画出轮廓，再填充细节，画轮廓时应该只关心轮廓，画细节时只关心当前部分的细节。而不是注意力来回跳转（话说有人似乎这么画画，但这不是我们选择的方式）。</p>
<h3 id="回调和高阶函数练习"><a href="#回调和高阶函数练习" class="headerlink" title="回调和高阶函数练习"></a>回调和高阶函数练习</h3><blockquote>
<p><a href="http://csbin.io/callbacks" target="_blank" rel="noopener">callbacks</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type JavaScript here and click "Run Code" or press Ctrl + s</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello, world!'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 1</span></span><br><span class="line"><span class="comment">// Create a function addTwo that accepts one input and adds 2 to it.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To check if you've completed it, uncomment these console.logs!</span></span><br><span class="line"><span class="comment">// console.log(addTwo(3));</span></span><br><span class="line"><span class="comment">// console.log(addTwo(10));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 2</span></span><br><span class="line"><span class="comment">// Create a function addS that accepts one input and adds an "s" to it.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addS</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> word += <span class="string">'s'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uncomment these to check your work</span></span><br><span class="line"><span class="built_in">console</span>.log(addS(<span class="string">'pizza'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(addS(<span class="string">'bagel'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Create a function called map that takes two inputs:</span></span><br><span class="line"><span class="comment">1.an array of numbers (a list of numbers)</span></span><br><span class="line"><span class="comment">2.a 'callback' function - a function that is applied to each element of the array (inside of the function 'map')</span></span><br><span class="line"><span class="comment">Have map return a new array filled with numbers that are the result of using the 'callback' function on each element of the input array.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">array, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []<span class="comment">// 创建一个新数组，最后返回这个数组</span></span><br><span class="line">  <span class="comment">// 遍历传入的数组，并将每一项经callback处理后添加到新数组中</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    arr.push(callback(array[i]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr<span class="comment">// 返回处理过的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], addTwo));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Challenge 4</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The function forEach takes an array and a callback, and runs the callback on each element of the array. forEach does not return anything.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; array.length; i++)&#123;</span><br><span class="line">    array[i] = callback(array[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// see for yourself if your forEach works!</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">forEach(arr3,addTwo)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`forEach <span class="subst">$&#123;arr3&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------</span></span><br><span class="line"><span class="comment">// Extension</span></span><br><span class="line"><span class="comment">//--------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Extension 1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  In the first part of the extension, you're going to rebuild map as mapWith. This time you're going to use forEach inside of mapWith instead of using a for loop.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapWith</span>(<span class="params">array, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [] <span class="comment">// 创建一个新数组</span></span><br><span class="line">  forEach(array, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="comment">// 使用forEach遍历数组</span></span><br><span class="line">    arr.push(callback(item)) <span class="comment">// 遍历时把数组的每一项都经callback处理后添加到新数组中</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr <span class="comment">// 返回新数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`mapWith <span class="subst">$&#123;mapWith([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], addTwo)&#125;</span>`</span>)</span><br><span class="line"><span class="comment">//Extension 2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The function reduce takes an array and reduces the elements to a single value. For example it can sum all the numbers, multiply them, or any operation that you can put into a function.</span></span><br><span class="line"><span class="comment">    var nums = [4, 1, 3];</span></span><br><span class="line"><span class="comment">    var add = function(a, b) &#123; return a + b; &#125;</span></span><br><span class="line"><span class="comment">    reduce(nums, add, 0);   //-&gt; 8</span></span><br><span class="line"><span class="comment">    0 + 4 = 4 =&gt; 4 + 1 = 5 =&gt; 5 + 3 = 8</span></span><br><span class="line"><span class="comment">  Here's how it works. The function has an "accumulator value" which starts as the initialValue and accumulates the output of each loop. The array is iterated over, passing the accumulator and the next array element as arguments to the callback. The callback's return value becomes the new accumulator value. The next loop executes with this new accumulator value. In the example above, the accumulator begins at 0. add(0,4) is called. The accumulator's value is now 4. Then add(4, 1) to make it 5. Finally add(5, 3) brings it to 8, which is returned.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">array, callback, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> total = initialValue <span class="comment">// 创建一个变量，记录最后的结果</span></span><br><span class="line">  forEach(array,item =&gt; &#123; <span class="comment">// 遍历输入的数组</span></span><br><span class="line">    total = callback(item, total) <span class="comment">// 计算经callback处理后的当前项和前一项的值，保存在total中</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> total <span class="comment">// 返回最终结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(reduce(nums, add, <span class="number">0</span>))</span><br><span class="line"><span class="comment">//Extension 3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Construct a function intersection that compares input arrays and returns a new array with elements found in all of the inputs. BONUS: Use reduce!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">arrays</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrs = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>) <span class="comment">// 先把实参转化为数组</span></span><br><span class="line">  <span class="keyword">return</span> reduce(arrs, (previous, next) =&gt; &#123; <span class="comment">// 遍历实参的每一项，对上次操作的结果和当前项进行操作，得出结果，供下一次循环与下一项一同传入函数进行操作</span></span><br><span class="line">    <span class="keyword">const</span> arr = [] <span class="comment">// 定义一个变量，存储交集数组</span></span><br><span class="line">    <span class="keyword">if</span> (previous.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="comment">// 因为初始化值是空的，直接跳到下一项，此时previous代表第一项，next是参数第二项</span></span><br><span class="line">    forEach(next, item =&gt; &#123; <span class="comment">// 对第二项进行遍历</span></span><br><span class="line">      <span class="keyword">if</span>(previous.includes(item))&#123; <span class="comment">// 如果第二项的值包含在第一项中</span></span><br><span class="line">        arr.push(item) <span class="comment">// 把值添加到交集数组</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr<span class="comment">// 返回交集数组供下一次操作使用，下次执行时，previous为第二项，next为第三项</span></span><br><span class="line">  &#125;,[]) <span class="comment">// 返回最终的交集数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(intersection([<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>], [<span class="number">15</span>, <span class="number">88</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">20</span>]));</span><br><span class="line"><span class="comment">// should log: [5, 15]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Extension 4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">arrays</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrs = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>) <span class="comment">// 把实参转化为数组</span></span><br><span class="line">  <span class="comment">// 使用reduce函数，输入这个数组，传入一个callback处理这个数组，返回一个新数组</span></span><br><span class="line">  <span class="keyword">return</span> reduce(arrs, (previous, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 传入两个数组，进行去重</span></span><br><span class="line">    forEach(next, item =&gt; &#123;  <span class="comment">// 遍历第二个数组，此时previous为空数组，next为实参的第一个数组</span></span><br><span class="line">      <span class="keyword">if</span>(!previous.includes(item)) &#123; <span class="comment">// 如果在第一个数组中不包含第二个数组的这一项</span></span><br><span class="line">        previous.push(item) <span class="comment">// 就添加到第一个数组中</span></span><br><span class="line">      &#125; </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> previous<span class="comment">// 最终返回一个数组，数组中没有重复的项，下次调用时previous为此数组，next为实参的第二个数组</span></span><br><span class="line">  &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(union([5, 10, 15], [15, 88, 1, 5, 7], [100, 15, 10, 1, 5]));</span></span><br><span class="line"><span class="comment">// should log: [5, 10, 15, 88, 1, 7, 100]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Extension 5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objOfMatches</span>(<span class="params">array1, array2, callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(objOfMatches(['hi', 'howdy', 'bye', 'later', 'hello'], ['HI', 'Howdy', 'BYE', 'LATER', 'hello'], function(str) &#123; return str.toUpperCase(); &#125;));</span></span><br><span class="line"><span class="comment">// should log: &#123; hi: 'HI', bye: 'BYE', later: 'LATER' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Extension 6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiMap</span>(<span class="params">arrVals, arrCallbacks</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(multiMap(['catfood', 'glue', 'beer'], [function(str) &#123; return str.toUpperCase(); &#125;, function(str) &#123; return str[0].toUpperCase() + str.slice(1).toLowerCase(); &#125;, function(str) &#123; return str + str; &#125;]));</span></span><br><span class="line"><span class="comment">// should log: &#123; catfood: ['CATFOOD', 'Catfood', 'catfoodcatfood'], glue: ['GLUE', 'Glue', 'glueglue'], beer: ['BEER', 'Beer', 'beerbeer'] &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="关于const和let"><a href="#关于const和let" class="headerlink" title="关于const和let"></a>关于const和let</h3><p>我们应该尽量使用const定义变量，除非我们知道我们想要改变这个变量的值（重新给这个变量分配新的数据）。</p>
<h3 id="广义函数-generalizing-functiongs"><a href="#广义函数-generalizing-functiongs" class="headerlink" title="广义函数(generalizing functiongs)"></a>广义函数(generalizing functiongs)</h3><p>这里举了个例子，我们写了一个function，给输入的数组每一项乘以2，返回一个处理后的数组；又写了一个function，给输入数组每一项加上2，返回一个处理后的数组；再写一个，给每一项除以2，返回一个处理后的数组。可以看出，function其他部分都一样，你要新建一个数组，给每一项加上/乘以/除以二，返回一个新数组。</p>
<p>那么，我们就违反了一个编程原则：Don’t repeat your self!</p>
<h3 id="解构广义函数-deconstructing-generalize-function"><a href="#解构广义函数-deconstructing-generalize-function" class="headerlink" title="解构广义函数(deconstructing generalize function)"></a>解构广义函数(deconstructing generalize function)</h3><p>我们可以把对每一项的处理变成一个函数，但是这个函数是不确定的，需要我们作为参数传入传入，只有在函数执行时，才知道传入的函数是什么，这就是callback。</p>
<p>在上面的例子中，我们把对每一项的处理的部分用一个占位符代替（callback），并在占位符后加括号代表这是一个function（函数），把需要处理的项作为实参传递到函数中。但是在执行这段代码前，这只是一个占位符。</p>
<p>在函数外部，我们定义一个函数，有一个形参，函数体内写入我们想要如何操作这个形参的代码，在这个阶段，函数体内的代码也没有执行，只是进行了定义。</p>
<p>最后，我们调用第一个函数，传入数据和第二个函数。在执行到处理数据的每一项时，每次处理js就执行第二个函数，把每一项作为实参传入第二个参数，返回一个新的值，添加到新数组中。</p>
<p>通过这种方法，我们降低了代码的耦合性，是的代码的复用度更高。</p>
<p>在问答环节，强调了函数的变量名只是一个占位符，并没有具体的值，只有在执行时才会发挥作用。</p>
<h3 id="第一等对象-first-class-object"><a href="#第一等对象-first-class-object" class="headerlink" title="第一等对象(first-class object)"></a>第一等对象(first-class object)</h3><p>在js中，functions是第一等对象(frist-class objects)，这意味着函数像对象一样，我们可以传递一个对象作为函数的参数，那么，我们当然也可以传递一个函数作为参数。在js中，只有七种数据类型，其中六种是基本数据类型（Number、String、Null、Undefined、Boolean、Symbol）,一种复杂数据类型（Object），Array、Date、RegExp、Function都是Object的一种，是引用类型。传递基本类型是，我们直接传递基本类型的值，传递复杂数据类型或叫引用数据类型时，我们传递的是引用（指针）。</p>
<p>函数作为引用类型，可以直接把指针分配给变量，称作函数表达式，也可以作为其他对象的属性，此时我们一般把这个函数叫做这个对象的方法，函数还可以作为其他函数的参数，这些都是因为函数是一种对象，是一个引用类型，可以把指针进行传递，在需要的时候进行调用。</p>
<p>这就是函数在js中最为美妙的部分。</p>
<p>函数与相对于普通对象，有个一美妙的特性，你可以使用()调用。</p>
<h3 id="回调与高阶函数-callbacks-and-high-order-functions"><a href="#回调与高阶函数-callbacks-and-high-order-functions" class="headerlink" title="回调与高阶函数(callbacks and high order functions)"></a>回调与高阶函数(callbacks and high order functions)</h3><p>我们传递给外部函数作为参数的函数叫做回调函数，接收这个函数作为参数的外部函数叫做高阶函数（他接受了一个函数，可以在函数内部实现其他函数的功能，所以级别比一个普通函数更高）。</p>
<p>接受一个函数作为参数或者返回一个函数作为输出结果的函数叫做高阶函数。</p>
<p>这只是描述这些函数的一个术语 - 我们把有这些行为（函数作为参数或返回一个函数）的函数叫做高阶函数 - 但是它们与普通函数本质上没有什么不同。</p>
<p>那么，既然高阶函数跟普通函数没有什么不同，为什么要提出这么一个概念呢？</p>
<p>高阶函数简化了我们的代码，使他们更加易读。(So callbacks and high order functions simplify our code and keep it DRY)</p>
<p>通过上面的例子我们可以清晰地看到这一点。</p>
<p>并且，高阶函数有更为强大的应用。(and they do something even powerful)</p>
<p>通过高阶函数，我们可以异步执行代码。(they allow us to run asynchronous code)</p>
<h2 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h2><p>当我们使用括号调用一个函数时，我们创建了一个变量环境(variable environment)，一般称作本地存储空间(local memory)，用于存储函数内定义的变量（本地变量，arguments等）。当函数执行完毕时，函数创建的执行上下文被调用栈推出，变量环境被销毁，<strong>除了函数的返回值</strong>。除了函数的返回值，函数的所创建的其他数据被垃圾回收机制回收删除，释放所占用的内存。那么，有没有一种办法能够在函数调用之前就保存一些数据呢？在一些情况下，我们希望函数能够保存一些数据，而不是每次都创建新的数据并在结束时全部回收（复杂计算的结果，之前运行的次数等情况）。这就是闭包存在的价值，他改变了我们编写代码的方式。这一切都从在一个函数内返回另一个函数开始。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a function createFunction that creates and returns a function. When that created function is called, it should print "hello".</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNCOMMENT THESE TO TEST YOUR WORK!</span></span><br><span class="line"><span class="keyword">var</span> function1 = createFunction();</span><br><span class="line">function1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Create a function createFunctionPrinter that accepts one input and returns a function. When that created function is called, it should print out the input that was used when the function was created.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionPrinter</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(input)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNCOMMENT THESE TO TEST YOUR WORK!</span></span><br><span class="line"><span class="keyword">var</span> printSample = createFunctionPrinter(<span class="string">'sample'</span>);</span><br><span class="line">printSample();</span><br><span class="line"><span class="keyword">var</span> printHello = createFunctionPrinter(<span class="string">'hello'</span>);</span><br><span class="line">printHello();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Examine the code for the outer function. Notice that we are returning a function and that function is using variables that are outside of its scope.</span></span><br><span class="line"><span class="comment">  Uncomment those lines of code. Try to deduce the output before executing.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>; <span class="comment">// this variable is outside incrementCounter's scope</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">incrementCounter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter ++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'counter'</span>, counter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> incrementCounter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> willCounter = outer();</span><br><span class="line"><span class="keyword">var</span> jasCounter = outer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncomment each of these lines one by one.</span></span><br><span class="line"><span class="comment">// Before your do, guess what will be logged from each function call.</span></span><br><span class="line"></span><br><span class="line">willCounter();<span class="comment">//1</span></span><br><span class="line">willCounter();<span class="comment">//2</span></span><br><span class="line">willCounter();<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">jasCounter();<span class="comment">//1</span></span><br><span class="line">willCounter();<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Now we are going to create a function addByX that returns a function that will add an input by x.</span></span><br><span class="line"><span class="comment">    var addByTwo = addByX(2);</span></span><br><span class="line"><span class="comment">    addByTwo(1); //should return 3</span></span><br><span class="line"><span class="comment">    addByTwo(2); //should return 4</span></span><br><span class="line"><span class="comment">    addByTwo(3); //should return 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    var addByThree = addByX(3);</span></span><br><span class="line"><span class="comment">    addByThree(1); //should return 4</span></span><br><span class="line"><span class="comment">    addByThree(2); //should return 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    var addByFour = addByX(4);</span></span><br><span class="line"><span class="comment">    addByFour(4); //should return 8</span></span><br><span class="line"><span class="comment">    addByFour(10); //should return 14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addByX</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addByTwo = addByX(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now call addByTwo with an input of 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'addByTwo with 1'</span>,addByTwo(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// now call addByTwo with an input of 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'addByTwo with 2'</span>,addByTwo(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------</span></span><br><span class="line"><span class="comment">// Extension</span></span><br><span class="line"><span class="comment">//--------------------------------------------------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write a function once that accepts a callback as input and returns a function. When the returned function is called the first time, it should call the callback and return that output. If it is called any additional times, instead of calling the callback again it will simply return the output value from the first time it was called.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>,</span><br><span class="line">      result = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">      result = func(...arg)</span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onceFunc = once(addByTwo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNCOMMENT THESE TO TEST YOUR WORK!</span></span><br><span class="line"><span class="built_in">console</span>.log(onceFunc(<span class="number">4</span>));  <span class="comment">//should log 6</span></span><br><span class="line"><span class="built_in">console</span>.log(onceFunc(<span class="number">10</span>));  <span class="comment">//should log 6</span></span><br><span class="line"><span class="built_in">console</span>.log(onceFunc(<span class="number">9001</span>));  <span class="comment">//should log 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write a function after that takes the number of times the callback needs to be called before being executed as the first parameter and the callback as the second parameter.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">count, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> innerCount = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(innerCount &lt; count)&#123;</span><br><span class="line">      innerCount += <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      func()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> called = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'hello'</span>) &#125;;</span><br><span class="line"><span class="keyword">var</span> afterCalled = after(<span class="number">3</span>, called);</span><br><span class="line"></span><br><span class="line">afterCalled(); <span class="comment">// -&gt; nothing is printed</span></span><br><span class="line">afterCalled(); <span class="comment">// -&gt; nothing is printed</span></span><br><span class="line">afterCalled(); <span class="comment">// -&gt; 'hello' is printed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Write a function delay that accepts a callback as the first parameter and the wait in milliseconds before allowing the callback to be invoked as the second parameter. Any additional arguments after wait are provided to func when it is invoked. HINT: research setTimeout();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  clearTimeout(timeout)</span><br><span class="line">  timeout = setTimeout(func, wait)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<p>当我们调用一个函数，函数创建一个新的执行上下文，并将其推入调用栈的最顶端，使js优先执行。在执行完毕后，会返回一个返回值，然后函数的执行上下文被推出调用栈，执行上下文被垃圾回收机制回收，这是一个函数的生命周期。</p>
<p>但是，当函数返回一个在函数内部定义的函数时，情况变得稍微复杂起来。</p>
<p>当我们定义一个函数时，为了确保该函数能够访问其外部作用域的变量，js保留内部函数对外部函数变量的引用，此时，我们返回的不仅仅是一个函数体的代码，还有对齐定义时所在执行上下文的引用。所以即使外部执行函数已经执行完毕，但返回了内部函数，及内部函数与外部函数局部变量之间的联系。为了保持这种联系，也因为垃圾回收机制的原理，外部函数的变量数据并不会消失，仍保持着与内部函数的联系。但应为外部函数已经执行完毕，所以除了与内部函数之间的联系，通过其他方式无法找到这些数据。所以闭包的特殊之处在于它不仅仅是一个普通函数，还携带了定义时所在执行上下文（外部函数执行上下文）的数据，而且这个数据是存储在全局执行上下文中，但是除了内部函数外没有其他访问方式的。</p>
<p>这是js中最为美妙，最为深刻的概念！</p>
<p>在闭包中，js会保留内部函数引用的数据，回收其他未被引用的数据。复述一遍，我们得到了不止一个函数，还得到了一些因为被引用而保留下来的数据。</p>
<p>我想，这与引用类型传递的是指针而不是值本身有关系。（垃圾回收机制查看内存中那些数据没有被外部引用并进行回收，当我们执行外部函数时，数据被创建在内存中，外部函数执行完毕后，执行上下文被销毁。但是部分数据因为被内部函数引用，内部函数又因为被外部所引用，而保存下来。但是因为数据在外部函数的引用已经被销毁，只保留了内部函数对其的引用，所以只能通过内部函数来进行访问。）</p>
<h3 id="词法作用域-lexical-scope"><a href="#词法作用域-lexical-scope" class="headerlink" title="词法作用域(lexical scope)"></a>词法作用域(lexical scope)</h3><p>定义函数时，它会获得一个[[scope]]属性，该属性引用已定义它的本地内存/变量环境</p>
<blockquote>
<p>When a function is defined, it gets a [[scope]] property that references the Local Memory/Variable<br>Environment in which it has been defined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">incrementCounter</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    counter ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> incrementCounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myNewFunction = outer(); <span class="comment">// myNewFunction = incrementCounter</span></span><br><span class="line">myNewFunction();</span><br><span class="line">myNewFunction();</span><br></pre></td></tr></table></figure>
<p>当我们调用incrementCounter函数时，会首先查找他自己的本地存储空间（变量环境），然后在[[scope]]的next的属性中查找</p>
<blockquote>
<p>Wherever we call that incrementCounter function - it will always look first in its immediate local<br>memory (variable environment), and then in the [[scope]] property next before it looks any further up</p>
</blockquote>
<p>所以是否是因为函数也是一个对象，对象就有属性和方法，每一个函数都是Function的实例，在实例创建时，会有一个[[scope]]属性，这个属性应该也是一个对象，然后在[[scope]]中有一个next属性，指向了其定义时函数的[[scope]]属性。这样就可以沿着这个原型链来访问其中的数据。</p>
<h3 id="JavaScript的静态-词法范围-JavaScript-static-lexical-scoping"><a href="#JavaScript的静态-词法范围-JavaScript-static-lexical-scoping" class="headerlink" title="JavaScript的静态/词法范围(JavaScript static/lexical scoping)"></a>JavaScript的静态/词法范围(JavaScript static/lexical scoping)</h3><p>这就是当我们说JavaScript是词法或静态范围时，所表达的意思<br>我们的词法作用域（函数定义时可以使用的实时数据）决定了函数执行时可以访问的变量以及访问变量的优先顺序，而不是在函数调用时决定可以访问的数据及访问优先级。</p>
<blockquote>
<p>This is what it means when we say JavaScript is lexically or statically scoped<br>Our lexical scope (the available live data when our function was defined) is what determines our available variables and prioritization at function execution, not where our function is called</p>
</blockquote>
<p>当我们定义一个函数时，函数所能访问的数据就会被函数的[[scope]]属性所引用，这样就不会被垃圾回收机制回收，就会被一直保存下来，直到函数被销毁。</p>
<p>所以闭包是一个名词，代表着函数携带的数据，或者叫lexical scope reference。</p>
<p>当我们想访问闭包中的数据时，我们可以通过在内部函数中return来获取数据的指针。</p>
<p>当我们重新执行外部函数时，创建了一个新的执行上下文，返回了一个新的内部函数，如果新的内部函数引用了了新的外部函数执行上下文中的数据，那么显然，是一个新的数据。</p>
<p>在我们定义或者说声明一个函数时，我们给函数创建了一个新的词法作用域，引用了函数可以访问的数据。函数内部如果定义一个函数，同样会创建一个新的词法作用域，当然这个内部函数的词法作用域可以指向外部函数。当我们返回内部函数时，外部函数已经执行完毕，其执行上下文销毁，但是因为内部函数的词法作用域存在着对外部函数局部数据的引用，所以返回内部函数时也会返回一个词法作用域引用，也就是闭包。</p>
<h3 id="闭包的力量-The-power-of-Closure"><a href="#闭包的力量-The-power-of-Closure" class="headerlink" title="闭包的力量(The power of Closure)"></a>闭包的力量(The power of Closure)</h3><p>闭包可以使我们的函数有”记忆“，既可以操作闭包中的数据（私有变量）的内部函数来实现一个计时器或者”自动销毁“（执行一定次数后就不在执行回调函数）的函数。</p>
<p>我们也可应在js中通过闭包实现模块模式。（我们不想污染全局作用域）</p>
<blockquote>
<p>Now: Our functions get ‘memories’ - once, memoize<br>Advanced: We can implement the module pattern in JavaScript</p>
</blockquote>
<h2 id="异步的JavaScript-Asynchrous-JavaScript"><a href="#异步的JavaScript-Asynchrous-JavaScript" class="headerlink" title="异步的JavaScript(Asynchrous JavaScript)"></a>异步的JavaScript(Asynchrous JavaScript)</h2><p>异步是现代JavaScript网络开发的基石</p>
<blockquote>
<p>Asynchronicity is the backbone of modern web development in JavaScript</p>
</blockquote>
<p>JavaScript是单线程的（一次执行一个命令），并具有同步执行模型(按照每行代码的顺序执行)</p>
<blockquote>
<p>JavaScript is single threaded (one command executing at a time) and has a synchronous execution model (each line is executed in order the code appears)</p>
</blockquote>
<p>通过上面的学习，我们知道，JavaScript是单线程的(single thread)。这就意味着在js执行代码时一般是一行行解析执行。但这就引申出来一个问题，或者说一个需求：如果我们需要等待一段时间在执行一个功能(function)怎么办？</p>
<p>在实际的开发情况中，这是一个常见的需求。例如我们需要等待服务器返回一段数据之后再进行相应的操作，又或者设置一个定时器等。此时，我们就有了一个新的需求，既如何在不阻碍js继续解析执行的前提下，定义一个在一段时间后执行的函数（例如先获取用户数据，再根据用户的数据信息显示对应评论，同时不影响页面加载）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(“Hello”);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(printHello,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(“Me first!”);</span><br></pre></td></tr></table></figure>
<p>如果了解setTimeout函数的作用，我们知道，上面的代码首先会在控制台打印出Me first!，然后才是Hello。但是这与我们前面所学习的知识并不一致。那么，setTimeout函数的原理是什么，它为什么可以做出不符合我们之前所学习知识的行为？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(“Hello”);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(printHello,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(“Me first!”);</span><br></pre></td></tr></table></figure>
<p>分析上面代码，根据我们对setTimeout的函数作用的了解，我们可以知道控制台会首先打印出Me first!，然后是Hello。</p>
<p>以上两种结果的出现，并不是因为我们之前所学是错误的，是因为我们所学习的JavaScript执行模型是不完整的。</p>
<blockquote>
<p>Our previous model of JavaScript execution is insufficient</p>
</blockquote>
<p>既然有了新的需求，那么我们就要在JavaScript这个平台上添加新的功能。</p>
<p>在之前的学习中，我们在函数执行时，我们有如下三个组件</p>
<ul>
<li>Thread of execution（执行线程）</li>
<li>Memory/variable environment（变量环境）</li>
<li>Call stack（调用栈）</li>
</ul>
<p>现在因为新的需求，我们添加了一下三个组件</p>
<ul>
<li>Web Browser APIs/Node background threads（Web浏览器api /节点后台线程）</li>
<li>Callback/Message queue（回调函数/消息队列）</li>
<li>Event loop（事件循环）</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/FrontEndMasters/" rel="tag"># FrontEndMasters</a>
          
            <a href="/tags/JavaScript基础/" rel="tag"># JavaScript基础</a>
          
            <a href="/tags/闭包/" rel="tag"># 闭包</a>
          
            <a href="/tags/异步/" rel="tag"># 异步</a>
          
            <a href="/tags/执行上下文/" rel="tag"># 执行上下文</a>
          
            <a href="/tags/回调函数/" rel="tag"># 回调函数</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/18/评判事情的标准/" rel="next" title="评判事情的标准">
                <i class="fa fa-chevron-left"></i> 评判事情的标准
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://img.zcool.cn/community/04c6fd55fa1a4a000001b19c79e625.jpg@160w_160h_1c_1e_1o_100sh.jpg" alt="刘勇">
            
              <p class="site-author-name" itemprop="name">刘勇</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/blingblingredstar" title="GitHub &rarr; https://github.com/blingblingredstar" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:564447023@qq.com" title="E-Mail &rarr; mailto:564447023@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript的基本组成要素-Principles-of-JavaScript"><span class="nav-number">1.</span> <span class="nav-text">JavaScript的基本组成要素(Principles of JavaScript)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局执行上下文-global-execution-context"><span class="nav-number">1.1.</span> <span class="nav-text">全局执行上下文(global execution context)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js中的线程-Thread"><span class="nav-number">1.2.</span> <span class="nav-text">js中的线程(Thread)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地执行上下文-local-execution-context"><span class="nav-number">1.3.</span> <span class="nav-text">本地执行上下文(local execution context)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用堆栈-Call-Stack"><span class="nav-number">1.4.</span> <span class="nav-text">调用堆栈(Call Stack)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三个基本元素"><span class="nav-number">1.5.</span> <span class="nav-text">三个基本元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程-Funcitional-Programming"><span class="nav-number">2.</span> <span class="nav-text">函数式编程(Funcitional Programming)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#纯粹的函数-Pure-Functions"><span class="nav-number">2.1.</span> <span class="nav-text">纯粹的函数(Pure Functions)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回调函数和高阶函数-callbacks-and-high-order-functions"><span class="nav-number">3.</span> <span class="nav-text">回调函数和高阶函数(callbacks and high order functions)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#学习困难的事"><span class="nav-number">3.1.</span> <span class="nav-text">学习困难的事</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回调和高阶函数练习"><span class="nav-number">3.2.</span> <span class="nav-text">回调和高阶函数练习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于const和let"><span class="nav-number">3.3.</span> <span class="nav-text">关于const和let</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#广义函数-generalizing-functiongs"><span class="nav-number">3.4.</span> <span class="nav-text">广义函数(generalizing functiongs)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解构广义函数-deconstructing-generalize-function"><span class="nav-number">3.5.</span> <span class="nav-text">解构广义函数(deconstructing generalize function)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一等对象-first-class-object"><span class="nav-number">3.6.</span> <span class="nav-text">第一等对象(first-class object)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回调与高阶函数-callbacks-and-high-order-functions"><span class="nav-number">3.7.</span> <span class="nav-text">回调与高阶函数(callbacks and high order functions)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包-closure"><span class="nav-number">4.</span> <span class="nav-text">闭包(closure)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#练习"><span class="nav-number">4.1.</span> <span class="nav-text">练习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#词法作用域-lexical-scope"><span class="nav-number">4.2.</span> <span class="nav-text">词法作用域(lexical scope)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript的静态-词法范围-JavaScript-static-lexical-scoping"><span class="nav-number">4.3.</span> <span class="nav-text">JavaScript的静态/词法范围(JavaScript static/lexical scoping)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包的力量-The-power-of-Closure"><span class="nav-number">4.4.</span> <span class="nav-text">闭包的力量(The power of Closure)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步的JavaScript-Asynchrous-JavaScript"><span class="nav-number">5.</span> <span class="nav-text">异步的JavaScript(Asynchrous JavaScript)</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘勇</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
